{"meta":{"title":"F2E 星球通訊","subtitle":"DO！ Or DO Not！ There is NO TRY！","description":"","author":"POPEYE","url":"https://popeye-ux.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-04-13T15:00:35.000Z","updated":"2022-04-13T00:01:56.000Z","comments":false,"path":"categories/index.html","permalink":"https://popeye-ux.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"用給定的順序改變陣列本來的順序","slug":"js-resort-array","date":"2023-05-14T15:49:05.000Z","updated":"2023-05-14T16:02:27.171Z","comments":true,"path":"2023/05/14/js-resort-array/","link":"","permalink":"https://popeye-ux.github.io/2023/05/14/js-resort-array/","excerpt":"","text":"公司要提供客戶美食優惠券，公司資料庫中有客戶偏好的食物類型，我心想這個簡單，不就打個 API 就把資料取回來了嗎，取回的資料結果如下： const arr=[ &#123; name: \"小明\", type: \"牛排\", &#125;, &#123; name: \"小華\", type: \"壽司\", &#125;, &#123; name: \"小春\", type: \"燒肉\", &#125;, &#123; name: \"小陽\", type: \"義大利麵\", &#125;, &#123; name: \"小陽\", type: \"麥當勞\", &#125; ]; 但這時候，行銷部門的經理跑來說，這個名單要按照這樣的「”燒肉”,”牛排”,”壽司”,”麥當勞”,”義大利麵”」順序來排列。 要解決這個問題，我們可以先根據食物順序排定一個陣列： const typeOrder = [\"燒肉\",\"牛排\",\"壽司\",\"麥當勞\",\"義大利麵\"]; 然後利用 Array.prototype.indexOf() 與 Array.prototype.sort() 來重新排列原始陣列的順序： arr.sort((a, b) => &#123; console.log(typeOrder.indexOf(a.type)); console.log(typeOrder.indexOf(b.type)); return typeOrder.indexOf(a.type) - typeOrder.indexOf(b.type); &#125;); Array.prototype.indexOf()會回傳給定元素於陣列中第一個被找到之索引位置，若不存在於陣列中則回傳 -1。 Array.prototype.sort() 方法會原地（in place）對一個陣列的所有元素進行排序，並回傳此陣列。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript,array,sort,indexOf","slug":"JavaScript-array-sort-indexOf","permalink":"https://popeye-ux.github.io/tags/JavaScript-array-sort-indexOf/"}]},{"title":"網頁截圖功能 DOM to image","slug":"dom-to-image","date":"2023-03-17T15:43:26.000Z","updated":"2023-03-17T15:45:59.880Z","comments":true,"path":"2023/03/17/dom-to-image/","link":"","permalink":"https://popeye-ux.github.io/2023/03/17/dom-to-image/","excerpt":"","text":"最近在工作上需要寫網頁截圖的功能，所以稍微研究了一下 dom-to-image 這個插件，在我寫這篇筆記時的版本是 2.15.0。dom-to-imagenpm-dom-to-image 起手式npm如果要使用 npm 的方式可以參考以下安裝指令： npm install dom-to-image 官網範例**step1 ** node 參數放入要抓取截圖的 DOM 節點，config 的部分放入細部的設定。 &lt;script> domtoimage.toPng(node,config) //程式碼放的位置 &lt;/script> config&#96; 設定 const config = &#123; quality: 1, style: &#123; filter: \"grayscale(100%)\", width: \"600px\" &#125; &#125;; quality: 設定圖片的品質。 style: 可以套用濾鏡，也可以設定圖片的寬度與高度。 step2後面接非同步程式碼 var node = document.getElementById('my-node'); domtoimage.toPng(node) // 非同步程式碼 .then(function (dataUrl) &#123; var img = new Image(); // 產生圖片的網址 img.src = dataUrl; // 把圖片加入到 body 節點的下方 document.body.appendChild(img); &#125;) .catch(function (error) &#123; console.error('oops, something went wrong!', error); &#125;); 我在 CodePen 中加入一個按鈕，去監聽 click 事件，觸發 domtoimage ，擷取到 capture1 DOM 元素，轉為圖片， 然後把圖片的網址 append 到按鈕之後的 inserDiv 節點上。 See the Pen dom-to-image-append by POPEYE (@popeye_ux) on CodePen. 擷取 DOM 元素，下載圖片接下來加上以下程式碼，就可以做到截取 DOM 元素，轉為圖片之後下載的功能。 // 幫下載的圖片檔案名稱 const filename = \"popeye_Demo_\" + new Date().getTime(); // 下載的部分 var link = document.createElement(\"a\"); // 下載圖片的檔名 link.download = `$&#123;filename&#125;.jpeg`; link.href = dataUrl; link.click(); 完整 JS 程式碼 var node = document.getElementById(\"capture1\"); // config 參數設定 const config = &#123; quality: 1, style: &#123; filter: \"grayscale(100%)\", width: \"600px\" &#125; &#125;; const newnode = document.createElement(\"h2\"); const textnode = document.createTextNode(\"截到的圖\"); newnode.appendChild(textnode); // 觸發按鈕 const btn = document.getElementById(\"captureBtn\"); // 監聽觸發按鈕 domtoimage.toPng(node) captureBtn.addEventListener(\"click\", (e) => &#123; domtoimage .toPng(node, config) .then(function (dataUrl) &#123; var img = new Image(); img.src = dataUrl; const filename = \"popeye_Demo_\" + new Date().getTime(); // 下載的部分 var link = document.createElement(\"a\"); // 下載圖片的檔名 link.download = `$&#123;filename&#125;.jpeg`; link.href = dataUrl; link.click(); // 把截圖插入到指定的位置 const inserDiv = document.getElementById(\"insert\"); inserDiv.appendChild(newnode); inserDiv.appendChild(img); &#125;) .catch(function (error) &#123; console.error(\"oops, something went wrong!\", error); &#125;); &#125;); See the Pen dom-to-image by POPEYE (@popeye_ux) on CodePen. 參考資料 做一個簡單的網頁截圖功能 html2canvas 官網 https://dev.to/letswrite/jian-dan-de-wang-ye-jie-tu-gong-neng-dom-to-image-2h8d https://codepen.io/weilinzung/pen/VXzEaN https://stackblitz.com/edit/react-3j9qja?file=src%2FApp.js","categories":[{"name":"PlugIn","slug":"PlugIn","permalink":"https://popeye-ux.github.io/categories/PlugIn/"}],"tags":[{"name":"JavaScript, dom-to-image, plugin","slug":"JavaScript-dom-to-image-plugin","permalink":"https://popeye-ux.github.io/tags/JavaScript-dom-to-image-plugin/"}]},{"title":"Vue 實作 check box 全選與取消全選","slug":"vue-allchecked","date":"2023-03-09T14:07:52.000Z","updated":"2023-03-11T04:18:58.017Z","comments":true,"path":"2023/03/09/vue-allchecked/","link":"","permalink":"https://popeye-ux.github.io/2023/03/09/vue-allchecked/","excerpt":"","text":"Vue 實作 check box 全選與取消全選check box 全選與取消全選有 2 種做法可以實現這個功能，可以使用 methods 來實現，也可以使用 computed 來監聽「全選的核取框」。 使用 methods 方法實作 全選的 check box 雙向綁定到 allChecked 這個資料狀態，預設的布林值為 false。 checkList 這個資料狀態是一個陣列，存放所有的 check box 選項。 在 data 中準備一個 checkedItems 的空陣列。 使用 v-for 把 checkList 裡面的資料渲染成一個一個的 check box 選項，與 checkedItems 雙向綁定。 在 methods 中，準備一個 allCheckedFn 的方法，綁定change事件到「全選」的核取框，把 checkList 裡面的的選項 map 到一個 arr 空陣列，點擊全選的時候，allChecked會變成 true ，然後使用 三元運算式判斷，當 allChecked 為 true 的時候，checkedItems（與所有選項雙向綁定）會被賦值為 arr ，allChecked 為 false 的時候為空陣列：this.checkedHeros = this.allChecked ? arr : []; changeFn這個方法，比對 checkedHeros 的陣列長度與 核取框原始資料陣列長度 是否一致，返回一個布林值，賦值給 全選 allChecked 這個資料狀態。 &lt;div id&#x3D;&quot;app&quot;&gt; &lt;p&gt; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;select&quot; v-model&#x3D;&quot;allChecked&quot; @change&#x3D;&quot;allCheckedFn&quot;&gt; &lt;label for&#x3D;&quot;select&quot;&gt;全選&#x2F;反選&lt;&#x2F;label&gt; &lt;&#x2F;p&gt; &lt;!-- 注意下面 input 對應的都是 v-model&#x3D;&quot;checkedHeros&quot; --&gt; &lt;div v-for&#x3D;&quot;item in checkList&quot; :key&#x3D;&quot;item.id&quot; v-model&#x3D;&quot;checkedItems&quot;&gt; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;item.name&quot; :value&#x3D;&quot;item.name&quot; v-model&#x3D;&quot;checkedItems&quot; @change&#x3D;&quot;changeFn&quot;&gt; &lt;label for&#x3D;&quot;item.name&quot;&gt;&#123;&#123;item.id + item.name&#125;&#125;&lt;&#x2F;label&gt; &lt;&#x2F;div&gt; &lt;br&gt; &lt;p&gt;checkedItems: &#123;&#123; checkedItems &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; // 因為是複選的關係，這裡的 checkedHeros 是陣列 const vm = Vue.createApp(&#123; data () &#123; return &#123; // checkedHeros和複選框雙向綁定 checkedItems: [], allChecked: false, checkList:[&#123; name:'鋼鐵人', id:1, &#125;,&#123; name:'蜘蛛人', id:2, &#125;,&#123; name:'蟻人', id:3, &#125;] &#125; &#125;, methods:&#123; // 全選用的方法 allCheckedFn()&#123; let arr=[]; // heroList 是所有選項的清單，arr 這個陣列會裝進所有選項 this.checkList.map(item=>&#123; return arr.push(item.name); &#125;) // allChecked 和全選框綁定，如果是true，就是裝有所有選項的 arr 陣列（全選），如果 false ，就是空陣列（全不選） this.checkedItems = this.allChecked ? arr : []; &#125;, changeFn()&#123; // 比對 this.allChecked = this.checkedItems.length == this.checkList.length; console.log(this.allChecked); &#125; &#125; &#125;) vm.mount('#app'); See the Pen 全選或取消選取-methods by POPEYE (@popeye_ux) on CodePen. 使用 computed 實作 使用 computed 監聽 allChecked 這個資料狀態，然後 allChecked 與全選框綁定。checkedItems 與所有的選項雙向綁定。 get 的部分是監聽所有的選項，所有選項都打勾時，全選會被核取。 使用三元運算子，當 checkList 的陣列長度等於 checkedItems 的陣列長度時，全選會打勾。 set 的部分是監聽全選框，全選核取時，所有的選項都會打勾。 設一個 selected 空陣列，當全選框勾選時，value 為 true，會把 checkList 裡的選項推到 selected，把 selected 賦值給 checkedItems，這時所有選項都會打勾。 當全選框沒有勾選時， value 為 false，selected 為空陣列，checkedItems 裏沒有選項。&lt;div id&#x3D;&quot;app&quot;&gt; &lt;p&gt; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;select&quot; v-model&#x3D;&quot;allChecked&quot;&gt; &lt;label for&#x3D;&quot;select&quot;&gt;全選&#x2F;反選&lt;&#x2F;label&gt; &lt;&#x2F;p&gt; &lt;!-- 注意下面 input 對應的都是 v-model&#x3D;&quot;checkedHeros&quot; --&gt; &lt;div v-for&#x3D;&quot;item in checkList&quot; :key&#x3D;&quot;item.id&quot; &gt; &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;item.name&quot; :value&#x3D;&quot;item.name&quot; v-model&#x3D;&quot;checkedItems&quot;&gt; &lt;label for&#x3D;&quot;item.name&quot;&gt;&#123;&#123;item.id + item.name&#125;&#125;&lt;&#x2F;label&gt; &lt;&#x2F;div&gt; &lt;br&gt; &lt;p&gt;Checked heros: &#123;&#123; checkedItems &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; // 因為是複選的關係，這裡的 checkedHeros 是陣列 const vm = Vue.createApp(&#123; data() &#123; return &#123; checkedHeros: [], // allChecked: false, heroList: [ &#123; name: \"鋼鐵人\", id: 1, selected: false &#125;, &#123; name: \"蜘蛛人\", id: 2, selected: false &#125;, &#123; name: \"蟻人\", id: 3, selected: false &#125; ] &#125;; &#125;, computed: &#123; //allChecked 與 全選雙向綁定 allChecked: &#123; //當所有選項都選的時候，全選會打勾 get: function () &#123; return this.heroList ? this.checkedHeros.length === this.heroList.length : false; &#125;, //全選打勾時，所有選項都會打勾 set: function (value) &#123; // value 是 在全選 checkbox 上的勾選狀態，打勾時為 true，用 v-model 雙向綁定 // 暫存用陣列，用來存放被打勾的 checkbox value let selected = []; // 如果全選打勾 if (value) &#123; // 把可以勾的 選項 push 到暫存的 selected 陣列 this.heroList.forEach((item) => &#123; // 寫入暫存陣列 selected.push(item.name); &#125;); &#125; console.log(selected); // 將暫存陣列的值寫到已經勾選的容器陣列，表示全都勾（true），false 時會被清空，因為 selected 此時為空陣列 this.checkedHeros = selected; &#125; &#125; &#125; &#125;); vm.mount(\"#app\"); See the Pen 全選或取消選取-computed by POPEYE (@popeye_ux) on CodePen.","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://popeye-ux.github.io/categories/Vue3/"}],"tags":[{"name":"Vue3, JavaScript, checkbox, computed,methods","slug":"Vue3-JavaScript-checkbox-computed-methods","permalink":"https://popeye-ux.github.io/tags/Vue3-JavaScript-checkbox-computed-methods/"}]},{"title":"在 Option API 使用 ref 來操控 DOM 元素","slug":"vue-option-ref-basics","date":"2023-02-28T09:04:12.000Z","updated":"2023-02-28T09:05:58.483Z","comments":true,"path":"2023/02/28/vue-option-ref-basics/","link":"","permalink":"https://popeye-ux.github.io/2023/02/28/vue-option-ref-basics/","excerpt":"","text":"在原生的 Java Script 中常常會使用 id 來取得 DOM 元素，但是開發到最後常常會用了太多的 id，搞的 id 的名稱互相衝突。在 VUE 中提供了 $refs 的方法，讓我們用 ref 代替 id 來取得 DOM 元素。 ref 的作用： 用來選取與操控 DOM 元素。 用來取得元件的內容。 Bootstrap Modal 元件的封裝。 使用 ref 取得 DOM 元素在 input 標籤中加入 ref=&quot;inputDom&quot;，就可以在 Vue 中使用 this.$refs.inputDom選取到 input 輸入框。 HTML 部分&lt;div id&#x3D;&quot;app&quot;&gt; &lt;h3&gt;使用 ref 定義元素&lt;&#x2F;h3&gt; message: &lt;br&gt; &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&quot;inputDom&quot;&gt; &lt;&#x2F;div&gt; Vue.js 部分const app = &#123; data() &#123; return &#123; &#125; &#125;, methods:&#123; &#125;, mounted() &#123; console.log(this.$refs); &#125; &#125; Vue.createApp(app).mount('#app') 如圖所示，console.log(this.$refs);顯示取得的 DOM 元素。 See the Pen refs-1 by POPEYE (@popeye_ux) on CodePen. 讓 輸入框 一載入就 focushttps://codepen.io/popeye_ux/pen/ExeZKKM?editors=1111 使用 ref 來取得 DOM 元素的內容我們在 Vue 的實體上註冊了一個 &lt;card&gt; 元件，在 HTML 中插入 &lt;card ref=&quot;card&quot;&gt; &lt;/card&gt;，同時可以看到在 ref 屬性中定義了 card 的 DOM 名稱。 HTML 的部分&lt;div id&#x3D;&quot;app&quot;&gt; &lt;h3&gt;使用 ref 更新元件內容&lt;&#x2F;h3&gt; &lt;card ref&#x3D;&quot;card&quot;&gt; &lt;&#x2F;card&gt; &lt;button @click&#x3D;&quot;getComponentInfo&quot;&gt;取得元件資訊&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; Vue.js 的部分我們在 card 元件的 data 中定義了： title:'文件標題', content:'文件內文', 然後在父元件中定義了這樣的方法： getComponentInfo()&#123; console.log(this.$refs.card) this.$refs.card.title = '被更新的元件標題' this.$refs.card.content = '被更新的內文' &#125; 然後把 getComponentInfo() 方法綁定到 HTML 的 &lt;button&gt; 上面，就可以取得 &lt;car&gt; 元件裡的內容。 Vue.js 的完整內容const app = Vue.createApp( &#123; data() &#123; return &#123; &#125; &#125;, methods:&#123; getComponentInfo()&#123; console.log(this.$refs.card) this.$refs.card.title = '被更新的元件標題' this.$refs.card.content = '被更新的內文' &#125; &#125;, mounted() &#123; console.log(this.$refs); &#125; &#125;) app.component('card',&#123; data()&#123; return&#123; title:'文件標題', content:'文件內文', &#125; &#125;, template: ` &lt;div class=\"card\" width=\"18rem\"> &lt;h3>&#123;&#123;title&#125;&#125;&lt;/h3> &lt;p>&#123;&#123;content&#125;&#125;&lt;/p> &lt;/div> ` &#125;) app.mount('#app') 在 CodePen 上看看如何實作： See the Pen refs-card by POPEYE (@popeye_ux) on CodePen. Bootstrap Modal 封裝我們也可以利用 ref 來操作 Bootstrap Modal 的開關。 首先到 Bootstrap 官網把 Modal 的 HTML 碼 COPY 過來。 &lt;div id&#x3D;&quot;app&quot;&gt; &lt;div class&#x3D;&quot;btn btn-primary&quot; @click&#x3D;&quot;openModal&quot;&gt; 開啟 Modal &lt;&#x2F;div&gt; &lt;-- Modal --&gt; &lt;div class&#x3D;&quot;modal&quot; tabindex&#x3D;&quot;-1&quot; ref&#x3D;&quot;modal&quot;&gt; &lt;div class&#x3D;&quot;modal-dialog&quot;&gt; &lt;div class&#x3D;&quot;modal-content&quot;&gt; &lt;div class&#x3D;&quot;modal-header&quot;&gt; &lt;h5 class&#x3D;&quot;modal-title&quot;&gt;Modal title&lt;&#x2F;h5&gt; &lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;btn-close&quot; data-bs-dismiss&#x3D;&quot;modal&quot; aria-label&#x3D;&quot;Close&quot;&gt;&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;modal-body&quot;&gt; &lt;p&gt;Modal body text goes here.&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;modal-footer&quot;&gt; &lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;btn btn-secondary&quot; data-bs-dismiss&#x3D;&quot;modal&quot;&gt;Close&lt;&#x2F;button&gt; &lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;btn btn-primary&quot;&gt;Save changes&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; 其次把 Bootstrap 使用 JavaScript 操控 Modal 的方法 COPY 到 Mounted() 中： var myModal = new bootstrap.Modal(document.getElementById('myModal'), options) 接著改成下面這樣，new bootstrap.Modal 是用來建立一個 Modal 實體，this.bsModal 要在 data 中定義： this.bsModal = new bootstrap.Modal(this.$refs.modal); 在 methods 中定義打開 Modal 的方法，然後綁定到按鈕上面，(.show() 是 Bootstrap Modal 所提供的方法)： openModal() &#123; this.bsModal.show(); &#125; const app = Vue.createApp(&#123; data() &#123; return &#123; bsModal: \"\" &#125;; &#125;, methods: &#123; openModal() &#123; this.bsModal.show(); &#125; &#125;, mounted() &#123; console.log(this.$refs); // var myModal = new bootstrap.Modal(document.getElementById('myModal'), options) // 建立實體 this.bsModal = new bootstrap.Modal(this.$refs.modal); &#125; &#125;); app.mount(\"#app\"); See the Pen refs-card by POPEYE (@popeye_ux) on CodePen.","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://popeye-ux.github.io/categories/Vue3/"}],"tags":[{"name":"Vue3, JavaScript, ref, Modal","slug":"Vue3-JavaScript-ref-Modal","permalink":"https://popeye-ux.github.io/tags/Vue3-JavaScript-ref-Modal/"}]},{"title":"VUE 直播班上課心得","slug":"wall","date":"2023-02-28T02:52:09.000Z","updated":"2023-02-28T04:39:31.555Z","comments":true,"path":"2023/02/28/wall/","link":"","permalink":"https://popeye-ux.github.io/2023/02/28/wall/","excerpt":"","text":"當初為什麼報名這堂課？我曾經參加過 2022 春季 VUE 直播班，後來去當了一陣子的 PM。本以為沒機會當工程師了，因緣際會，拿了直播班的作品去參加了一場面試，結果順利拿到了工作機會。因為有半年時間沒有接觸程式，所以想要重新複習一下 VUE 的語法與使用。 第一週~第八週的學習過程雖然每周五下班都累得像條狗，上課也是偶而會打瞌睡，還是撐著上完了，連假日直播也都沒有錯過。第八周課程的那一天剛好也是我通過試用期的日子，覺得努力沒有白費。 最大的收獲是？重新在學一次 VUE 的語法，發覺自己之前雖然懂了，但是不知道該怎麼用。有許多語法的使用場景在上一次課之後已經可以想像與觸類旁通，許多都已經用在工作實戰的任務中了。 最喜歡直播班的哪些活動？最喜歡的活動是每日任務。 如果時光能倒流，會希望自己再次注意哪些細節？一邊適應新工作，一邊上課，沒有時間可以參與最終作業的考驗，覺得很對不起老師，之後還是會把最終作業做完的。 對課程的建議或鼓勵？我覺得今年老師的功力又進步了，對於同學的學習狀況也更能掌握。今年少了 Ray 助教，覺得有點寂寞。 身為學長姐，分享些想入坑的新同學一些勉勵的話每日任務一定要做，小小的練習卻能把基礎穩穩地札好。","categories":[{"name":"雜記","slug":"雜記","permalink":"https://popeye-ux.github.io/categories/%E9%9B%9C%E8%A8%98/"}],"tags":[{"name":"雜記","slug":"雜記","permalink":"https://popeye-ux.github.io/tags/%E9%9B%9C%E8%A8%98/"}]},{"title":"Vee-Validate 4 表單驗證簡單上手","slug":"vue-vee-validate4","date":"2023-02-17T16:27:46.000Z","updated":"2023-02-17T16:34:32.436Z","comments":true,"path":"2023/02/18/vue-vee-validate4/","link":"","permalink":"https://popeye-ux.github.io/2023/02/18/vue-vee-validate4/","excerpt":"","text":"在開發中驗證表單欄位是一件前後端都必須處理的事情，不僅前端要驗證使用者輸入的欄位資訊，後端也要驗證送往伺服器的資料。 而前端的驗證如果要自己寫，會牽扯到正則，而且也會容易掛一漏萬，所以如果要在 Vue 裡面進行表單驗證，通常會引用套件，但是並不是所有的套件都支援中文語系。 Vee-Validate 是目前比較完整而且支援繁體中文語系的驗證套件。雖然說是套件，如果你去看 Vee-Validate 的官網，保證看完了，還是一頭霧水。所以我整理了 Vee-Validate 的使用方法，以防自己下次要用又失憶了。 Vee-Validate 官網：https://vee-validate.logaretm.com/v4/ 因為目前我所使用的是 Vue 3 的版本，所以要搭配 Vee-Validate 4.0 以上版本，在安裝的時候要注意版本相匹配的問題。 安裝 Vee-Validate安裝時除了 Vee-Validate 主程式之外，還要安裝驗證規則（rules）及多國語系（i18n）。 npm i vee-validate @vee-validate/i18n @vee-validate/rules @vee-validate/i18n --save 只要在 main.js 中設定，多國語系（i18n）就會把驗證的錯誤訊息轉成繁體中文。 例如： “email”: “{field} 須為有效的電子信箱”, {field} 的部分會填入對應的欄位名稱。 繁體中文驗證顯示內容。 main.js 設定在 main.js 中引入套件之外，同時把相關的規則及元件做全域註冊，就不用在每個需要做驗證的 vue 檔案中一一匯入。 import &#123; createApp &#125; from \"vue\"; import &#123; createPinia &#125; from \"pinia\"; import App from \"./App.vue\"; import router from \"./router\"; // 匯入 vee-validate 主套件 import &#123; Field, Form, ErrorMessage, defineRule, configure &#125; from \"vee-validate\"; // 匯入 vee-validate 相關規則 import &#123; required, email, min, numeric, max_value, min_value, between, digits &#125; from \"@vee-validate/rules\"; // import * as rules from '@vee-validate/rules'; // 匯入多國語系的功能 import &#123; localize, setLocale &#125; from \"@vee-validate/i18n\"; // 匯入繁體中文語系檔案 import zhTW from \"@vee-validate/i18n/dist/locale/zh_TW.json\"; const app = createApp(App); // 定義驗證規則 defineRule(\"required\", required); defineRule(\"email\", email); defineRule(\"min\", min); // 數字，但是小數點會認為是非數字 defineRule(\"numeric\", numeric); defineRule(\"max_value\", max_value); defineRule(\"min_value\", min_value); // between 可以驗證 某個區間的數字，例如 5~10 defineRule(\"between\", between); // digits 限制小數點後幾位數 defineRule(\"digits\", digits); // 設定 vee-validate 全域規則 configure(&#123; generateMessage: localize(&#123; zh_TW: zhTW &#125;), // 載入繁體中文語系 validateOnInput: true, // 當輸入任何內容直接進行驗證 &#125;); // 設定預設語系 setLocale(\"zh_TW\"); // 註冊 vee-validate 三個全域元件 app.component(\"Form\", Form); app.component(\"Field\", Field); app.component(\"ErrorMessage\", ErrorMessage); app.mount(\"#app\"); 也可以使用這種方法把全部的規則都引入，就不用像上面一樣一一定義驗證規則。 import &#123; defineRule &#125; from 'vee-validate'; import * as rules from '@vee-validate/rules'; Object.keys(rules).forEach(rule => &#123; defineRule(rule, rules[rule]); &#125;); 表單欄位的設定表單的頭尾要用大寫 F 開頭的 &lt;Form&gt; 包住， v-slot=”&#123; errors &#125;” 則對應到錯誤訊息欄位。 &lt;Form ref=\"form\" @submit=\"submitOrders\" v-slot=\"&#123; errors &#125;\"> &lt;/Form> 原本的 &lt;input&gt;Z標籤用 標籤取代， 其中 name 會對應到 的 name，如果欄位輸入錯誤，以 email 欄位為例，就會出現：「email 為必填」。 rules=&quot;email|required&quot; 則會去抓 main.js 中定義的表單規則。 :class=&quot;&#123; &#39;is-invalid&#39;: errors[&#39;email&#39;] &#125;&quot; 輸入驗證錯誤則會綁定 Bootstrap 中 is-invalid 樣式，讓輸入框的 border 變成紅色的。 &lt;Field id=\"email\" name=\"email\" type=\"email\" class=\"form-control\" rules=\"email|required\" :class=\"&#123; 'is-invalid': errors['email'] &#125;\" placeholder=\"請輸入 Email\" v-model=\"form.user.email\">&lt;/Field> &lt;ErrorMessage name=\"email\" class=\"invalid-feedback\">&lt;/ErrorMessage> &lt;button&gt; 的 disabled 有綁訂到 Vee-Validate 的 errors 物件，如果陣列長度大於 0，按鈕就不能按。 &lt;button type=\"submit\" class=\"btn btn-lg w-100 add-btn\" @submit=\"submitOrders\" :disabled=\"Object.keys(errors).length > 0\"> 送出訂單 &lt;/button> &lt;Form ref=\"form\" @submit=\"submitOrders\" v-slot=\"&#123; errors &#125;\"> &lt;div class=\"mb-3\"> &lt;label for=\"email\" class=\"form-label\">Email&lt;span class=\"form-note\">*&lt;/span>&lt;/label> &lt;Field id=\"email\" name=\"email\" type=\"email\" class=\"form-control\" rules=\"email|required\" :class=\"&#123; 'is-invalid': errors['email'] &#125;\" placeholder=\"請輸入 Email\" v-model=\"form.user.email\">&lt;/Field> &lt;ErrorMessage name=\"email\" class=\"invalid-feedback\">&lt;/ErrorMessage> &lt;/div> &lt;div class=\"mb-3\"> &lt;label for=\"name\" class=\"form-label\">收件人姓名&lt;span class=\"form-note\">*&lt;/span>&lt;/label> &lt;Field id=\"name\" name=\"姓名\" type=\"text\" class=\"form-control\" :class=\"&#123; 'is-invalid': errors['姓名'] &#125;\" placeholder=\"請輸入姓名\" rules=\"required\" v-model=\"form.user.name\">&lt;/Field> &lt;ErrorMessage name=\"姓名\" class=\"invalid-feedback\">&lt;/ErrorMessage> &lt;/div> &lt;div class=\"mb-3\"> &lt;label for=\"tel\" class=\"form-label\">收件人電話&lt;span class=\"form-note\">*&lt;/span>&lt;/label> &lt;Field id=\"tel\" name=\"電話\" type=\"text\" class=\"form-control\" :rules=\"isPhone\" :class=\"&#123; 'is-invalid': errors['電話'] &#125;\" placeholder=\"請輸入電話\" v-model=\"form.user.tel\">&lt;/Field> &lt;ErrorMessage name=\"電話\" class=\"invalid-feedback\">&lt;/ErrorMessage> &lt;/div> &lt;div class=\"mb-3\"> &lt;label for=\"address\" class=\"form-label\">收件人地址&lt;span class=\"form-note\">*&lt;/span>&lt;/label> &lt;Field id=\"address\" name=\"地址\" type=\"text\" class=\"form-control\" :class=\"&#123; 'is-invalid': errors['地址'] &#125;\" placeholder=\"請輸入地址\" rules=\"required\" v-model=\"form.user.address\">&lt;/Field> &lt;ErrorMessage name=\"地址\" class=\"invalid-feedback\">&lt;/ErrorMessage> &lt;/div> &lt;div class=\"mb-3\"> &lt;label for=\"message\" class=\"form-label\">留言&lt;/label> &lt;textarea id=\"message\" class=\"form-control\" cols=\"30\" rows=\"10\" v-model=\"form.message\">&lt;/textarea> &lt;/div> &lt;div class=\"text-end\"> &lt;button type=\"submit\" class=\"btn btn-lg w-100 add-btn\" @submit=\"submitOrders\" :disabled=\"Object.keys(errors).length > 0\"> 送出訂單 &lt;/button> &lt;/div> &lt;/Form> Script 中的設定表單的 v-model 有綁訂到 data 的 form 物件。 button 綁定的 submitOrders 方法是打 API 把訂單送去後端。 data () &#123; return &#123; form: &#123; user: &#123; name: '', email: '', tel: '', address: '' &#125;, message: '' &#125;, &#125; &#125;, 其中手機號碼的驗證規則，也寫在 methods 裡面： methods: &#123; // validate isPhone (value) &#123; const phoneNumber = /^(09)[0-9]&#123;8&#125;$/ return phoneNumber.test(value) ? true : '需要正確的電話號碼' &#125;, &#125; 久久寫一次驗證，發覺自己有點失意，寫個筆記，希望下次可以不用花那麼久的時間重新探索。 參考： https://stackblitz.com/edit/vue-3-veevalidate-form-validation-example?file=src%2FApp.vue https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;@vee-validate&#x2F;rules","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://popeye-ux.github.io/categories/Vue3/"}],"tags":[{"name":"Vue3, JavaScript, Vee-Valdate, Validate","slug":"Vue3-JavaScript-Vee-Valdate-Validate","permalink":"https://popeye-ux.github.io/tags/Vue3-JavaScript-Vee-Valdate-Validate/"}]},{"title":"Vite 設定開發環境與正式環境使用不同的 G-tag","slug":"vue-env-gtag","date":"2023-02-11T17:29:27.000Z","updated":"2023-02-11T17:31:09.410Z","comments":true,"path":"2023/02/12/vue-env-gtag/","link":"","permalink":"https://popeye-ux.github.io/2023/02/12/vue-env-gtag/","excerpt":"","text":"PM 開了一項需求，希望在開發環境與正式部屬環境使用不同的 Google-Analytics 的評估碼 g-tag，之前在開發的時候都是寫死的，剛聽到這個需求，我有點不明所以。 請教了有處理過這個 issue 的前輩，才明白是使用了 vite-plugin-html 這個插件，分別在不同環境的env 檔案寫入對應的 g-tag，然後動態依據不同環境替換不同的 g-tag。 首先安裝 vite-plugin-html ： npm i vite-plugin-html -D 然後 vite 的根目錄，建立 .env 、.env.development 及 .env.production 三個檔案。 .env 通用的環境變數 .env.development 開發中的環境變數 .env.production 產品完成布署的環境 .env 裡面寫入： VITE_BASE_URL=/ VITE_GATAG=G-AAAAAAAAAA .env.development 裡面寫入： VITE_GATAG-AAAAAAAAAA .env.production 裡面寫入： VITE_GATAG=G-BBBBBBBBBB 原本的 vite.config.js 長這樣： import &#123; fileURLToPath, URL &#125; from \"node:url\"; import &#123; defineConfig &#125; from \"vite\"; import vue from \"@vitejs/plugin-vue\"; // https://vitejs.dev/config/ export default defineConfig(&#123; plugins: [vue()], resolve: &#123; alias: &#123; \"@\": fileURLToPath(new URL(\"./src\", import.meta.url)), &#125;, &#125;, // 解決 Network: use --host to expose server: &#123; host: \"0.0.0.0\", &#125;, &#125;); 然後現在把 vite.config.js 改成： import &#123; fileURLToPath, URL &#125; from \"node:url\"; // import path from \"path\"; import &#123; defineConfig, loadEnv &#125; from \"vite\"; import vue from \"@vitejs/plugin-vue\"; import &#123; createHtmlPlugin &#125; from \"vite-plugin-html\"; // https://vitejs.dev/config/ export default (&#123; mode &#125;) => &#123; process.env = &#123; ...process.env, ...loadEnv(mode, process.cwd()) &#125;; return defineConfig(&#123; base: process.env.VITE_BASE_URL, plugins: [ vue(), createHtmlPlugin(&#123; minify: true, inject: &#123; data: &#123; GA4: process.env.VITE_GATAG, // injectScript: `&lt;script src=\"./inject.js\">&lt;/script>`, &#125;, &#125;, &#125;), ], resolve: &#123; alias: &#123; \"@\": fileURLToPath(new URL(\"./src\", import.meta.url)), &#125;, &#125;, &#125;); &#125;; 然後修改根目錄的 index.html，把原本放 g-tag 的地方替換成 &lt;%- GATAG %&gt;： &lt;!DOCTYPE html&gt; &lt;html lang&#x3D;&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt; &lt;link rel&#x3D;&quot;icon&quot; href&#x3D;&quot;&#x2F;favicon.ico&quot; &#x2F;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt; &lt;title&gt;標題&lt;&#x2F;title&gt; &lt;!-- Global site tag (gtag.js) - Google Analytics --&gt; &lt;script async src&#x3D;&quot;https:&#x2F;&#x2F;www.googletagmanager.com&#x2F;gtag&#x2F;js?id&#x3D;&lt;%- GATAG %&gt;&quot; &gt;&lt;&#x2F;script&gt; &lt;script&gt; window.dataLayer &#x3D; window.dataLayer || []; function gtag() &#123; dataLayer.push(arguments); &#125; gtag(&quot;js&quot;, new Date()); gtag(&quot;config&quot;, &quot;&lt;%- GATAG %&gt;&quot;); &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt; &lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;&#x2F;src&#x2F;main.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://popeye-ux.github.io/categories/Vue3/"}],"tags":[{"name":"Vue3, Javascript, env, g-tag","slug":"Vue3-Javascript-env-g-tag","permalink":"https://popeye-ux.github.io/tags/Vue3-Javascript-env-g-tag/"}]},{"title":"Vue router 有沒有 hash 有差別","slug":"vue-router-historymode","date":"2023-02-11T17:10:36.000Z","updated":"2023-02-11T17:19:33.697Z","comments":true,"path":"2023/02/12/vue-router-historymode/","link":"","permalink":"https://popeye-ux.github.io/2023/02/12/vue-router-historymode/","excerpt":"","text":"Vue 3 主要有 2 種處理路由的方式，分別是 Hash Mode 以及 HTML5 (History API) Mode 兩種。(其實還有一種 abstract 模式) createWebHashHistory 模式網址列多了一個 # 字號。 Hash 也就是 我們用來設定連結錨點的那個 # 字號。 &lt;a hhref&#x3D;&quot;https:&#x2F;&#x2F;xxx.com&#x2F;#hashmark&quot;&gt;&lt;&#x2F;a&gt; 利用改變#後面對應到 HTML 檔案 id 的文字，就可以不用換頁，又可以在瀏覽器中留下「上一頁」與「下一頁」的歷史紀錄，而且切換時不會刷新頁面。 createWebHashHistory 模式預設的路徑為 location.pathname 或 &#x2F; 根目錄，也可以改變預設路徑，使用 createWebHashHistory(‘&#x2F;folder&#x2F;‘)，就可以對應到 https://xxxx.com/folder/# 。 Hash 模式完全是前端模式，只在瀏覽器中動作，不牽扯後端，缺點是對 SEO 不利，因為搜尋引擎會自動忽略 URL 有 # 的部分。 router.js import &#123; createRouter, createWebHashHistory &#125; from 'vue-router' import HomeView from '../views/HomeView.vue' const router = createRouter(&#123; history: createWebHashHistory(import.meta.env.BASE_URL), routes: [ &#123; path: '/', name: 'home', component: HomeView &#125;, &#123; path: '/about', name: 'about', // route level code-splitting // this generates a separate chunk (About.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () => import('../views/AboutView.vue') &#125; ] &#125;) export default router createWebHistory 模式如果是 createWebHistory 就是採用 HTML5 的 History API，可以使用 pushState()、replaceState() 等方法更新 URL，搭配原有的 history.go()、history.back()來指定頁面路徑切換，如，也提供了 state 物件讓開發這可以暫時存取網頁的狀態。 &lt;a hhref&#x3D;&quot;https:&#x2F;&#x2F;xxx.com&#x2F;path&quot;&gt;&lt;&#x2F;a&gt; 需要搭配後端路由，如果沒有後端的配置，使用者直接輸入網址，或瀏覽器重整網頁的時候會找不到網頁，跳 404 頁面。 router.js import &#123; createRouter, createWebHistory &#125; from 'vue-router' import HomeView from '../views/HomeView.vue' const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), routes: [ &#123; path: '/', name: 'home', component: HomeView &#125;, &#123; path: '/about', name: 'about', // route level code-splitting // this generates a separate chunk (About.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () => import('../views/AboutView.vue') &#125; ] &#125;) export default router","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://popeye-ux.github.io/categories/Vue3/"}],"tags":[{"name":"Vue3, JavaScript, createWebHashHistory, createWebHistory","slug":"Vue3-JavaScript-createWebHashHistory-createWebHistory","permalink":"https://popeye-ux.github.io/tags/Vue3-JavaScript-createWebHashHistory-createWebHistory/"}]},{"title":"在 Vue 裡面使用 pinia 管理狀態","slug":"piniabeginner","date":"2023-02-05T16:28:02.000Z","updated":"2023-02-11T17:14:12.137Z","comments":true,"path":"2023/02/06/piniabeginner/","link":"","permalink":"https://popeye-ux.github.io/2023/02/06/piniabeginner/","excerpt":"","text":"pinia 是 Vue 官方推薦的狀態管理工具，可以解決跨元件之間資料傳遞要反覆的 props 及 emit 的問題，只要把資料跟方法放在 store 裡面，就可以讓所有的元件取用，不但傳遞變簡單了，在管理資料上面也變得更清楚。 首先安裝 pinia npm install pinia main.js 中初始化 import &#123; createApp &#125; from \"vue\"; import App from \"./App.vue\"; import &#123; createPinia &#125; from \"pinia\"; const pinia = createPinia(); const app = createApp(App); app.use(pinia); app.mount(\"#app\"); 在 src 下面建立 stores 資料夾，然後在 stores 裡面建立 user.js。 import &#123; defineStore &#125; from \"pinia\"; // userStore 為自定義名稱 // &#123;屬性參數&#125; export default defineStore(\"userStore\", &#123; // data state: () => (&#123; name: \"鋼鐵人\", friend: \"蜘蛛人\" &#125;), // computed getters: &#123; getUserName(state) &#123; return `$&#123;state.name&#125; 和 $&#123;state.friend&#125;是好朋友`; &#125; &#125;, // methods actions: &#123; // 可以使用 this，所以不用箭頭函式 updateFriend() &#123; this.friend = \"美國隊長\"; &#125; &#125; &#125;); HelloWorld.vue &lt;template> &lt;div class=\"hello\"> &lt;h1>&#123;&#123; msg &#125;&#125;&lt;/h1> &lt;h2>&#123;&#123; name &#125;&#125;,&#123;&#123; friend &#125;&#125;&lt;/h2> &lt;h2>&#123;&#123; getUserName &#125;&#125;&lt;/h2> &lt;button type=\"button\" @click=\"updateFriend\">更新復仇者好友&lt;/button> &lt;/div> &lt;/template> &lt;script> import &#123; mapState, mapActions &#125; from \"pinia\"; import userStore from \"@/stores/user\"; export default &#123; name: \"HelloWorld\", props: &#123; msg: String, &#125;, computed: &#123; ...mapState(userStore, [\"name\", \"friend\", \"getUserName\"]), &#125;, methods: &#123; ...mapActions(userStore, [\"updateFriend\"]), &#125;, &#125;; &lt;/script> 在 Composition 中使用 pinia簡單初始化，首先 import userStore from \"@/stores/user\"; 使用 reactive 格式然後在 setup() 把 userStore 賦值給一個常數 user，記得要 把 user 給 return 出去。 然後在 HTML 中使用 &#123;&#123; user.變數名稱或方法 &#125;&#125; ， 就可以綁定 user.js 裡面 state 定義的資料、 getters 及 actions 中的方法，而且這樣的情形下，資料及方法都是 reactive 格式的，所以可以做到雙向綁定。 HelloWorld.vue &lt;template> &lt;div class=\"hello\"> &lt;h1>&#123;&#123; msg &#125;&#125;&lt;/h1> &lt;h2>&#123;&#123; user.name &#125;&#125;,&#123;&#123; user.friend &#125;&#125;&lt;/h2> &lt;h2>&#123;&#123; user.getFriendName &#125;&#125;&lt;/h2> &lt;button type=\"button\" @click=\"user.updateFriend\">更新復仇者好友&lt;/button> &lt;/div> &lt;/template> &lt;script> import userStore from \"@/stores/user\"; export default &#123; name: \"HelloWorld\", props: &#123; msg: String, &#125;, setup() &#123; const user = userStore(); //state 中的資料為 reactive 格式 return &#123; user, &#125;; &#125;, &#125;; &lt;/script> 使用 ref 格式要使用 ref 格式，除了 import userStore from &quot;@/stores/user&quot;;之外，還必須匯入一個 pinia 提供的 &#123; storeToRefs &#125; 方法，把 store 中定義的方法跟資料轉為 ref 格式： import &#123; storeToRefs &#125; from \"pinia\"; 然後在 setup() 中，取出 store 中的變數及方法： const &#123; name, friend, getFriendName &#125; = storeToRefs(user); // 如果要改變 變數的值，記得加上 .value name.value = '雷神' return 的時候除了 user 之外， name 、 friend 及 getFriendName 也要記得 return 出去。 這時 HTML 中的 &#123;&#123; user.xxxx &#125;&#125; 就可以拿掉了。但是如果要在 setup() 中更改 變數的值，就要像使用 ref 一樣，加上 xxxx.value 。 如果在 state 中不用作到雙向綁定的，就直接取出 // 不用雙向綁定 直接取出 const &#123; updateFriend &#125; = user; HelloWorld.vue &lt;template> &lt;div class=\"hello\"> &lt;h1>&#123;&#123; msg &#125;&#125;&lt;/h1> &lt;h2>&#123;&#123; user.name &#125;&#125;,&#123;&#123; user.friend &#125;&#125;&lt;/h2> &lt;h2>&#123;&#123; user.getFriendName &#125;&#125;&lt;/h2> &lt;!-- user 可以拿掉 --> &lt;h2>&#123;&#123; name &#125;&#125;,&#123;&#123; friend &#125;&#125;&lt;/h2> &lt;h2>&#123;&#123; getFriendName &#125;&#125;&lt;/h2> &lt;!-- 雙向綁定也可以 --> &lt;input type=\"text\" v-model=\"user.name\" /> &lt;button type=\"button\" @click=\"user.updateFriend\">更新復仇者好友&lt;/button> &lt;/div> &lt;/template> &lt;script> import &#123; storeToRefs &#125; from \"pinia\"; import userStore from \"@/stores/user\"; export default &#123; name: \"HelloWorld\", props: &#123; msg: String, &#125;, setup() &#123; const user = userStore(); // 轉成 ref 格式 const &#123; name, friend, getFriendName &#125; = storeToRefs(user); // ref 格式，state 中的變數須加上 .value name.value = \"雷神\"; // 不用雙向綁定 直接取出 const &#123; updateFriend &#125; = user; return &#123; user, name, friend, getFriendName, &#125;; &#125;, &#125;; &lt;/script> 使用 pinia 提供的 patch 方法修改資料： function updateData() &#123; user.$patch(&#123; name: \"浩克\", friend: \"薩諾斯\", &#125;); &#125; 使用 pinia 提供的 reset 方法重置資料： function reset() &#123; user.$reset(); &#125;","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://popeye-ux.github.io/categories/Vue3/"}],"tags":[{"name":"Vue, pinia, compositionAPI, optionAPI","slug":"Vue-pinia-compositionAPI-optionAPI","permalink":"https://popeye-ux.github.io/tags/Vue-pinia-compositionAPI-optionAPI/"}]},{"title":"在 Composition API 中使用 pinia 操控 modal","slug":"modal-pinia","date":"2023-01-29T15:18:09.000Z","updated":"2023-02-11T17:13:55.118Z","comments":true,"path":"2023/01/29/modal-pinia/","link":"","permalink":"https://popeye-ux.github.io/2023/01/29/modal-pinia/","excerpt":"","text":"之前寫過一篇在 《在 Composition API 中使用 props 與 emit 操控 modal》的筆記，那時是使用 props 跟 emit 處理外部元件與內部元件之間資料傳遞的問題。 但是當有兩個以上的 modal&#x2F;彈跳視窗 的時候，第一個 modal 是開啟狀態，這時觸發第二個 modal 開啟，同時第一個 modal 要關閉。這種情形下，兩個內部元件彼此要傳遞訊息變得十分複雜，這次我試著用 pinia 來管理兩個 modal 的狀態，狀態就不再儲存在兩個 modal 元件內部。 任務說明在 pinia 中有 isFirstOpen 跟 isSecondOpen 兩個變數，用來管理 2 個元件的開啟與關閉，預設都是 false， 內部元件則用 v-if 控制元件的顯示與否，在 false 狀態，兩個元件皆為關閉，當有一個元件被開啟，則另外一個元件的狀態則會轉為 false(預設也是 false)。 假設第一個元件是開啟狀態，isFirstOpen 的狀態為 true，第二個元件的狀態isSecondOpen 為 false 。這時去開啟第二個元件，isSecondOpen 轉為 true，則isFirstOpen 轉為 false，第一個元件就會關閉，反之亦然。這樣就可以達到切換2個 modal 的目的。 檔案結構如下： main.js 引入 piniaimport &#123; createApp &#125; from \"vue\"; import App from \"./App.vue\"; import &#123; createPinia &#125; from \"pinia\"; const pinia = createPinia(); const app = createApp(App); app.use(pinia); app.mount(\"#app\"); pinia 中 modalControl.js 的設定stores&#x2F;modalControl.js import &#123; defineStore &#125; from \"pinia\"; export default defineStore(\"modalControl\", &#123; state: () => (&#123; name: \"胖胖\", isFirstOpen: false, isSecondOpen: false &#125;) &#125;); app.vue 中的設定 把兩個元件 import 進來，當成子元件。 把 pinia 中的狀態及方法匯入。import &#123; storeToRefs &#125; from &quot;pinia&quot;import modalControl from &quot;@/stores/modalControl.js&quot;; 設定開啟及切換 modal 的方法 const openModal = function () &#123; isFirstOpen.value = true; isSecondOpen.value = false; &#125;; // 開啟第二個 modal，關閉第一個 modal const openSecond = function () &#123; isSecondOpen.value = true; isFirstOpen.value = false; &#125;; 將兩個按鈕綁上開啟 modal 的方法。 &lt;button type=\"button\" class=\"btn\" @click=\"openModal\">showModal&lt;/button> &lt;button type=\"button\" class=\"btn\" @click=\"openSecond\">showModal2&lt;/button> app.vue &lt;template> &lt;div class=\"up\"> &lt;button type=\"button\" class=\"btn\" @click=\"openModal\">showModal&lt;/button> &lt;button type=\"button\" class=\"btn\" @click=\"openSecond\">showModal2&lt;/button> &lt;/div> &lt;!-- &lt;Modal :open=\"isOpen\" @close=\"isOpen = !isOpen\"> --> &lt;Modal> &lt;p> &#123;&#123; name &#125;&#125; Lorem ipsum dolor, sit amet consectetur adipisicing elit. Quo molestiae consectetur blanditiis aspernatur velit autem labore amet &lt;/p> &lt;/Modal> &lt;SecondModal> &lt;p> &#123;&#123; name &#125;&#125; Lorem ipsum dolor, sit amet consectetur adipisicing elit. Quo molestiae consectetur blanditiis aspernatur velit autem labore amet &lt;/p> &lt;/SecondModal> &lt;/template> &lt;script> import &#123; ref &#125; from \"vue\"; // 第一個元件 import Modal from \"./components/ModalView.vue\"; // 第二個元件 import SecondModal from \"./components/SecondModal.vue\"; // pinia 中共用的狀態 import modalControl from \"@/stores/modalControl.js\"; // 使用 pinia 中資料的方法 import &#123; storeToRefs &#125; from \"pinia\"; // import HelloWorldVue from \"./components/HelloWorld.vue\"; export default &#123; components: &#123; Modal, SecondModal &#125;, setup() &#123; // 把 pinia 中元件共用的狀態，賦值給 modaltest 這個變數 const modaltest = modalControl(); // 解構 const &#123; name, isFirstOpen, isSecondOpen &#125; = storeToRefs(modaltest); // const isOpen = ref(false); // 開啟第一個 modal，關閉第二個 modal const openModal = function () &#123; isFirstOpen.value = true; isSecondOpen.value = false; &#125;; // 開啟第二個 modal，關閉第一個 modal const openSecond = function () &#123; isSecondOpen.value = true; isFirstOpen.value = false; &#125;; return &#123; isFirstOpen, modalControl, name, isSecondOpen, openModal, openSecond, &#125;; &#125;, &#125;; &lt;/script> &lt;style> .up &#123; z-index: 500; cursor: pointer; &#125; &lt;/style> 2 個 modal 元件的設定ModalView.vue &lt;template> &lt;transition name=\"fade\"> &lt;div class=\"vue-modal\" v-if=\"isFirstOpen\"> &lt;transition name=\"drop-in\"> &lt;div class=\"vue-modal-inner\" v-if=\"isFirstOpen\"> &lt;div class=\"vue-modal-content\"> &lt;slot /> &#123;&#123; name &#125;&#125; &#123;&#123; isOpen &#125;&#125; &lt;button type=\"button\" @click=\"isFirstOpen = false\">close&lt;/button> &lt;/div> &lt;/div> &lt;/transition> &lt;/div> &lt;/transition> &lt;/template> &lt;script> import &#123; onMounted, onUnmounted &#125; from \"vue\"; import modalControl from \"@/stores/modalControl.js\"; import &#123; storeToRefs &#125; from \"pinia\"; export default &#123; setup() &#123; const modaltest = modalControl(); const &#123; name, isFirstOpen &#125; = storeToRefs(modaltest); return &#123; modaltest, name, isFirstOpen, &#125;; &#125;, &#125;; &lt;/script> SecondModal.vue &lt;template> &lt;transition name=\"fade\"> &lt;div class=\"vue-modal\" v-if=\"isSecondOpen\"> &lt;transition name=\"drop-in\"> &lt;div class=\"vue-modal-inner\" v-if=\"isSecondOpen\"> &lt;div class=\"vue-modal-content\"> &lt;slot /> &#123;&#123; name &#125;&#125; &#123;&#123; isOpen &#125;&#125; &lt;button type=\"button\" @click=\"isSecondOpen = false\">close&lt;/button> &lt;/div> &lt;/div> &lt;/transition> &lt;/div> &lt;/transition> &lt;/template> &lt;script> import modalControl from \"@/stores/modalControl.js\"; import &#123; storeToRefs &#125; from \"pinia\"; export default &#123; setup(props, &#123; emit &#125;) &#123; const modaltest = modalControl(); const &#123; name, isSecondOpen &#125; = storeToRefs(modaltest); return &#123; modaltest, name, isSecondOpen, &#125;; &#125;, &#125;; &lt;/script>","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://popeye-ux.github.io/categories/Vue3/"}],"tags":[{"name":"Vue, modal, pinia","slug":"Vue-modal-pinia","permalink":"https://popeye-ux.github.io/tags/Vue-modal-pinia/"}]},{"title":"在 Composition API 中使用 props 與 emit 操控 modal","slug":"modal-props-emit","date":"2023-01-26T17:14:43.000Z","updated":"2023-02-11T17:14:25.558Z","comments":true,"path":"2023/01/27/modal-props-emit/","link":"","permalink":"https://popeye-ux.github.io/2023/01/27/modal-props-emit/","excerpt":"","text":"在前端工程師的日常中，modal&#x2F; 彈出視窗 是常常會遇到的工作情境。畫面大概就是外部元件有一個按鈕，按下去會有一個對話框（內部元件）彈出來，對話框上有個按鈕，點擊後對話框就會關閉。 如果前端框架是 Vue 的話，一般我們會在外部元件定義一個布林值，預設為 false ，按下外部的按鈕後，布林值會變為 true。 開啟：在內部元件 modal 用 props 接收外部元件的布林值，綁上 v-if= props 接收到的布林值。這樣就可以由外部元件控制內部元件的開啟。 關閉：內元件 modal 可以由元件內部的按鈕關閉，按下按鈕後以 emit 傳送一個事件去觸發外部元件反轉布林值，達成元件的關閉。 App.vue(外部元件) &lt;template> &lt;button @click=\"isOpen = true\">showModal&lt;/button> &lt;!-- 外部元件中插入內部元件 modal --> &lt;!-- props 口訣：先內後外 :open=\"isOpen\"--> &lt;!-- emit 口訣：先內後外 @close=\"isOpen = !isOpen\"--> &lt;Modal :open=\"isOpen\" @close=\"isOpen = !isOpen\"> &lt;p> Lorem ipsum dolor, sit amet consectetur adipisicing elit. Quo molestiae consectetur blanditiis aspernatur velit autem labore amet &lt;/p> &lt;/Modal> &lt;/template> &lt;script> import &#123; ref &#125; from \"vue\"; import Modal from \"./components/ModalView.vue\"; // import HelloWorldVue from \"./components/HelloWorld.vue\"; export default &#123; components: &#123; Modal &#125;, setup() &#123; // 由 isOpen 的 true 或 false 控制 modal 的開關 const isOpen = ref(false); return &#123; isOpen, &#125;; &#125;, &#125;; &lt;/script> &lt;style> &lt;/style> &#x2F;components&#x2F;ModalView.vue(內部元件) &lt;template> &lt;transition name=\"fade\"> &lt;!-- 控制背景 --> &lt;div class=\"vue-modal\" v-if=\"open\"> &lt;transition name=\"drop-in\"> &lt;!-- 彈跳視窗本體 props 為 open，所以 v-if=\"open\" --> &lt;div class=\"vue-modal-inner\" v-if=\"open\"> &lt;div class=\"vue-modal-content\"> &lt;slot /> &lt;!-- @click=\"close\" 觸發 emit 事件，傳送至外層切換 isOpen --> &lt;button type=\"button\" @click=\"close\">close&lt;/button> &lt;/div> &lt;/div> &lt;/transition> &lt;/div> &lt;/transition> &lt;/template> &lt;script> import &#123; onMounted, onUnmounted &#125; from \"vue\"; export default &#123; props: &#123; open: &#123; type: Boolean, requires: true, &#125;, &#125;, // peops 這個參數一定要帶到，才能使用 &#123;emit&#125; setup(props, &#123; emit &#125;) &#123; const close = () => &#123; emit(\"close\"); &#125;; const handleKeyup = (event) => &#123; close(); &#125;; onMounted(() => document.addEventListener(\"keyup\", handleKeyup)); onUnmounted(() => document.removeEventListener(\"keyup\", handleKeyup)); return &#123; close &#125;; &#125;, &#125;; &lt;/script> &lt;style scoped> *, ::before, ::after &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .vue-modal &#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%; overflow-x: hidden; overflow-y: auto; background-color: rgba(0, 0, 0, 0.04); z-index: 1; &#125; .vue-modal-inner &#123; max-width: 500px; margin: 2rem auto; &#125; .vue-modal-content &#123; position: relative; background-color: #fff; border: 1px solid rgba(0, 0, 0, 0.3); background-clip: padding-box; border-radius: 0.3rem; padding: 1rem; &#125; .fade-enter-active, .fade-leave-active &#123; transition: opacity 0.5s; &#125; .fade-enter-from, .fade-leave-to &#123; opacity: 0; &#125; .drop-in-enter-active, .drop-in-leave-active &#123; transition: all 0.3s easeout; &#125; .drop-in-enter-from, .drop-in-leave-to &#123; opacity: 0; transform: translateY(-50px); &#125; &lt;/style>","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://popeye-ux.github.io/categories/Vue3/"}],"tags":[{"name":"Vue, modal, props, emit","slug":"Vue-modal-props-emit","permalink":"https://popeye-ux.github.io/tags/Vue-modal-props-emit/"}]},{"title":"hover 基本應用","slug":"hoverBasic","date":"2023-01-20T17:05:30.000Z","updated":"2023-02-11T17:14:29.778Z","comments":true,"path":"2023/01/21/hoverBasic/","link":"","permalink":"https://popeye-ux.github.io/2023/01/21/hoverBasic/","excerpt":"","text":"hover 是一種常見的網頁滑鼠互動，用法十分簡單，但是卻可以變化出各種形式。以下筆記幾種常見的用法： 基本用法HTML元素先設定基本的樣式，再用 選取器:hover&#123;...&#125; 設定滑鼠滑上元素後變化的樣式。 &lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt; .box &#123; width: 100px; height: 100px; margin: 100px auto; transition: 0.5s; background: #ffa7de; &#125; .box:hover &#123; background: #ffd592; &#125; See the Pen Untitled by POPEYE (@popeye_ux) on CodePen. 樣式的變換可以是： opacity:透明度的變化。 border-radius：如果要讓正方形的 div 變成圓的，只要設定:hover&#123;border-radius: 50%&#125; 即可做到。 transform: 可以讓 HTML 元素放大、縮小、旋轉，範例如下： .box &#123; width: 100px; height: 100px; margin: 100px auto; transition: 0.5s; background: #ffa7de; &#125; /* transform 設定 放大1.2倍,旋轉 45 度*/ .box:hover &#123; transform: scale(1.2) rotate(45deg); &#125; See the Pen hover:basic by POPEYE (@popeye_ux) on CodePen. hover 結合 keyframes 與 animation我們來做一個滑鼠移到方塊上，方塊就會搖擺的效果。 .box &#123; width: 100px; height: 100px; margin: 50px auto; transition: 0.5s; background: #ffa7de; &#125; /* 設定搖擺的過程*/ @keyframes swing &#123; 15% &#123;transform: translateX(5px);&#125; 40% &#123;transform: translateX(-5px);&#125; 65% &#123;transform: translateX(2px);&#125; 85% &#123;transform: translateX(-2px);&#125; 100% &#123;transform: translateX(0px);&#125; &#125; /* 把搖擺的過程用 animation 加到 hover 上*/ .box:hover &#123; animation: swing 1s 1; &#125; See the Pen hover:transform by POPEYE (@popeye_ux) on CodePen. hover 結合偽元素的應用一般我們常常看到 navbar 的選項在滑鼠移上去之後，下方會有一條線跑出來。這是利用 ::before 與 ::after 偽元素加上hover所做出來的效果。 div 方塊 position 要設定為 relative，而 before 與 after 偽元素 position 要設定為 absolute，width 要設定為 0，hover 之後設定為 100%，這樣就會有互動效果產生。 /* 加上 position: relative */ .box &#123; width: 100px; height: 100px; margin: 50px auto; transition: 0.5s; background: #ffa7de; position: relative; &#125; /* 設定偽元素的寬度為 0 ，position 為 absolute */ .box:before &#123; content: \"\"; width: 0%; height: 10px; background-color: #ff5e33; position: absolute; top: 0; left: 0; transition: all 0.3s linear; &#125; .box:after &#123; content: \"\"; width: 0%; height: 10px; background-color: #ff5e33; position: absolute; bottom: 0; left: 0; transition: all 0.3s linear; &#125; /* 設定偽元素在滑鼠移上去之後，寬度變為 100% */ .box:hover::after &#123; width: 100%; &#125; .box:hover::before &#123; width: 100%; &#125; /* 第二個方塊，滑鼠移上去之後，由下方的中間變出線條 */ .box2 &#123; width: 100px; height: 100px; margin: 50px auto; transition: 0.5s; background: #ffa7de; position: relative; &#125; .box2:after &#123; content: \"\"; width: 100%; height: 10px; background-color: #ff5e33; position: absolute; bottom: 0; left: 0; transition: transform 0.5s ease; transform: scaleX(0); &#125; .box2:hover::after &#123; transform: scaleX(1); &#125; See the Pen hover: animation by POPEYE (@popeye_ux) on CodePen.","categories":[{"name":"CSS","slug":"CSS","permalink":"https://popeye-ux.github.io/categories/CSS/"}],"tags":[{"name":"CSS, hover","slug":"CSS-hover","permalink":"https://popeye-ux.github.io/tags/CSS-hover/"}]},{"title":"target 進階：頁籤切換顯示內容","slug":"cssTargetTab1","date":"2023-01-19T17:29:39.000Z","updated":"2023-02-11T17:14:32.775Z","comments":true,"path":"2023/01/20/cssTargetTab1/","link":"","permalink":"https://popeye-ux.github.io/2023/01/20/cssTargetTab1/","excerpt":"","text":"target 是一個虛擬類別選擇器，用途在於讓我們設定目標對象的樣式。 CSS 的寫法為： 選擇器：target&#123; ..... &#125; 也就是當有人點了錨點為 hello 的 a 連結，則透過 #hello:target&#123;……..&#125; 就可以改變 id 為 hello 的 HTML 元素樣式。 在這個範例中必須懂的知識點： 選取 [ 擁有特定屬性 ]的選擇器 img[alt] &#123;……..&#125; 為改變有 alt 屬性的圖片樣式。 選取對象A ~ 選取對象B：意指選到 A 後面所有同一層的 B 選取對象A &gt; 選取對象B：意指僅選到 A 的下一層的 B 第一步：設定 HTML 結構，「頁籤按鈕」與「內容」連動 點選 &lt;li&gt;&lt;a href=&quot;#tab-1&quot;&gt;Tab 1&lt;/a&gt;&lt;/li&gt; 標籤來觸發 &lt;span id=&quot;tab-1&quot;&gt;1&lt;/span&gt; &lt;span id=&quot;tab-1&quot;&gt;1&lt;/span&gt; 利用 :target 反過來改變 &lt;li&gt;&lt;a href=&quot;#tab-1&quot;&gt;Tab 1&lt;/a&gt;&lt;/li&gt;與 &lt;div class=&quot;tab-content-1&quot;&gt;&lt;p&gt;內容-1&lt;/p&gt;&lt;/div&gt; 的樣式。 HTML 結構如下： &lt;span id=\"tab-1\">1&lt;/span> &lt;span id=\"tab-2\">2&lt;/span> &lt;span id=\"tab-3\">3&lt;/span> &lt;span id=\"tab-4\">4&lt;/span> &lt;div id=\"tab\"> &lt;!– 頁籤按鈕 –> &lt;ul> &lt;li>&lt;a href=\"#tab-1\">Tab 1&lt;/a>&lt;/li> &lt;li>&lt;a href=\"#tab-2\">Tab 2&lt;/a>&lt;/li> &lt;li>&lt;a href=\"#tab-3\">Tab 3&lt;/a>&lt;/li> &lt;li>&lt;a href=\"#tab-4\">Tab 4&lt;/a>&lt;/li> &lt;/ul> &lt;!– 頁籤的內容區塊 –> &lt;div class=\"tab-content-1\">&lt;p>內容-1&lt;/p>&lt;/div> &lt;div class=\"tab-content-2\">&lt;p>內容-2&lt;/p>&lt;/div> &lt;div class=\"tab-content-3\">&lt;p>內容-3&lt;/p>&lt;/div> &lt;div class=\"tab-content-4\">&lt;p>內容-4&lt;/p>&lt;/div> &lt;/div> CSS 結構如下： /* span:target */ #tab-1:target, #tab-2:target, #tab-3:target, #tab-4:target&#123; border: solid 1px red; &#125; /* /頁籤變換 選到 #tab-1 後面 #tab 後面 ul li a標籤屬性為 \"#tab-x\"的元素/ */ #tab-1:target ~ #tab > ul li a[href$=\"#tab-1\"], #tab-2:target ~ #tab > ul li a[href$=\"#tab-2\"], #tab-3:target ~ #tab > ul li a[href$=\"#tab-3\"], #tab-4:target ~ #tab > ul li a[href$=\"#tab-4\"] &#123; border: solid 1px blue; &#125; /* /頁籤內容顯示 / */ #tab-1:target ~ #tab > div.tab-content-1, #tab-2:target ~ #tab > div.tab-content-2, #tab-3:target ~ #tab > div.tab-content-3, #tab-4:target ~ #tab > div.tab-content-4 &#123; border: solid 1px black; &#125; /* 頁籤的樣式設定 */ #tab&#123; width: 300px; background: lightblue; border: solid 4px pink; &#125; /* 頁籤ul */ #tab>ul&#123; overflow: hidden; margin: 0; padding: 10px 20px 0 20px; &#125; #tab>ul>li&#123; list-style-type: none; &#125; /* 設定頁籤內的樣式 */ #tab>ul>li>a&#123; text-decoration: none; font-size: 13px; color: #333; float: left; padding: 10px; margin-left: 5px; &#125; See the Pen target 進階應用 by POPEYE (@popeye_ux) on CodePen. 第二步：設定隱藏與切換顯示 設定所有內容區塊為隱藏。 設定初始的時候 tab1 為啟動狀態，而 內容-1 為顯示狀態。 設定點選其他標籤時切換內容 /* span:target */ #tab-1:target, #tab-2:target, #tab-3:target, #tab-4:target&#123; border: solid 1px red; &#125; /* /頁籤變換 選到 #tab-1 後面 #tab 後面 ul li a標籤屬性為 \"#tab-x\"的元素/ */ #tab-1:target ~ #tab > ul li a[href$=\"#tab-1\"], #tab-2:target ~ #tab > ul li a[href$=\"#tab-2\"], #tab-3:target ~ #tab > ul li a[href$=\"#tab-3\"], #tab-4:target ~ #tab > ul li a[href$=\"#tab-4\"] &#123; border: solid 1px blue; &#125; /* /頁籤內容顯示 / */ #tab-1:target ~ #tab > div.tab-content-1, #tab-2:target ~ #tab > div.tab-content-2, #tab-3:target ~ #tab > div.tab-content-3, #tab-4:target ~ #tab > div.tab-content-4 &#123; border: solid 1px black; &#125; #tab&#123; width: 300px; background: lightblue; border: solid 4px pink; &#125; /* 頁籤ul */ #tab>ul&#123; overflow: hidden; margin: 0; padding: 10px 20px 0 20px; &#125; #tab>ul>li&#123; list-style-type: none; &#125; /* 設定頁籤內的樣式 */ #tab>ul>li>a&#123; text-decoration: none; font-size: 13px; color: #333; float: left; padding: 10px; margin-left: 5px; &#125; /* 第二步由此開始 */ /* /所有內容區塊隱藏起來/ */ #tab>div &#123; clear:both; padding:0 15px; height:0; overflow:hidden; visibility:hidden; -webkit-transition:all .4s ease-in-out; -moz-transition:all .4s ease-in-out; -ms-transition:all .4s ease-in-out; -o-transition:all .4s ease-in-out; transition:all .4s ease-in-out; &#125; /* /第一筆的底色，點擊tab1以外的標籤會變色/ */ span:target ~ #tab > ul li:first-child a &#123; background:red; &#125; /* :first-of-type 代表本節點為兄弟節點中第一個此類型節點。 點擊tab1以外其他標籤內容-1隱藏 */ span:target ~ #tab > div:first-of-type &#123; visibility:hidden; height:0px; background: purple; padding:0 15px; &#125; /* /頁籤:點擊變換&amp;第一筆還未點擊的初始化樣式/ */ /* 下面的是點擊才會變色 */ span ~ #tab > ul li:first-child a, #tab-1:target ~ #tab > ul li a[href$=\"#tab-1\"], #tab-2:target ~ #tab > ul li a[href$=\"#tab-2\"], #tab-3:target ~ #tab > ul li a[href$=\"#tab-3\"], #tab-4:target ~ #tab > ul li a[href$=\"#tab-4\"] &#123; background: #fff; &#125; /* /頁籤內容顯示&amp;設定第一筆為顯示/ */ span ~ #tab > div:first-of-type, #tab-1:target ~ #tab > div.tab-content-1, #tab-2:target ~ #tab > div.tab-content-2, #tab-3:target ~ #tab > div.tab-content-3, #tab-4:target ~ #tab > div.tab-content-4 &#123; visibility:visible; height:200px; background: #fff; &#125; See the Pen target 進階應用2 by POPEYE (@popeye_ux) on CodePen. 最後記得把 &lt;span&gt; 設為 display:none","categories":[{"name":"CSS","slug":"CSS","permalink":"https://popeye-ux.github.io/categories/CSS/"}],"tags":[{"name":"CSS, target","slug":"CSS-target","permalink":"https://popeye-ux.github.io/tags/CSS-target/"}]},{"title":"用 target 選擇器改變其他 HTML 元素的樣式","slug":"cssTarget-1","date":"2023-01-18T16:05:30.000Z","updated":"2023-01-19T17:09:26.505Z","comments":true,"path":"2023/01/19/cssTarget-1/","link":"","permalink":"https://popeye-ux.github.io/2023/01/19/cssTarget-1/","excerpt":"","text":"target 是一個虛擬類別選擇器，用途在於讓我們設定目標對象的樣式。 CSS 的寫法如下： .類別選擇器：target&#123; ..... &#125; target 基礎應用在這個範例中，我們藉由 &lt;a href=&quot;#top&quot;&gt; 來動態地操控 id 是 top 的 HTML 元素樣式。 &lt;a href&#x3D;&quot;#top&quot;&gt;上面變色&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;#&quot;&gt;不變色&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;#bottom&quot;&gt;下面變色&lt;&#x2F;a&gt; &lt;div class&#x3D;&quot;change&quot; id&#x3D;&quot;top&quot;&gt;上面變色&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;change&quot; id&#x3D;&quot;bottom&quot;&gt;下面變色&lt;&#x2F;div&gt; &lt;a href=&quot;#top&quot;&gt; 對應的 target 就是 id 為 top 的 HTML 元素。 .change:target&#123; background: orange; width:200px; &#125; 當我們點選其他連結的時候，連結對應 id 的元素也會改變樣式，同時其他元素的樣式會恢復原狀。 See the Pen :target by POPEYE (@popeye_ux) on CodePen. target 進階應用：燈箱效果利用 &lt;a href=&quot;#example1&quot;&gt; 來打開燈箱。 然後用 &lt;a href=&quot;#&quot; class=&quot;close&quot;&gt; 來關掉燈箱效果。 &lt;ul&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#example1&quot;&gt;打開燈箱 #1&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#example2&quot;&gt;打開燈箱 #2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;div class&#x3D;&quot;lightbox&quot; id&#x3D;&quot;example1&quot;&gt; &lt;figure&gt; &lt;!-- 關閉燈箱效果 --&gt; &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;close&quot;&gt;&lt;&#x2F;a&gt; &lt;figcaption&gt;我是燈箱一&lt;&#x2F;figcaption&gt; &lt;&#x2F;figure&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;lightbox&quot; id&#x3D;&quot;example2&quot;&gt; &lt;figure&gt; &lt;!-- 關閉燈箱效果 --&gt; &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;close&quot;&gt;&lt;&#x2F;a&gt; &lt;figcaption&gt;我是燈箱二&lt;&#x2F;figcaption&gt; &lt;&#x2F;figure&gt; &lt;&#x2F;div&gt; /* 先把燈箱設為 不顯示 */ .lightbox &#123; display: none; &#125; /* 利用 target 來打開燈箱 */ .lightbox:target &#123; position: absolute; left: 0; top: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; &#125; /* Lightbox content */ .lightbox figcaption &#123; width: 25rem; position: relative; padding: 1.5em; background-color: lightblue; &#125; /* Close button */ .lightbox .close &#123; position: relative; display: block; &#125; .lightbox .close::after &#123; right: -1rem; top: -1rem; width: 2rem; height: 2rem; position: absolute; display: flex; z-index: 1; align-items: center; justify-content: center; background-color: black; border-radius: 50%; color: white; content: \"×\"; cursor: pointer; &#125; /* Lightbox overlay */ .lightbox .close::before &#123; left: 0; top: 0; width: 100%; height: 100%; position: fixed; background-color: rgba(0,0,0,.7); content: \"\"; cursor: default; &#125; See the Pen Pure-CSS lightbox by POPEYE (@popeye_ux) on CodePen.","categories":[{"name":"CSS","slug":"CSS","permalink":"https://popeye-ux.github.io/categories/CSS/"}],"tags":[{"name":"CSS, target","slug":"CSS-target","permalink":"https://popeye-ux.github.io/tags/CSS-target/"}]},{"title":"computed 的簡單任務--只讀不寫","slug":"vue-computed-1","date":"2023-01-14T10:59:55.000Z","updated":"2023-02-17T16:34:42.511Z","comments":true,"path":"2023/01/14/vue-computed-1/","link":"","permalink":"https://popeye-ux.github.io/2023/01/14/vue-computed-1/","excerpt":"","text":"甚麼是 Computed在 Vue 中有一個叫 computed 的神奇方法，它可以觀察在data的變數，一旦變數有了改變，就會去取變數來運算，產生一個新的值呈現在畫面上，而這個新的值不會寫回 Option API 的 data 中。 先來個簡單的計算，看看它神奇的地方：Computed 去觀察 num 跟 price 這兩個資料，一但數值有變化，就算一個新的數值到畫面上。HTML 這樣寫： &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h3&gt;計算機&lt;&#x2F;h3&gt; &lt;div&gt; 數量: &#123;&#123;num&#125;&#125; &lt;br&gt; &lt;input type&#x3D;&quot;text&quot; v-model.num&#x3D;&quot;num&quot;&gt; &lt;&#x2F;div&gt; &lt;div&gt; 價格: &#123;&#123;price&#125;&#125; &lt;br&gt; &lt;input type&#x3D;&quot;text&quot; v-model.num&#x3D;&quot;price&quot;&gt; &lt;&#x2F;div&gt; &lt;!-- &#123;&#123;&#125;&#125; 需要與 computed 內的函式同名 --&gt; 總價(表達式 num * price ) : &#123;&#123; total &#125;&#125; &lt;br&gt; &lt;&#x2F;div&gt; JavaScript 這樣寫： const app = &#123; data() &#123; return &#123; message:'', num:0, price:100 &#125; &#125;, computed:&#123; //函式需與在 HTML 中的觀察對象 &#123;&#123;&#125;&#125; 相同名稱 total()&#123; //可以同時觀察多個對象，在這裡同時觀察 num 與 price return this.num * this.price &#125; &#125; &#125; Vue.createApp(app).mount('#app') See the Pen vue by POPEYE (@popeye_ux) on CodePen. Computed 的特性： 在大部分情境中(Getter)，只讀不寫，一旦在 data 中，Computed 所觀察的對象有變化，就會進行運算，然後產生一個值渲染到畫面上，而這個新的值並不會寫回 data。 可以同時監聽多個變數，只要其中一個改變，就會重新運算。 沒有被 Computed 監聽的變數不會觸發 computed。 computed 是一個物件。 Computed 和 利用兩對大括號渲染運算結果 的比較當然也可以在 HTML 中加入 &#123;&#123; 對應的資料名稱 &#125;&#125; ，就可以讓畫面與資料連動，只是如果相同的資料要運用在多個地方就要反覆去寫相同的&#123;&#123;運算式&#125;&#125;。 HTML 這樣寫： &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h3&gt;計算機&lt;&#x2F;h3&gt; &lt;div&gt; 數量: &#123;&#123;num&#125;&#125; &lt;br&gt; &lt;input type&#x3D;&quot;text&quot; v-model.num&#x3D;&quot;num1&quot;&gt; &lt;&#x2F;div&gt; &lt;div&gt; 價格: &#123;&#123;price&#125;&#125; &lt;br&gt; &lt;input type&#x3D;&quot;text&quot; v-model.num&#x3D;&quot;price&quot;&gt; &lt;&#x2F;div&gt; &lt;!-- &#123;&#123;&#125;&#125; 中可以放入表達式 --&gt; 總價(表達式 num1 * price ) &#123;&#123; num * price &#125;&#125; &lt;br&gt; &lt;&#x2F;div&gt; JavaScript 這樣寫： const app = &#123; data() &#123; return &#123; num:0, price:0 &#125; &#125; &#125; Vue.createApp(app).mount('#app') See the Pen Vue methods 與 computed by POPEYE (@popeye_ux) on CodePen. 在 methods 中使用函式運算如果要重複運算相同的資料，methods 也可以做到，我們可以在 methods 中使用函式，將運算的過程封裝進去。 在 HTML 中只要寫 &#123;&#123; 函式名稱() &#125;&#125; 就可以了，methods 中的函式會去修改資料與同時將運算結果呈現在 HTML 中的 &#123;&#123; 函式名稱() &#125;&#125; 的位置。 在這裡承前題，但是加入一個折扣的&lt;input&gt;輸入框，也在資料中新增一個 discount 的屬性，計算處理上也加上「乘以折扣」的程序。 &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h3&gt;計算機&lt;&#x2F;h3&gt; &lt;div&gt; 數量: &#123;&#123;num&#125;&#125; &lt;br&gt; &lt;input type&#x3D;&quot;text&quot; v-model.num&#x3D;&quot;num&quot;&gt; &lt;&#x2F;div&gt; &lt;div&gt; 價格: &#123;&#123;price&#125;&#125; &lt;br&gt; &lt;input type&#x3D;&quot;text&quot; v-model.num&#x3D;&quot;price&quot;&gt; &lt;&#x2F;div&gt; &lt;div&gt; 折扣: &#123;&#123;discount&#125;&#125; %&lt;br&gt; &lt;input type&#x3D;&quot;text&quot; v-model.num&#x3D;&quot;discount&quot;&gt; &lt;&#x2F;div&gt; &lt;!-- &#123;&#123;&#125;&#125; 中可以放入表達式 --&gt; 總價(表達式 num1 * price ) &#123;&#123; num * price * discount&#x2F;100 &#125;&#125; &lt;br&gt; 總價( methods ) &#123;&#123;totalMethod()&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; const app = &#123; data() &#123; return &#123; discount:100, num:0, price:0 &#125; &#125;, methods:&#123; totalMethod()&#123; console.log('methods') return this.num * this.price*this.discount/100; &#125; &#125; &#125; Vue.createApp(app).mount('#app') See the Pen Vue methods 與 computed by POPEYE (@popeye_ux) on CodePen. Methods 是急驚風，Computed 是慢郎中承上題，我們加入一個不相干的 message 屬性，與畫面上 message 輸入框連動： &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h3&gt;計算機&lt;&#x2F;h3&gt; message: &lt;br&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;message&quot;&gt; &lt;div&gt; 數量: &#123;&#123;num&#125;&#125; &lt;br&gt; &lt;input type&#x3D;&quot;text&quot; v-model.num&#x3D;&quot;num&quot;&gt; &lt;&#x2F;div&gt; &lt;div&gt; 價格: &#123;&#123;price&#125;&#125; &lt;br&gt; &lt;input type&#x3D;&quot;text&quot; v-model.num&#x3D;&quot;price&quot;&gt; &lt;&#x2F;div&gt; &lt;!-- &#123;&#123;&#125;&#125; 中可以放入表達式 --&gt; 總價(表達式 num1 * price ) &#123;&#123; num * price &#125;&#125; &lt;br&gt; &lt;!-- methods 中的函式 --&gt; 總價( methods ) &#123;&#123;totalMethod()&#125;&#125; 總價( computed ) &#123;&#123;totalComputed&#125;&#125; &lt;&#x2F;div&gt; const app = &#123; data() &#123; return &#123; message:'', num:0, price:0 &#125; &#125;, methods:&#123; totalMethod()&#123; console.log('methods') return this.num * this.price; &#125; &#125;, computed:&#123; totalComputed()&#123; console.log('computed') return this.num * this.price; &#125; &#125; &#125; Vue.createApp(app).mount('#app') 當我們改變 this.num 與 this.price 會同時觸發 console.log(&#39;methods&#39;) 與 console.log(&#39;computed&#39;)，但是我們會發現在 message 輸入框中更新 data 的時候，console.log(&#39;methods&#39;) 也會被觸發，但是 console.log(&#39;computed&#39;) 卻沒有反應，這是因為 this.message 不是 totalComputed() 的觀察對象。 而 methods 只要 data 中的資料有任何風吹草動，他都會觸發。 我們可以說 Methods 是急驚風，而 Computed 則是天塌下來，只要我家沒事，都不理會。 computed 與 methods 的差別： computed 只有在自己觀察的值有變動時才會觸發，而 methods 則是所有的資料有變動時都會觸發。 computed 運作的結果只會呈現在畫面中，不會寫回資料(data)，除非有加上 setter()，才會改變資料的內容。","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://popeye-ux.github.io/categories/Vue3/"}],"tags":[{"name":"Vue, Computeds","slug":"Vue-Computeds","permalink":"https://popeye-ux.github.io/tags/Vue-Computeds/"}]},{"title":"v-model 與 v-for 起使用的注意事項","slug":"v-modelAndV-for","date":"2023-01-07T13:43:05.000Z","updated":"2023-02-11T17:14:44.534Z","comments":true,"path":"2023/01/07/v-modelAndV-for/","link":"","permalink":"https://popeye-ux.github.io/2023/01/07/v-modelAndV-for/","excerpt":"","text":"Vue 指令與表單應用Vue3 的指令可以節省許多原生 JS 要寫的 DOM 元素綁定與事件監聽的語法，Vue 指令方便歸方便，但是如果有些地方沒有注意，表單就有渲染不出來的困擾，以下整理一下初入手 Vue 指令與表單應用要注意的事情。 checkbox 的雙向綁定與渲染在使用 Vue 來做表單渲染與表單選項的雙向綁定時，要注意 v-model 的雙向綁定 與 v-for 的表單選項渲染 是兩件不同的工作，以 checkbox為例，在資料上面要有 2 個陣列分別對應 v-for 與 v-model： 要準備一個放入所有選項的陣列，讓 v-for 渲染在表單上，讓每個 checkbox 的 value 都可以 v-bind 到陣列的值。 因為 checkbox 可以複選，所以 v-model 要綁定到一個空陣列，把勾選的項目放入陣列中雙向綁定，讓資料與畫面連動。 v-for 要用 v-bind 綁定 key 值，不然會出現 選項 與 勾選 不連動的靈異事件。 const app = &#123; data() &#123; return &#123; heroInfo: &#123; // v-model 要綁以下空陣列 loveHero: [] &#125;, // v-for 要綁以下陣列 heros: [\"鋼鐵人\", \"美國隊長\", \"雷神索爾\", \"綠巨人浩克\"] &#125;; &#125; &#125;; Vue.createApp(app).mount(\"#app\"); 同時使用 v-for 與 v-model 的時候，要注意兩者下的位置，以 checkbox 為例： v-for 要下在外層，不能下在 &lt;input&gt; 標籤裡面，放在 &lt;input&gt; 會沒有作用。 v-model 則要放在 &lt;input&gt;s 上面，value 要用 v-bind 去綁 v-for 的 item。 &lt;div id&#x3D;&quot;app&quot;&gt; &lt;form class&#x3D;&quot;container p-2&quot;&gt; &lt;h3&gt;超級英雄調查&lt;&#x2F;h3&gt; &lt;!-- v-for 要綁在外層的 div --&gt; &lt;div class&#x3D;&quot;form-check&quot; v-for&#x3D;&quot;(item,index) in heros&quot;&gt; &lt;!-- v-model 則要綁在 input 上， input 的 value 則要用 v-bind 綁在 v-for 的 item上面 --&gt; &lt;input class&#x3D;&quot;form-check-input&quot; type&#x3D;&quot;checkbox&quot; :value&#x3D;&quot;item&quot; :id&#x3D;&quot;item&quot; :key&#x3D;&quot;index + item&quot; v-model&#x3D;&quot;heroInfo.loveHero&quot;&gt; &lt;label class&#x3D;&quot;form-check-label&quot; :for&#x3D;&quot;item&quot;&gt; &#123;&#123; item &#125;&#125; &lt;&#x2F;label&gt; &lt;&#x2F;div&gt; &lt;hr&gt; &lt;ul&gt; &lt;li&gt;英雄愛好: &#123;&#123; heroInfo.loveHero &#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; See the Pen v-for 與 v-model 放的位置 by POPEYE (@popeye_ux) on CodePen. select 下拉選單的 v-for 渲染與 v-model 綁定select 下拉選單 v-model 雙向綁定 與 v-for 選項渲染要注意的事項： v-model 要放在 select 標籤上，綁定 data 中的空字串。 v-for 則要放在 option 標籤上， value 要 v-bind 到 v-for 的 item 上面。item 的名稱可以自訂。v-for 一樣要對應到 所有選項的空陣列。 const app = &#123; data() &#123; return &#123; herolInfo: &#123; favoriteHero: '', &#125;, heros: ['鋼鐵人', '美國隊長','綠巨人浩克','雷神索爾'], &#125; &#125; &#125; Vue.createApp(app).mount('#app') &lt;div id=\"app\"> &lt;form class=\"container p-2\"> &lt;div class=\"mb-3\"> &lt;label for=\"favoritePet\" class=\"mb-2\">選擇英雄&lt;/label> &lt;br> &lt;select name=\"favoriteHero\" id=\"favoriteHero\" v-model=\"herolInfo.favoriteHero\"> &lt;option value=\"\" disabled=\"disabled\">請選擇英雄&lt;/option> &lt;option :value=\"item\" v-for=\"(item,index) in heros\" :key=\"index + item\">我是&#123;&#123; item &#125;&#125;&lt;/option> &lt;/select> &lt;/div> &lt;hr> &lt;ul> &lt;li>選擇英雄: &#123;&#123; herolInfo.favoriteHero &#125;&#125;&lt;/li> &lt;/ul> &lt;/form> &lt;/div>s","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://popeye-ux.github.io/categories/Vue3/"}],"tags":[{"name":"Vue, Vue3, JavaScript","slug":"Vue-Vue3-JavaScript","permalink":"https://popeye-ux.github.io/tags/Vue-Vue3-JavaScript/"}]},{"title":"VS Code 樣板字面值 HTML 補全","slug":"vscodeJSHtmlComplete","date":"2022-10-21T23:57:40.000Z","updated":"2022-10-22T00:01:57.414Z","comments":true,"path":"2022/10/22/vscodeJSHtmlComplete/","link":"","permalink":"https://popeye-ux.github.io/2022/10/22/vscodeJSHtmlComplete/","excerpt":"","text":"一般在寫 HTML 時可以使用 emmet 來幫忙補全 HTML 標籤，但是在 JavaScript 中使用樣版字面值來寫 HTML 就沒有 emmet 可以用，每次寫 HTML 標籤都要自己手打，既不方便也容易出錯。 後來發現在 settings.json 檔中加入幾行 emmet 設定，就可以在寫 JS 樣版字面值時取得 HTML 標籤補全的功能。 請按左下角的齒輪，選擇「設定」： 然後選擇右上角的小圖，進入 settings.json 在結尾補上這一段 emmet 設定： // 樣版字面值 HTML 補全開始 \"emmet.triggerExpansionOnTab\": true, \"emmet.showAbbreviationSuggestions\": true, \"emmet.showExpandedAbbreviation\": \"always\", \"emmet.includeLanguages\": &#123; \"javascript\": \"html\" &#125; // 樣版字面值 HTML 補全結束","categories":[{"name":"VS Code","slug":"VS-Code","permalink":"https://popeye-ux.github.io/categories/VS-Code/"}],"tags":[{"name":"VS Code,樣板自面值,HTML補全","slug":"VS-Code-樣板自面值-HTML補全","permalink":"https://popeye-ux.github.io/tags/VS-Code-%E6%A8%A3%E6%9D%BF%E8%87%AA%E9%9D%A2%E5%80%BC-HTML%E8%A3%9C%E5%85%A8/"}]},{"title":"箭頭函式的this","slug":"thisInArrowFunction","date":"2022-10-18T16:01:11.000Z","updated":"2022-10-18T16:07:25.931Z","comments":true,"path":"2022/10/19/thisInArrowFunction/","link":"","permalink":"https://popeye-ux.github.io/2022/10/19/thisInArrowFunction/","excerpt":"","text":"箭頭函式的this在 JavaScript 中遇到 this ，有 2 件事情要注意： this 代表的是 function 執行時所屬的物件，而不是 function 本身。 沒有特別指定 this 的情況下，this 預設綁定( Default Binding )「全域物件」，也就是 window。 物件調用與 Simple Call先來看看 simple call 跟物件調用的狀況： var universe = '漫威宇宙'; // 用 var 才會是全域變數 function callHero() &#123; console.log(this.universe); &#125; const ironMan = &#123; universe : '鋼鐵人宇宙', callHero &#125; ironMan.callHero(); // this 指向調用 callHero() 的 ironMan var spiderMan = &#123; universe : '蜘蛛人宇宙', callHero, stranger()&#123; callHero(); // simple call &#125; &#125; spiderMan.callHero(); // 蜘蛛人宇宙，調用 callHero() 的是 spiderMan 這個物件 // 所以 this 指向 spiderMan spiderMan.stranger(); // 漫威宇宙，因為調用 callHero() 的是 stranger()這個函式 // 所以 this 指向全域，也就是 window See the Pen Untitled by POPEYE (@popeye_ux) on CodePen. 箭頭函式的 this當 this 出現在箭頭函式中，因為箭頭函式沒有自己的 this ，所以會指向外層。 一樣設一個全域變數與一個 callHero()函式。 var universe = '漫威宇宙'; // 用 var 才會指向全域 function callHero() &#123; console.log(this.universe); &#125; var spiderMan = &#123; universe : '蜘蛛人宇宙', callHero, stranger:() => &#123; console.log(this.universe) &#125; // 箭頭函式沒有自己的 this ，所以指向外層，也就是全域 &#125; spiderMan.callHero(); //蜘蛛人宇宙 spiderMan.stranger(); //漫威宇宙 See the Pen this arrow function by POPEYE (@popeye_ux) on CodePen. callBack function 中的 thisvar universe = '漫威宇宙'; // 用 var 才會指向全域 function callHero() &#123; console.log(this.universe); &#125; const spiderMan = &#123; universe : '蛛蛛人宇宙', callHero: function()&#123; console.log('1',this.universe); // 1 蜘蛛人宇宙 setTimeout(function ()&#123; console.log('2',this.universe); // 2 漫威宇宙 console.log('3',this); // 3 window &#125;) &#125; &#125; spiderMan.callHero(); See the Pen callBack this 1 by POPEYE (@popeye_ux) on CodePen. 但是 callBack function 被包在一個物件屬性的函式 callHero 中，當 spiderMan.callHero()，也就是spiderMan 調用 callHero()的時候，setTimeout 是被 callHero 這個函式所調用，這時 this 指向全域的 window。 同樣的例子，在 setTimeout() 中改用箭頭函式，則 this 會指向外層，也就是調用他的物件– spiderMan 這個物件。 var universe = '漫威宇宙'; // 用 var 才會指向全域 function callHero() &#123; console.log(this.universe); &#125; const spiderMan = &#123; universe : '蛛蛛人宇宙', callHero: function()&#123; console.log('1',this.universe); // 1 蜘蛛人宇宙 setTimeout(() => &#123; console.log('2',this.universe); // 2 蛛蛛人宇宙 console.log('3',this); // 3 &#123;universe: '蛛蛛人宇宙', callHero: ƒ&#125; &#125;) &#125; &#125; spiderMan.callHero(); See the Pen callBack this 1 by POPEYE (@popeye_ux) on CodePen.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript,this,箭頭函式","slug":"JavaScript-this-箭頭函式","permalink":"https://popeye-ux.github.io/tags/JavaScript-this-%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F/"}]},{"title":"getAttributeSetAttribute","slug":"getAttributeSetAttribute","date":"2022-07-06T15:27:46.000Z","updated":"2022-07-06T00:34:30.000Z","comments":true,"path":"2022/07/06/getAttributeSetAttribute/","link":"","permalink":"https://popeye-ux.github.io/2022/07/06/getAttributeSetAttribute/","excerpt":"","text":"Hi,我是POPEYE，今天要來談談 getAttribute 與 setAttribute 。 getAttribute 與 setAttribute 是兩個我比較容易混淆的 JS 方法，所以我花了一點工夫來研究一下這兩個方法如何使用。 首先要了解這兩種方法是存取與操作 HTML 標籤屬性的方法，都必須要透過選取到某個 HTML DOM 節點來操作，所以寫法上一定是這樣子： element.getAttribute('屬性名稱'); element.setAttribute('屬性名稱','屬性值'); //屬性名稱為 id 、 class 、 href、 data-** ……等等 getAttributegetAttribute 用來取得 HTML 標籤的屬性值，如果指定的屬性不存在，則會回傳 null 或 “”。 &lt;h2 class&#x3D;&quot;title&quot; id&#x3D;&quot;quiet&quot; data-band&#x3D;&quot;Mayday&quot; name&#x3D;&quot;好好&quot;&gt; 最安靜的時刻，回憶總是最喧囂 &lt;&#x2F;h2&gt; //JavaScript const quiet = document.querySelector('.title'); console.log(quiet.getAttribute('class')); // \"title\" console.log(quiet.getAttribute('id')); //\"quiet\" console.log(quiet.getAttribute('data-band')); //\"Mayday\" console.log(quiet.getAttribute('name')); //\"好好\" 所以我們可以把 HTML 節點的屬性值取出，拿來組字串之後，再塞回本來的節點去。 &lt;h2 class&#x3D;&quot;title&quot; id&#x3D;&quot;quiet&quot; data-band&#x3D;&quot;Mayday&quot; name&#x3D;&quot;好好&quot;&gt; 最安靜的時刻，回憶總是最喧囂 &lt;&#x2F;h2&gt; //JavaScript const quiet = document.querySelector('.title'); let str =`我最喜歡的歌詞是《$&#123;quiet.getAttribute('data-band')&#125;》唱的 《$&#123;quiet.getAttribute('data-song')&#125;》， 裡面這一句「$&#123;quiet.textContent&#125;」`; quiet.textContent = str; console.log(quiet.textContent); //\"我最喜歡的歌詞是《Mayday》唱的《null》，裡面這一句「最安靜的時刻，回憶總是最喧囂」\" 本來 &lt;h2&gt; 標籤中 「最安靜的時刻，回憶總是最喧囂」 ，被改成 「我最喜歡的歌詞是《Mayday》唱的《null》，裡面這一句「最安靜的時刻，回憶總是最喧囂」」囉！！！ setAttributesetAttribute 的功用在於修改 HTML 節的的屬性。 element.setAttribute('屬性名稱','屬性值'); //屬性名稱為 id 、 class 、 href、 data-** ……等等 不囉嗦！來看一下範例： &lt;h2 class&#x3D;&quot;title2&quot; data-song&#x3D;&quot;好好&quot; data-band&#x3D;&quot;Mayday&quot;&gt; 最喧囂的時刻，寂寞包圍著孤島 &lt;&#x2F;h2&gt; .blue &#123; color: blue; &#125; //JavaScript const noise = document.querySelector('.title2'); noise.setAttribute(\"data-song\",\"瘋狂世界\"); noise.setAttribute('class','blue'); //字的顏色也變成藍色了 console.log(noise.getAttribute('data-song')); //瘋狂世界\" console.log(noise.getAttribute('class')); //\"blue\" CODEPEN範例 getAttribute 與 setAttribute 的進階使用除了用來操作屬性之外，在做事件監聽的時候，也可以利用 getAttribute 來做一些判斷： &lt;ul class&#x3D;&quot;item&quot;&gt; &lt;li class &#x3D;&quot;item1&quot;&gt;item1&lt;&#x2F;li&gt; &lt;li class &#x3D;&quot;item2&quot;&gt;item2&lt;&#x2F;li&gt; &lt;li class &#x3D;&quot;item3&quot;&gt;item3&lt;&#x2F;li&gt; &lt;li class &#x3D;&quot;item4&quot;&gt;item4&lt;&#x2F;li&gt; &lt;li class &#x3D;&quot;item5&quot;&gt;item5&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; .item&#123; font-size: 20px; &#125; .item1, .item2, .item3, .item4, .item5&#123; margin-bottom: 20px; &#125; .blue&#123; color : blue; margin-bottom: 50px; &#125; const item = document.querySelector('.item'); item.addEventListener('click',function(e)&#123; if(e.target.getAttribute('class') === 'item3')&#123; e.target.setAttribute('class','blue') &#125; &#125;) 在這裡利用 e.target.getAttribute(&#39;class&#39;) 來判斷如果點擊到的 class 屬性如果是 item3 ， 則把 e.target 的 class 屬性變成藍色的。 MDN 有把 getAttribute 與 setAttribute 這兩個節點方法可以操作的 HTML 屬性列出來，有需要時可以參考一下： MDN HTML attribute reference","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, JS直播班","slug":"JavaScript-JS直播班","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD/"}]},{"title":"C3.js基本使用方法","slug":"c3js","date":"2021-11-29T15:38:31.000Z","updated":"2022-05-23T00:47:22.000Z","comments":true,"path":"2021/11/29/c3js/","link":"","permalink":"https://popeye-ux.github.io/2021/11/29/c3js/","excerpt":"","text":"這一周六角學院 JS 直播班教的是 C3.js 這個畫圖表的套件。 對於一個畫圖表快二十年的人，看到這個套件感到很親切。不同於手工畫的圖表，C3.js可以透過程式把資料帶入，只要資料更新，圖表也同步更新。 其實我也使用過另外一套圖表套件 Chart.js，那是在前公司結束前，做了一個 COVID-19 的網頁，裡面圖表就是用 Chart.js 做的，那時還不會串 API ，也不會篩選資料，每天都用手動把資料更新，真的很傻B！ 誠如老師講的，不用真的把文件整個看過才會用，基本上只要抓住一些設定的要點，就可以做出還不錯的圖表。以下就整理了一些我試過可行的設定，方便未來要用時，可以快速上手： 導入方法在HTML中插入以下程式碼： CSS要放在自己寫的CSS之前。 透過CDN抓進來使用的 d3.js 與 c3.js 也要放在自己寫的 JS檔之前。 &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;c3&#x2F;0.7.18&#x2F;c3.css&quot;&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;d3&#x2F;5.16.0&#x2F;d3.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;c3&#x2F;0.7.18&#x2F;c3.js&quot;&gt;&lt;&#x2F;script&gt; 曲線圖 Line Chart基本上套件就是一個物件，而所有的圖表的資料與外觀都在 generate 這個屬性的函式參數裡面設定。而 generate 函式的參數也是一個物件。 可以透過 bindto 這個屬性把圖表綁定到 HTML 的 DOM 元素上。 var chart = c3.generate(&#123; bindto: \".chart\", data: &#123; // x 是設定 x 軸刻度的格式與數據 x: \"date\", columns: [ //\"date\" 綁定到 x 屬性的值\"date\" ，日期是字串格式 [\"date\", \"2021-11-21\", \"2021-11-22\", \"2021-11-23\", \"2021-11-24\"], //資料部分，可以透過 變數 帶入 [\"data1\", 30, 200, 100, 400], [\"data2\", 50, 20, 10, 40] ], // 顯示線圖上面每一點的資料 // labels: true // 每一點的資料顯示 $ labels: &#123; format: &#123; data1: d3.format(\"$\") &#125; &#125; &#125;, //設定一組色票讓data自己捉 線 的顏色 color: &#123; pattern: [\"#ff9896\", \"#9467bd\", \"#c5b0d5\", \"#8c564b\", \"#c49c94\", \"#e377c2\"] &#125;, // 設定顯示格線(虛線) grid: &#123; x: &#123; show: true &#125;, y: &#123; show: true &#125; &#125;, //整體尺寸 不設定的話，圖表可以自適應地伸縮 size: &#123; width: 780, height: 400 &#125;, //padding 會壓縮線圖的大小 padding: &#123; top: 0, //right設太小，會讓最右側刻度的日期被遮住 right: 100, bottom: 10, left: 100 &#125;, //設定坐標軸格式 axis: &#123; x: &#123; type: \"timeseries\", //刻度 tick: &#123; count: 4, format: \"%Y-%m-%d\", // outer 拿掉圖表最右側多出來的刻度 outer: false &#125;, // 設定x軸說明 或是 數據 的單位 label: &#123; text: \"日期\", //label 橫式的位置有以下幾種 //inner-right [default],inner-center,inner-left,outer-right,outer-center,outer-left position: \"outer-center\" &#125; &#125;, y: &#123; show: true, tick: &#123; //label 的位置有以下幾種 //inner-right [default],inner-center,inner-left,outer-right,outer-center,outer-left position: \"inner-center\", // Y軸 數字前面加上 $ 字號 format: d3.format(\"$,\") //format: function (d) &#123; return \"$\" + d; &#125; &#125;, label: &#123; text: \"價格\", // inner-right : default, inner-center, inner-left, outer-right, outer-center, outer-left position: \"outer-middle\" &#125; &#125; &#125;, //設定圖例 legend: &#123; show: true, //圖例的位置只有 'right' 與 'bottom' position: \"bottom\" &#125;, //圖表的標題 title: &#123; text: \"好心指數\" &#125; &#125;); CSS設定的部分： // CSS .c3-title &#123; font-size: 32px; &#125; .c3-axis-y text &#123; fill: red; font-size: 12px; &#125; .c3-axis-x text &#123; font-size: 12px; fill: green; &#125; .c3-axis-y text &#123; font-size: 10px; fill: green; letter-spacing: 2px; &#125; .c3-axis-y .c3-axis-y-label &#123; font-size: 20px; fill: red; &#125; .c3-line &#123; stroke-width: 3px; &#125; .c3-circle &#123; fill: blue !important; &#125; Line Chart 範例 Bar Chart 長條圖Bar Chart 的設定大同小異，差別在於 axis 可以設定 rotated: false , 坐標軸翻轉，由垂直轉為水平。 var chart = c3.generate(&#123; bindto: \".chart\", //是bind，不是bid data: &#123; x: \"x\", columns: [ [ \"x\", \"2013-01-01\", \"2013-01-02\", \"2013-01-03\", \"2013-01-04\", \"2013-01-05\" ], [\"data1\", 30, 200, 100, 400, 150], [\"data2\", 130, 100, 140, 200, 150] ], //type 設定圖表類型 type: \"bar\" &#125;, bar: &#123; //設定長條圖每一條寬度 width: &#123; ratio: 0.5 // this makes bar width 50% of length between ticks &#125; // or //width: 100 // this makes bar width 100px &#125;, //設定一組色票讓data自己捉 color: &#123; pattern: [\"#ff9896\", \"#9467bd\", \"#c5b0d5\", \"#8c564b\", \"#c49c94\", \"#e377c2\"] &#125;, // 設定顯示格線(虛線) grid: &#123; x: &#123; show: true &#125;, y: &#123; show: true &#125; &#125;, //整體尺寸 不設定的話，圖表可以自適應地伸縮 size: &#123; width: 780, height: 400 &#125;, padding: &#123; top: 0, right: 200, bottom: 10, left: 100 &#125;, axis: &#123; //rotated 設定坐標軸翻轉 rotated: false, x: &#123; type: \"category\", // 設定x軸說明 或是 數據 的單位 label: &#123; text: \"日期\", //label 橫式的位置有以下幾種 //inner-right [default],inner-center,inner-left,outer-right,outer-center,outer-left position: \"outer-center\" &#125; &#125;, y: &#123; tick: &#123; position: \"inner-center\", // Y軸 數字前面加上 $ 字號 format: d3.format(\"$,\") //format: function (d) &#123; return \"$\" + d; &#125; &#125;, label: &#123; text: \"價格\", // inner-right : default, inner-center, inner-left, outer-right, outer-center, outer-left position: \"outer-middle\" &#125; &#125; &#125;, legend: &#123; show: true, //圖例的位置 'bottom' position: \"bottom\" &#125;, //圖表的標題 title: &#123; text: \"銷售金額\" &#125; &#125;); Bar Chart 範例 Pie Chart 餅圖var chart = c3.generate(&#123; bindto: \".chart\", data: &#123; // iris data from R columns: [ [\"iPhone\", 30], [\"其他手機\", 120] ], type: \"pie\", labels: true &#125;, //設定一組色票讓data自己捉 線 的顏色 color: &#123; pattern: [\"#ff9896\", \"#9467bd\", \"#c5b0d5\", \"#8c564b\", \"#c49c94\", \"#e377c2\"] &#125;, //整體尺寸，本來置中，會往畫面左邊靠 size: &#123; width: 780, height: 400 &#125;, //padding 會壓縮線圖的大小 padding: &#123; top: 0, right: 100, bottom: 10, left: 100 &#125;, //設定圖例 legend: &#123; show: true, //圖例的位置只有 'right' 與 'bottom' position: \"bottom\" &#125;, //pie 及 donut 圖 label 設定的方式和其他圖不一樣，要注意 pie: &#123; label: &#123; show: true, format: function (value, ratio, id) &#123; return d3.format(\"$\")(value); &#125; &#125; &#125;, //圖表的標題 title: &#123; text: \"銷售金額比例\" &#125; &#125;); Pie Chart 範例 Donut Chart 甜甜圈圖var chart = c3.generate(&#123; bindto: \".chart\", data: &#123; // iris data from R columns: [ [\"iPhone\", 30], [\"其他手機\", 120] ], type: \"donut\", labels: true &#125;, //設定一組色票讓data自己捉 線 的顏色 color: &#123; pattern: [\"#ff9896\", \"#9467bd\", \"#c5b0d5\", \"#8c564b\", \"#c49c94\", \"#e377c2\"] &#125;, //整體尺寸，本來置中，會往畫面左邊靠 size: &#123; width: 780, height: 400 &#125;, //padding 會壓縮線圖的大小 padding: &#123; top: 0, //right設太小，會讓最右側刻度的日期被遮住 right: 100, bottom: 10, left: 100 &#125;, //設定圖例 legend: &#123; show: true, //圖例的位置只有 'right' 與 'bottom' position: \"bottom\" &#125;, //pie 及 donut 圖 label 設定的方式和其他圖不一樣，要注意 donut: &#123; title: \"地區\", //控制環的粗細 width:80, label: &#123; show: true &#125; &#125;, //圖表的外部標題 title: &#123; text: \"銷售金額比例\" &#125; &#125;); Donut Chart 範例 先整理以上這些基本設定，以後若有新發現在隨時更新！如果有錯誤的地方，也請不吝告訴我。感謝！ 參考資料 Learning C3.js – Lesson 3 – Line Charts Javascript C3.js X axis label text position CodePen Home C3 Line Chart Demo Learning C3.js – Lesson 4 – Bar Charts js學習60天-c3.js筆記 JS 筆記 - C3.js 基本認識","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, JS直播班, C3.js","slug":"JavaScript-JS直播班-C3-js","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD-C3-js/"}]},{"title":"表單取值的誤區","slug":"formValueMistake","date":"2021-11-28T09:24:39.000Z","updated":"2022-07-06T00:34:24.000Z","comments":true,"path":"2021/11/28/formValueMistake/","link":"","permalink":"https://popeye-ux.github.io/2021/11/28/formValueMistake/","excerpt":"","text":"誤區一：忘記將表單中取出的「數字」由字串轉為數字從 input 中取出的值為「字串」，就算 type=number 取出來的值也是字串，不是數字。 在JS直播班第五周的作業，我就犯了這樣的錯誤。 &lt;input type&#x3D;&quot;number&quot; id&#x3D;&quot;targetInput&quot; value&#x3D;&#39;123&#39;&gt; &lt;button id&#x3D;&quot;btn&quot;&gt;觸發按鈕&lt;&#x2F;button&gt; 原本的 el.value 顯示為 string，要透過 parseInt之後才會轉為數字。 let el = document.querySelector(\"#targetInput\"); let btn = document.querySelector(\"#btn\"); btn.addEventListener(\"click\", function () &#123; console.log(el.value); //\"123\" 甚麼都不輸入的話，輸出預設值 console.log(typeof el.value); //\"string\" let newValue = parseInt(el.value); console.log(typeof newValue); //\"number\" &#125;); 誤區二：.value, .getAttribute(&#39;value&#39;) 兩者大不同這一點是我之前沒有思考過的問題。 在這個例子中，當我們做表單取值的時候，必須把 id 為 &quot;targetInput&quot;的表單元素綁訂到 el 這個變數上。然後利用 el.value去取值。 &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;targetInput&quot; value&#x3D;&quot;123&quot;&gt; &lt;button id&#x3D;&quot;firstBtn&quot;&gt;觸發按鈕&lt;&#x2F;button&gt; let el = document.querySelector('#targetInput'); let firstBtn = document.querySelector('#firstBtn'); console.log(`el.value: $&#123;el.value&#125;`); firstBtn.addEventListener('click', function()&#123; //輸入框填入任何值都會被 \"任意填入的值\" 取代 el.value = \"任意填入的值\"; console.log(`el.value: $&#123;el.value&#125;`); //\"任意填入的值\" &#125;) 但是使用 .getAttribute(&#39;value&#39;) 也能取到 input 元素 value 屬性的值，那 .value 和 .getAttribute(&#39;value&#39;) 有甚麼差別呢？ let el = document.querySelector(\"#targetInput\"); let firstBtn = document.querySelector(\"#firstBtn\"); console.log(`el.value: $&#123;el.value&#125;`); firstBtn.addEventListener(\"click\", function () &#123; //輸入框填入任何值都會被 \"任意填入的值\" 取代 el.value = \"任意填入的值\"; console.log(`el.value: $&#123;el.value&#125;`); //\"el.value: 任意填入的值\" let getValue = el.getAttribute(\"value\"); //getAttribute 取到的是 input 的預設值 ，而非 user 輸入的值 console.log(getValue); //\"123\" &#125;); el.value 會去捉取表單輸入的值，如果沒有輸入的話，就會去捉預設值。而 .getAttribute(&#39;value&#39;) 則不管使用者輸入甚麼，都會去捉預設值，而要改變預設值的話必須使用 el.setAttribute(&#39;value&#39;, &#39;456&#39;)。 let el = document.querySelector(\"#targetInput\"); let firstBtn = document.querySelector(\"#firstBtn\"); console.log(`el.value: $&#123;el.value&#125;`); firstBtn.addEventListener(\"click\", function () &#123; //輸入框填入任何值都會被 \"任意填入的值\" 取代 el.value = \"任意填入的值\"; console.log(`el.value: $&#123;el.value&#125;`); //\"el.value: 任意填入的值\" el.setAttribute('value', '456') let getValue = el.getAttribute(\"value\"); //getAttribute 取到的是 input 的預設值 ，而非 user 輸入的值 console.log(getValue); // \"456\" &#125;); 所以結論是表單取值不能使用 el.getAttribute(&quot;value&quot;)。 六角學院助教的提醒： el.value 對應的是 input 欄位目前「輸入的值」 el.getAttribute(‘value’) 對應的是 input 欄位的「預設屬性值」 修改 el.value 並不會影響 input 標籤的 value 預設屬性，使用 setAttribute() 才會。 真的每天都要花時間做每日任務，常常會發現自己不懂的地方。 誤區三： el.value 不等於 e.target.value今天看每日任務的時候有一瞬間被混淆了。 e.target.value 的 e 是事件監聽的事件物件，例如滑鼠點擊按鈕時會產生一個事件物件，e.target.value 是點擊事件所帶的資訊。 el.value 則是我們綁定表單元素，當輸入資訊時就會夾帶在 value 上。兩者並不相同。 今天的每日任務 。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, JS直播班","slug":"JavaScript-JS直播班","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD/"}]},{"title":"JS直播班 作業檢討--旅遊套票作業","slug":"travelticket","date":"2021-11-27T07:40:21.000Z","updated":"2022-05-01T16:49:36.000Z","comments":true,"path":"2021/11/27/travelticket/","link":"","permalink":"https://popeye-ux.github.io/2021/11/27/travelticket/","excerpt":"這是六角學院JS直播班第五周作業的檢討。 作業有現成的 HTML 與 CSS模板，是一個旅遊促銷套票的網站，可以新增套票會同步渲染到畫面上。","text":"這是六角學院JS直播班第五周作業的檢討。 作業有現成的 HTML 與 CSS模板，是一個旅遊促銷套票的網站，可以新增套票會同步渲染到畫面上。 我的作業CODE PEN 這也是我第一次抓資料渲染到網頁上，有些笨拙，也有些地方思慮不周，更有些地方根本沒有注意到就犯錯了。 所以我後來又去看了同學的作業，針對自己沒做好的地方改進，以下就是我的檢討： Level 2 把資料渲染到畫面上原本我是用字串累加，之後再innerHTML到綁定的DOM元素上： function renderScene(datas) &#123; let info = ''; datas.forEach(function (item) &#123; info += `&lt;li class=\"ticketCard\">&lt;div class=\"ticketCard-img\"> &lt;a href=\"#\"> &lt;img src=\"$&#123;item.imgUrl&#125;\" alt=\"$&#123;item.name&#125;\"> &lt;/a> &lt;div class=\"ticketCard-region\">$&#123;item.area&#125;&lt;/div> &lt;div class=\"ticketCard-rank\">$&#123;item.rate&#125;&lt;/div> &lt;/div> &lt;div class=\"ticketCard-content\"> &lt;div> &lt;h3> &lt;a href=\"#\" class=\"ticketCard-name\">$&#123;item.name&#125;&lt;/a> &lt;/h3> &lt;p class=\"ticketCard-description\"> $&#123;item.description&#125; &lt;/p> &lt;/div> &lt;div class=\"ticketCard-info\"> &lt;p class=\"ticketCard-num\"> &lt;span>&lt;i class=\"fas fa-exclamation-circle\">&lt;/i>&lt;/span> 剩下最後 &lt;span id=\"ticketCard-num\"> $&#123;item.group&#125; &lt;/span> 組 &lt;/p> &lt;p class=\"ticketCard-price\"> TWD &lt;span id=\"ticketCard-price\">$&#123;item.price&#125;&lt;/span> &lt;/p> &lt;/div> &lt;/div> &lt;/li>` &#125; ) ticketInfo.innerHTML = info; &#125; 後來看到同學更好的作法： 把要渲染到畫面上的卡片，單獨做成一個函式，回傳( return ) HTML 碼的字串。 再用陣列 reduce 的方法，把卡片渲染出來。 function cardTemplate(dataObj)&#123; return ` &lt;li class=\"ticketCard\"> &lt;div class=\"ticketCard-img\"> &lt;a href=\"#\"> &lt;img src=\"$&#123;dataObj.imgUrl&#125;\" alt=\"圖片\"> &lt;/a> &lt;div class=\"ticketCard-region\">$&#123;dataObj.area&#125;&lt;/div> &lt;div class=\"ticketCard-rank\">$&#123;dataObj.rate&#125;&lt;/div> &lt;/div> &lt;div class=\"ticketCard-content\"> &lt;div> &lt;h3> &lt;a href=\"#\" class=\"ticketCard-name\">$&#123;dataObj.name&#125;&lt;/a> &lt;/h3> &lt;p class=\"ticketCard-description\"> $&#123;dataObj.description&#125; &lt;/p> &lt;/div> &lt;div class=\"ticketCard-info\"> &lt;p class=\"ticketCard-num\"> &lt;span>&lt;i class=\"fas fa-exclamation-circle\">&lt;/i>&lt;/span> 剩下最後 &lt;span id=\"ticketCard-num\"> $&#123;dataObj.group&#125; &lt;/span> 組 &lt;/p> &lt;p class=\"ticketCard-price\"> TWD &lt;span id=\"ticketCard-price\">$ $&#123;dataObj.price&#125;&lt;/span> &lt;/p> &lt;/div> &lt;/div> &lt;/li> ` &#125; 用陣列的reduce方法累加，把版型組起來。 function render(newData = data) &#123; ticketCardArea.innerHTML = newData.reduce(function (accumulator, currentValue) &#123; console.log(newData); return accumulator + cardTemp(currentValue); &#125;, '') &#125; 初始值設為 ‘’ 空字串，傳入累加器 prev 。 第二個參數則帶入 ticketData 陣列裡的物件，讓它們傳入 cardTemplate 這個函式去累加。 這種方法把版型的資料跟組版的方法分開，我覺得更有邏輯。 版型在網頁一載進來時，data陣列中的資料就要渲染在卡片上，所以要在 JS 程式碼中先呼叫 render 函式。 render(); LEVEL 3 利用表單新增票卡這部分我的錯誤比較多： 成功新增套票後，所有的輸入欄位可以做清空。 套票組數欄位輸入值新增進去會呈現 undefined，程式碼第 108 行在抓取 HTML 元素時有誤，應該是抓取組數欄位的 input 標籤 id 元素。 ticketObj 物件變數缺少了 rate 套票星級屬性。 金額、組數、星級的 type 都需要為 Number，建議可以在程式碼第 124~126 行做轉型。 //新增套票邏輯 //綁定表單輸入框的元素 const ticketName = document.querySelector('#ticketName'); const ticketImgUrl = document.querySelector('#ticketImgUrl'); const ticketRegion = document.querySelector('#ticketRegion'); const ticketPrice = document.querySelector('#ticketPrice'); const ticketNum = document.querySelector('#ticketNum'); const ticketRate = document.querySelector('#ticketRate'); const ticketDescription = document.querySelector('#ticketDescription'); //綁掉輸送按鈕 const addBtn = document.querySelector('.addTicket-btn'); //對按鈕做事件監聽 addBtn.addEventListener('click', function (e) &#123; if (ticketName.value === '' || ticketImgUrl.value === '' || ticketRegion.value === '' || ticketDescription.value === '' || ticketDescription.value === '' || ticketNum.value === '' || ticketPrice.value === '') &#123; return alert('有些資訊沒有填寫！！！') &#125; if(ticketDescription.value.length > 100)&#123; return alert('套票描述的字數超過 100 字！！！') &#125; if(ticketRate.value > 10)&#123; return alert('套票星級要在 10 (含10) 以下！！！') &#125; let ticketObj = &#123;&#125;; ticketObj.id = data.length; ticketObj.name = ticketName.value; ticketObj.imgUrl = ticketImgUrl.value; ticketObj.area = ticketRegion.value; ticketObj.description = ticketDescription.value; ticketObj.group = Number(ticketNum.value); ticketObj.price = Number(ticketPrice.value); ticketObj.rate = Number(ticketRate.value); data.push(ticketObj); data.reverse(); renderScene(data); const form = document.querySelector('.addTicket-form'); form.reset(); &#125;) 為了要捉到表單的資料，我綁定了許多輸入框的DOM元素，結果還少捉了一個，真的是眼花了。 後來發現同學的方法非常聰明，監聽整個 &lt;form&gt; 元素，而不是一個一個的輸入框，然後用陣列的展開運算子(…)，把每個輸入框的元素轉為一個一個物件，再用 foreEach() 去取輸入的值，這樣就大功告成了，不用再一一去綁定輸入框的DOM元素來取值。 function addData(e) &#123; e.preventDefault(); const formArray = [...e.target]; //展開運算子(...) 會把每個輸入框變成一個物件，捉進陣列 console.log(formArray); //最後一個物件是 submit 按鈕，所以要把它去除掉 formArray.pop(); const obj = &#123; id: ticketData.length, &#125;; //必須去HTML改name的內容，讓它對應到資料的物件 formArray.map((item) => &#123; obj[item['name']] = item.value.trim(); &#125;); //把數字的字串轉為數字 obj.group = Number(obj.group); obj.price = Number(obj.price); obj.rate = Number(obj.rate) //表單驗證 if(obj.description.length > 100)&#123; return alert('套票描述的字數超過 100 字！！！') &#125;else if (obj.description === '')&#123; alert('套票描述沒有填') &#125; if(obj.rate > 10)&#123; return alert('套票星級要在 10 (含10) 以下！！！') &#125; ticketData.push(obj); render(); regionSearch.value = ''; formEl.reset(); &#125; LEVEL3 城市選單：選擇城市 變換網頁內容這個部分，我目前的程度寫出來是這樣子： //選取城市，渲染出符合城市條件的卡片 function selectCity (e) &#123; // ''空字串布林值為 false，利用!反轉變成 true if (!e.target.value ) &#123; render(ticketData) searchResultText.innerHTML = `本次搜尋共 $&#123;ticketData.length&#125; 筆資料`; &#125; else &#123; let selectedCity = ticketData.filter(function(item)&#123; return e.target.value === item.area; &#125;) console.log(selectedCity); searchResultText.innerHTML = `本次搜尋共 $&#123;selectedCity.length&#125; 筆資料`; render(selectedCity); &#125; &#125; 但是我也有看到同學利用「三元運算子」寫出很簡短的程式碼： function selectCity(e) &#123; const filterStr = e.target.value; filterStr === '' ? render() : render(ticketData.filter((item) => item.area === filterStr)) ; &#125; 他山之石可以攻錯，如果可以學習別人好的地方，來讓自己進步，就可以讓自己離目標更近一點。 修改過後的作業 參考資料 MDN Spread syntax (…)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, JS直播班, array","slug":"JavaScript-JS直播班-array","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD-array/"}]},{"title":"JS直播班 作業檢討--高雄里長OPEN DATA作業","slug":"villageOpenData","date":"2021-11-25T05:35:37.000Z","updated":"2022-05-01T16:49:34.000Z","comments":true,"path":"2021/11/25/villageOpenData/","link":"","permalink":"https://popeye-ux.github.io/2021/11/25/villageOpenData/","excerpt":"六角學院JS直播班第五周的小組任務，是要撈 《高雄的里長資訊》，我自己做完作業之後，再參考同學寫的code，我認為自己可以再改進優化：","text":"六角學院JS直播班第五周的小組任務，是要撈 《高雄的里長資訊》，我自己做完作業之後，再參考同學寫的code，我認為自己可以再改進優化： 作業要求的任務如下： 里長男女生人數比例 前鎮區有幾個里長 三民區有幾個女性里長 無黨籍、民主進步黨、中國國民黨各佔幾位？ 所有區里長人數都整理在一個物件裡 我的高雄市里長資訊作業 資料格式是一個陣列包著物件的JSON檔，物件的屬性為中文命名： let data = [ &#123; 區別: \"鹽埕區\", 里別: \"藍橋里\", 里長姓名: \"陳本興\", 性別: \"男\", 生日: \"0380817\", 辦公室電話: \"075219559\", 住家電話: \"075219559\", 手機: \"0921236319\", 信箱: \"kh01001@kcg.gov.tw\", 辦公室: \"鹽埕區藍橋里建國四路344號1樓\", 黨籍: \"其他\", 經歷: \"改制後第3.4屆,合併後第1.2屆\" &#125; //以下省略 ] 以下一一來檢討： 任務一：里長男女生人數比例我的做法是用陣列的 filter 方法，分別撈出男、女里長的資訊，再來算百分比就好了。 //里長人數等於陣列長度 let villageChiefNum = data.length; //filter 方法撈出 [\"性別\"]為男性的里長 let maleNum = data.filter((item) =>&#123; return item[\"性別\"] === \"男\"; &#125;) //filter 方法撈出 [\"性別\"]為女性的里長 let femaleNum = data.filter((item)=>&#123; return item[\"性別\"] === \"女\"; &#125;) let malePercent = ((maleNum.length/villageChiefNum)*100).toFixed(2); let femalePercent =((femaleNum.length/villageChiefNum)*100).toFixed(2); console.log(`高雄市的男性里長有 $&#123;maleNum.length&#125; 位，佔所有里長 $&#123;malePercent&#125; %的比例； 女性里長有 $&#123;femaleNum.length&#125; 位，佔所有里長 $&#123;femalePercent&#125; %的比例`) //高雄市的男性里長有 704 位，佔所有里長 79.01 %的比例； //女性里長有 187 位，佔所有里長 20.99 %的比例 而同學的做法如下： const genderRatioCalc = () => &#123; //設定初始值 let maleNum = 0; let femaleNum = 0; //用if else來處理男女人數 data.forEach((item) => &#123; if (item['性別'] === '男') &#123; maleNum += 1; &#125; else &#123; femaleNum += 1; &#125; &#125;) let malePercent = ((maleNum / villageChiefNum) * 100).toFixed(2); let femalePercent = ((femaleNum / villageChiefNum) * 100).toFixed(2); console.log(`高雄市的男性里長有 $&#123;maleNum&#125; 位，佔所有里長 $&#123;malePercent&#125; %的比例； 女性里長有 $&#123;femaleNum&#125; 位，佔所有里長 $&#123;femalePercent&#125; %的比例`) &#125; genderRatioCalc(); 任務一檢討： 我沒有先用 if else 去想，而事先想用 filter 撈出陣列，跳過邏輯判斷的部分。 沒用 input output 的觀念來思考，以至於忽略了可以封裝成一個函式。 任務二：前鎮區有幾個里長我這樣做： let villageArr = data.filter((item) => item[\"區別\"] === \"前鎮區\"); console.log(`前鎮區里長有$&#123;villageArr.length&#125;位`); 任務三： 三民區有幾個女性里長我這樣做： let sanminDistrictFemale = data.filter((item) => &#123; return (item[\"區別\"] === \"三民區\" &amp;&amp; item[\"性別\"] === \"女\"); &#125;) console.log(`三民區女性區長有$&#123;sanminDistrictFemale.length&#125;位`); 同學把任務二跟三包裝成一個函式來處理： function villageChief(villageName, sex = '') &#123; //設一個空陣列 let villageArr = []; //如果性別為空字串(沒有查詢)，只要處理 里長的人數 if (sex === '') &#123; villageArr = data.filter((item) => item['區別'] === villageName); console.log(villageArr); console.log(`$&#123;villageName&#125;里長有$&#123;villageArr.length&#125;位`); &#125; else &#123; //否則 里長的人數 與 性別都做處理 villageArr = data.filter((item) => item[\"區別\"] === villageName &amp;&amp; item[\"性別\"] === sex) console.log(`$&#123;villageName&#125;有$&#123;villageArr.length&#125;位$&#123;sex&#125;里長`); &#125; &#125; villageChief('前鎮區'); villageChief('三民區','女'); 任務二、三檢討： 沒用 input output 的觀念來思考。 根本沒想到 兩個任務可以合併來寫。 忽略了參數屬值的設定( sex &#x3D;&#x3D;&#x3D; ‘’ )，可以拿來做 if else 判斷，這個要學起來。 任務四：無黨籍、民主進步黨、中國國民黨各佔幾位？因為有指定黨籍，所以我這麼做： let party = &#123; \"國民黨\": 0, \"民主進步黨\": 0, \"中國國民黨\": 0 &#125;; data.forEach(function (item) &#123; party[item[\"黨籍\"]] += 1 &#125;) console.log(`高雄無黨籍有$&#123;party[\"無黨籍\"]&#125;位`); console.log(`高雄民主進步黨有$&#123;party[\"民主進步黨\"]&#125;位`); console.log(`高雄中國國民黨有$&#123;party[\"中國國民黨\"]&#125;位`); 但是同學這樣做： const partChiefCount = (party) => &#123; let partyChiefNum = 0; data.forEach((item) => &#123; if (item['黨籍'] === party) partyChiefNum += 1; &#125;); console.log(`$&#123;party&#125;共有$&#123;partyChiefNum&#125;位里長`); &#125; partChiefCount('無黨籍'); partChiefCount('民主進步黨'); partChiefCount('中國國民黨'); 一樣是忽略了 input 與 output。 如果今天不是指定要那些黨，我就要改變做法了。 任務五：所有區里長人數都整理在一個物件裡作業要求最後輸出時要變成以下的樣子： let total = &#123; \"前鎮區\":30, \"三民區\":50, \"苓雅區\":79, &#125; 我的想法： 撈出資料中所有的區，把它放入一個空陣列中。 過濾掉重複的區 ，變成一個新的陣列 distArry 把各區的名字變成物件 distObj 的屬性 把data的區別屬性，與distObj的區別屬性比對，兩者相同就加一//撈出資料中所有的區，放入一個空陣列中： let dist = []; data.forEach(function (item) &#123; distName = item[\"區別\"]; dist.push(distName); &#125;) //過濾掉重複的區 let distArry = dist.filter(function (item, index) &#123; return dist.indexOf(item) === index; &#125;) //把所有的區名變成物件屬性，預設值為 0 let distObj = &#123;&#125;; distArry.map(function (item, index) &#123; distObj[item] = 0; &#125;) //跑data陣列物件與distObj物件比對，區別的值與物件的屬性一樣，那物件那邊的屬性值就加一 //三角關係：data，distArry,distObj data.forEach(function (item, index, array) &#123; distObj[item['區別']] += 1; &#125;) 同學的做法，又快又簡單： let total = &#123;&#125;; const organizeChiefOfVillage = () => &#123; data.forEach((item) => &#123; //如果物件沒有該屬性的話，則設置屬性，並給初始值數值 1 if (total[item['區別']] === undefined) &#123; total[item['區別']] = 1; &#125; else &#123; // 如果物件有屬性，則直接+1 total[item['區別']] += 1; &#125; &#125;); &#125; organizeChiefOfVillage(); console.log(total); 任務五檢討可能是剛做完陣列方法的筆記，對於 filter 的印象太過深刻，所以思考路徑會一直往 filter 跑，完全忘記用 if else 也可以篩選，還有是物件取值的方法不夠熟練，所以不會往那邊去想解決方法。 最後要做的時候要想 input 與 output，盡量想想怎樣可以更完整的解決問題。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, JS直播班, array","slug":"JavaScript-JS直播班-array","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD-array/"}]},{"title":"實用陣列操作大全-進階使用方法","slug":"arrayAdvance","date":"2021-11-20T07:22:17.000Z","updated":"2022-05-01T16:49:48.000Z","comments":true,"path":"2021/11/20/arrayAdvance/","link":"","permalink":"https://popeye-ux.github.io/2021/11/20/arrayAdvance/","excerpt":"陣列裡是有順序的集合，每個元素因為有索引。所以可以用迴圈的方法來遍歷陣列裡的元素，來進行有條件的篩選。","text":"陣列裡是有順序的集合，每個元素因為有索引。所以可以用迴圈的方法來遍歷陣列裡的元素，來進行有條件的篩選。 最常用的就是 for 迴圈處理陣列元素的遍歷問題。 它的撰寫規則如下： for ([initialization]; [condition]; [final-expression]) statement initialization：初始表達式，也就是按下計數器，從條件的初始值開始計算。 condition：判斷條件成不成立，如果回傳 true ,則迴圈繼續執行；如果為 false 則迴圈終止。 final-expression：遞增表達式，每次迴圈執行完，判斷條件加 1 ，直到判斷條件不成立。 假設我們要依序印出 avangers 這個超級英雄的陣列元素，用 for 迴圈可以這樣做： const avengers = ['鋼鐵人', '美國隊長', '浩克', '雷神', '驚奇隊長']; for (let i = 0; i &lt; avengers.length; i++)&#123; console.log(i + avengers[i]); &#125; // 依序印出： // 0鋼鐵人 // 1美國隊長 // 2浩克 // 3雷神 // 4驚奇隊長 可以看出 for 迴圈是依照條件，不斷地透過索引去撈出陣列中對應的元素（遍歷整個陣列），然後一次一次印出迴圈中的元素。直到條件不符合，才終止迴圈的執行。 但是現在操作陣列不用那麼麻煩，ES5之後，新增了許多操作陣列的方法，讓我們一起來看看吧！ Array.prototype.forEach() forEach() 方法會將陣列內的每個元素，皆傳入並執行給定的函式一次。直接修改原本的陣列。 arr.forEach(function (currentValue[, index[, array]]) &#123; //your iterator &#125;); function ： 給定的函式，是一個 callBack function，會把陣列中的每個元素當作參數帶入陣列中，每個元素執行一次。 currentValue ： 這個參數代表陣列中輪到被函式處理的元素。 index ： 這個參數代表陣列中正在被函式處理的元素的索引值。可省略。 array ： 代表被執行的陣列。可省略。 const avengers = ['鋼鐵人', '美國隊長', '浩克', '雷神']; let newArray = avengers.forEach(function(item,index,array)&#123; console.log(`$&#123;item&#125; 的索引值是 $&#123;index&#125;，陣列的內容是 [$&#123;array&#125;]`) &#125;) // 鋼鐵人 的索引值是 0，陣列的內容是 [鋼鐵人,美國隊長,浩克,雷神] // 美國隊長 的索引值是 1，陣列的內容是 [鋼鐵人,美國隊長,浩克,雷神] // 浩克 的索引值是 2，陣列的內容是 [鋼鐵人,美國隊長,浩克,雷神] // 雷神 的索引值是 3，陣列的內容是 [鋼鐵人,美國隊長,浩克,雷神] console.log(newArray); // undefined 和 for 迴圈比較起來， forEach 不用設定任何條件，也不用初始化，就可以把每個元素傳入函式中執行。 要注意的是 forEach 方法不會回傳任何的值，所以 console.log 的值是「 Uncaught ReferenceError: newArray is not defined 」。 另外，for 迴圈可以使用 break 跳出，但是 forEach()如果使用break會紅字報錯。 const avengers = ['鋼鐵人', '美國隊長', '浩克', '雷神']; avengers.forEach(function(item)&#123; if (item ==='美國隊長' )&#123; break; //Uncaught SyntaxError: Illegal break statement &#125; &#125;) forEach也不會理會使用return的方法中止程式執行，會一路跑完。 const avengers = ['鋼鐵人', '美國隊長', '浩克', '雷神']; avengers.forEach(function(item)&#123; if (item ==='美國隊長' )&#123; return; &#125; &#125;) console.log(avengers) //[\"鋼鐵人\",\"美國隊長\",\"浩克\",\"雷神\"] array.prototype.map map() 方法會建立一個新的陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。 也就是我們使用 map() 的時候，會透過給定的函式條件處理原來的陣列，再回傳一個新的陣列。 語法： let new_array = arr.map(function callback( currentValue[, index[, array]]) &#123; // return element for new_array &#125;[, thisArg]) function ： 給定的函式是一個回呼函式。會把陣列中的每個元素當作參數帶入陣列中，每個元素執行一次。 index ： 處理中的元素索引。 array ： 當前函式處理的陣列。 範例：找出名字的字串長度是2的超級英雄。 const avengers = ['鋼鐵人', '美國隊長', '浩克', '雷神']; let newArray = avengers.map(function(item)&#123; if(item.length === 2)&#123; return item; &#125; &#125;) console.log(newArray) //[undefined, undefined, '浩克', '雷神'] map() 的特色是： 適合用來篩選特定資料。 map() 所帶函式回傳的值，會組成一個新的陣列回傳。 不會改變原來的陣列。 回傳的陣列長度會等於原始的陣列長度。 如果沒有回傳值，則元素的值為undefined。 上面的範例，如果寫法照搬，只把 map 改成 forEach： const avengers = ['鋼鐵人', '美國隊長', '浩克', '雷神']; let newArray = avengers.forEach(function(item)&#123; if(item.length === 2)&#123; return item; &#125; &#125;) console.log(newArray) //undefined console.log(avengers) [\"鋼鐵人\",\"美國隊長\",\"浩克\",\"雷神\"] forEach 方法不會回傳值，所以 newArray 查詢的結果是 undefined。而 avengers 原始陣列也沒有被改變。 如果要改變原始陣列的話，要這樣子寫： const avengers = ['鋼鐵人', '美國隊長', '浩克', '雷神']; let newArray = avengers.forEach(function(item,index,array)&#123; if(item.length === 2)&#123; array[index] = item; &#125;else&#123; array[index] = \"undefined\"; &#125; &#125;) console.log(newArray) //undefined console.log(avengers) //['undefined', 'undefined', '浩克', '雷神'] 因為forEach不會回傳值， let newArray &#x3D; 這一段其實不用寫了，寫出來只是為了方便比較。 Array.prototype.filter() filter() 方法會建立一個經指定之函式運算後，由原陣列中通過該函式檢驗之元素所構成的新陣列。 語法如下： var newArray = arr.filter(callback(element[, index[, array]])[, thisArg]) element ： 當前處理到的元素。 index ： 給定函式目前處理的元素索引。可省略。 array ： 給定函式目前處理的陣列。可省略。 範例： const avengers = ['鋼鐵人', '美國隊長', '浩克', '雷神']; let newArray = avengers.filter(function(item)&#123; return item.length === 2 ; &#125;) console.log(newArray) [\"浩克\",\"雷神\"] console.log(avengers) [\"鋼鐵人\",\"美國隊長\",\"浩克\",\"雷神\"] 可以觀察到 filter 過濾出字串長度為 2 的陣列元素，並回傳一個新的陣列。而原來的陣列沒被改變。 filter()也可以用來過濾掉陣列中的重複值： const avengers = ['鋼鐵人', '美國隊長', '浩克','鋼鐵人', '雷神','美國隊長']; let newArray = avengers.filter(function (item,index,array)&#123; console.log(avengers.indexOf(item)); //回傳第一個找到的元素索引 console.log(index); //函式當前處理的元素索引 return avengers.indexOf(item) === index; //當第一個找到的元素索引等於函式目前處理的元素索引 &#125;) console.log(newArray); //[\"鋼鐵人\",\"美國隊長\",\"浩克\",\"雷神\"] const avengers = [ &#123; name: '鋼鐵人', firePower: 10, bodyForce: 5 &#125;, &#123; name: '美國隊長', firePower: 5, bodyForce: 8 &#125;, &#123; name: '浩克', firePower: 0, bodyForce: 10 &#125; ] const newAvengers= avengers.filter(member => member.firePower >= 5); console.log(newAvengers); 回傳值為一個新的陣列，陣列裡有 2 個物件， firePower 都大於或等於 5 ： Array.prototype.every() every() 方法會測試陣列中的所有元素是否都通過了由給定之函式所實作的測試。回傳值為布林值， true 或 false。 every() 方法可以用來檢測陣列中的元素是否符合特定條件。 語法： var newArray = arr.every(callback(currentValue[, index[, array]])[, thisArg]) currentValue ： 目前正被回呼函式處理的元素。 index ： 目前被處理元素的陣列索引。可省略。 array ： 目前被處理的陣列。可省略。const avengers = [ &#123; name: '鋼鐵人', firePower: 10, bodyForce: 5 &#125;, &#123; name: '美國隊長', firePower: 5, bodyForce: 8 &#125;, &#123; name: '浩克', firePower: 0, bodyForce: 10 &#125; ] const isGoodPower= avengers.every(function(member) &#123; return member.firePower >= 5; &#125;); console.log(isGoodPower); //false 並不是所有超級英雄的武裝火力都超過 5 Array.prototype.some() some() 方法會透過給定函式、測試陣列中是否至少有一個元素，通過該函式所實作的測試。這方法回傳的是布林值。 也就是陣列中只要有一個元素符合指定函式的條件，就回傳 true ，否則就回傳 false 。 語法： var newArray = arr.some(callback(currentValue[, index[, array]])[, thisArg]) currentValue ： 目前正被回呼函式處理的元素。 index ： 目前被處理元素的陣列索引。可省略。 array ： 目前被處理的陣列。可省略。 const avengers = [ &#123; name: '鋼鐵人', firePower: 10, bodyForce: 5 &#125;, &#123; name: '美國隊長', firePower: 5, bodyForce: 8 &#125;, &#123; name: '浩克', firePower: 0, bodyForce: 10 &#125; ] const isGoodPower= avengers.some(function(member) &#123; return member.firePower >= 5; &#125;); console.log(isGoodPower); //true Array.prototype.reduce()MDN上寫著： reduce() 方法將一個累加器及陣列中每項元素（由左至右）傳入回呼函式，將陣列化為單一值。 通常用來做陣列中數字的累加。 語法為： arr.reduce(callback[accumulator, currentValue, currentIndex, array], initialValue) accumulator：累加器，個別 currentValue 加總的累計值，如果是第一次呼叫，就看有沒有初始值來決定累加器一開始的值。 currentValue：陣列的個別元素 currentIndex：陣列的個別元素索引 array：回呼函式處理的陣列，可省略。 initialValue：預設值，可省略。 const avengers = [ &#123; name: '鋼鐵人', firePower: 10, bodyForce: 5 &#125;, &#123; name: '美國隊長', firePower: 5, bodyForce: 8 &#125;, &#123; name: '浩克', firePower: 0, bodyForce: 10 &#125; ] let reduceAvenger = avengers.reduce(function(accumulator, currentValue)&#123; return accumulator + currentValue.firePower; &#125;) console.log(reduceAvenger); //[object Object]50 !!!! //因為未提供初始值，預設 陣列 第一個值，作為初始值。 //第一個值為一個 Object，結果造成非預期的錯誤 因為未提供初始值，所以出現了錯誤。 沒有預設值的話，accumulator（累計值）會取陣列的第一個元素當作預設值。所以我們加上預設值，再來一次。 const avengers = [ &#123; name: '鋼鐵人', firePower: 10, bodyForce: 5 &#125;, &#123; name: '美國隊長', firePower: 5, bodyForce: 8 &#125;, &#123; name: '浩克', firePower: 0, bodyForce: 10 &#125; ] let reduceAvenger = avengers.reduce(function(accumulator, currentValue)&#123; return accumulator + currentValue.firePower; &#125;,0) console.log(reduceAvenger); //15 reduce()也可以拿來合併陣列： let avengers = [['鋼鐵人','蜘蛛人'],['浩克','雷神'],['美國隊長','黑寡婦']] newAvengers = avengers.reduce((accumulator,currentValue)=>&#123; return accumulator.concat(currentValue) &#125;,[]) console.log(newAvengers) //['鋼鐵人', '蜘蛛人', '浩克', '雷神', '美國隊長', '黑寡婦'] 參考資料 for 迴圈與 forEach 有什麼不同 Array 原型的 forEach 有多好用？ 學會高階函數之後都不想寫 JavaScript 以外的程式語言了 在 JavaScript 的 Array.prototype.forEach() 方法實現 continue; 及 break; 的效果 Javascript Array forEach()中无法return和break，代替方法some()与every() 【JS】旅遊網之行政區選單、分頁功能實作 JavaScript 陣列處理方法 [filter(), find(), forEach(), map(), every(), some(), reduce()] JavaScript 陣列中兩個冷門的方法：Every、Some JavaScript reduce 在做什麼？ 認識 JavaScript Reduce","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, JS直播班, array","slug":"JavaScript-JS直播班-array","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD-array/"}]},{"title":"實用陣列操作大全-基礎篇","slug":"arrayBasic","date":"2021-11-16T07:20:04.000Z","updated":"2022-05-01T16:49:48.000Z","comments":true,"path":"2021/11/16/arrayBasic/","link":"","permalink":"https://popeye-ux.github.io/2021/11/16/arrayBasic/","excerpt":"陣列可以被視為是一種特別的「物件」，和物件一樣，是零到多個屬性的集合，而且沒限制甚麼東西不能放進去，所以陣列裡面可以是字串、數字等基本型別，也可以是物件、函式，甚至是另一個陣列。","text":"陣列可以被視為是一種特別的「物件」，和物件一樣，是零到多個屬性的集合，而且沒限制甚麼東西不能放進去，所以陣列裡面可以是字串、數字等基本型別，也可以是物件、函式，甚至是另一個陣列。 而陣列與物件的差別在於，陣列是有順序的集合，能夠透過中括號[]加上索引來存取。也因為這種特性，所以陣列有許多的方法可以使用。 圖片來源：codingyuri 這次就來談談如何運用陣列的基本方法： Array.prototype.push() 使用 push() 方法可以在陣列尾端新增一個值。push() 方法回傳的值為陣列長度。 這一天有一塊巨大的隕石往地球飛來，超級英雄們緊急集合，要把隕石推出太陽系，但是隕石太大顆，所以又找了驚奇隊長來幫忙。 let array = ['鋼鐵人','美國隊長','浩克','雷神'] let value = array.push('驚奇隊長'); console.log(array); //['鋼鐵人', '美國隊長', '浩克', '雷神', '驚奇隊長'] console.log(value); // 5 push() 適用的在類似搶頭香的情境中。 Array.prototype.unshift() 使用 unshift() 可以在把想要新增的元素插入在陣列第一個元素的位置，也就是 index 為 0 的位置。unshift() 回傳的值也是陣列長度。 let array = ['鋼鐵人','美國隊長','浩克','雷神'] let value = array.unshift('黑寡婦'); console.log(array); //['黑寡婦', '鋼鐵人', '美國隊長', '浩克', '雷神'] console.log(array[0]); //'黑寡婦' console.log(value); // 5 unshift() 則適用於新聞類的排序，越新的新聞排到越前面。 Array.prototype.pop() 如果要把陣列尾端的元素刪除，可以使用 pop() 方法。pop() 方法回傳的值為被刪除的元素。 let array = ['鋼鐵人','美國隊長','浩克','雷神'] let value = array.pop(); console.log(array); //['鋼鐵人', '美國隊長', '浩克', ] console.log(value); // '雷神' pop 是取自 Popping 這個單字，意思是彈出。不是流行音樂的意思。 Array.prototype.shift() 如果要把陣列第一個元素刪除，可以使用 shift() 方法。shift() 方法回傳的值為被刪除的元素。 let array = ['鋼鐵人','美國隊長','浩克','雷神'] let value = array.shift(); console.log(array); //['美國隊長', '浩克', '雷神'] //array[0]的鋼鐵人被刪除了 console.log(value); // '鋼鐵人' Array.prototype.splice splice()可以刪除指定位置的陣列元素，或新增指定位置的陣列元素。回傳一個新的陣列，裡面放著被刪除的元素。 array.splice(startIndex[, deleteCount[, item1[, item2[, ...]]]]) startIndex ：要開始修改的索引位置。 deleteCount ：要刪除的元素數量(從startIndex位置的原四開始算)。 item1,item2… ：新增的元素，由startIndex開始新增。這個選項可以選擇性使用。 來個情境題：這一天復仇者聯盟的超級英雄們舉辦派對，結果不小心混入了兩個正義聯盟的英雄，請問要如何把他們找出來，並且叫一台車把他們裝在一起送回家？ let array = ['鋼鐵人','蜘蛛人','超人','蝙蝠俠','浩克','雷神']; let newArray = array.splice(2,2); console.log(array); //['鋼鐵人', '蜘蛛人', '浩克', '雷神'] console.log(newArray); //['超人', '蝙蝠俠'] 原本由超人與蝙蝠俠占用的名額由’驚奇隊長’跟’緋紅女巫’來代表。 let array = ['鋼鐵人','蜘蛛人','浩克','雷神']; let newArray = array.splice(2,0,'驚奇隊長','緋紅女巫'); console.log(array); //['鋼鐵人', '蜘蛛人', '驚奇隊長', '緋紅女巫', '浩克', '雷神'] console.log(newArray); //[]回傳空陣列 Array.prototype.sort()MDN上的解釋： 來看一下MDN上關於sort()的解說：sort() 方法會原地（in place）對一個陣列的所有元素進行排序，並回傳此陣列。排序不一定是穩定的（stable）。預設的排序順序是根據字串的 Unicode 編碼位置（code points）而定。 什麼?根據 Unicode 編碼位置（code points）來決定順序，這是甚麼東西? 來看看MDN上的範例： const months = ['March', 'Jan', 'Feb', 'Dec']; months.sort(); console.log(months); // expected output: Array [\"Dec\", \"Feb\", \"Jan\", \"March\"] const array1 = [1, 30, 4, 21, 100000]; array1.sort(); console.log(array1); // expected output: Array [1, 100000, 21, 30, 4] 不是由大到小，也不是由小到大，這實在是讓人一頭霧水呀？？？ MDN上面sort()方法的撰寫規則如下： arr.sort([compareFunction]) 也就是說如果你沒用一個判別大小的函式來做判斷，才會使用Unicode 編碼位置（code points）來決定順序。 如果你真的像要為數字排大小(當比較的是數字的時候)，可以寫一個函式來判別： var numbers = [4, 2, 5, 1, 3]; numbers.sort(function(a, b) &#123; if (a > b) return 1; if (a &lt; b) return -1; return 0; &#125;); console.log(numbers); // [1, 2, 3, 4, 5] 上面的判斷式也就是把陣列元素一一拿來當作a與b兩個參數，傳入判斷式做比較： 如果回傳的值小於 0，則 a 的索引位置比 b 的小，也就是 a 在 b 前面。 如果回傳的值大於 0，則 b 的索引位置 比 b 的大，也就是 a 在 b 後面。 如果等於 0，則 a 與 b 的位置不會改變，但會與陣列其他元素繼續比較。 至於是陣列索引小的當a，還是大的當a，則倚賴個瀏覽器廠商的實作。 compareFunction要更簡潔一些，可以這樣寫： var numbers = [4, 2, 5, 1, 3]; numbers.sort(function(a, b) &#123; return a - b; &#125;); console.log(numbers); // [1, 2, 3, 4, 5] MDN也寫了：由於依賴執行環境的實作，所以並不能保證排序的時間及空間複雜度。 也就是，sort() 這個方法，每家瀏覽器背後運作的原理都不相同。 像是Chrome瀏覽器，一般是使用快速排序法( Quick Sort )，但是在陣列裡面的元素小於10的時候是使用插入排序法( Insertion Sort)，還使用了二分搜尋法 Binary Search 來優化排序。( 詳細說明可以參考： 淺談 JS sort() 到背後排序方法 ) 我認為 sort() 是可以深入再研究的一個陣列方法，但是身為一個陣列大全，就先點到為止。 Array.prototype.indexOf()MDN上的解釋： 回傳給定元素於陣列中第一個被找到之索引位置，若不存在於陣列中則回傳 -1。適合用來確認陣列中那個元素是否存在。 array.indexOf(searchElement,fromIndex) searchElement：要找的元素。 fromIndex：要從第幾個元素開始找，預設為0。這個參數可以不設。 let array = ['鋼鐵人','蜘蛛人','浩克','雷神','鋼鐵人']; let value = array.indexOf('浩克'); console.log(value); // 2 let value1 = array.indexOf('鋼鐵人',2) console.log(value1); // 4 因為是從 [2] 的浩克開始往後面找。 let value2 = array.indexOf('美國隊長'); console.log(value2); // -1 美國隊長沒有在陣列中 Array.prototype.lastIndexOf()MDN上的解釋： 回傳給定元素於陣列中最後一個被找到之索引，若不存在於陣列中則回傳 -1。搜尋的方向為由陣列尾部向後（即向前）尋找，啟始於 fromIndex。 let array = ['鋼鐵人','蜘蛛人','浩克','雷神','鋼鐵人']; let value = array.lastIndexOf('浩克'); console.log(value); // 2 let value1 = array.lastIndexOf('鋼鐵人',2) console.log(value1); // 0 因為是從'浩克'往前找，找到的'鋼鐵人'是在索引[0] 的位置 let value2 = array.lastIndexOf('美國隊長'); console.log(value2); // -1 Array.prototype.prototype.findIndex()MDN上的解釋： findIndex()方法傳回陣列中滿足測試函式的第一個元素的索引。如果沒找到對應元素就回傳 -1。 findIndex()與indexOf()相似，但是findIndex()可以帶入函式來判斷陣列中是否有滿足函式條件的元素。 const avengers = [ &#123; name: '鋼鐵人', firePower: 10, bodyForce: 5 &#125;, &#123; name: '美國隊長', firePower: 5, bodyForce: 8 &#125;, &#123; name: '浩克', firePower: 0, bodyForce: 10 &#125; ] let isFirePower = function(element)&#123; return element.firePower === 5; &#125; console.log(avengers.findIndex(isFirePower)) // 1 Array.prototype.reverse()MDN上的解釋： 反轉（reverses）一個陣列。陣列中的第一個元素變為最後一個，而最後一個元素則變成第一個。回傳的值為反轉的陣列本身。 let array = ['鋼鐵人','蜘蛛人','浩克','雷神']; let newArray = array.reverse(); console.log(array); //['雷神', '浩克', '蜘蛛人', '鋼鐵人'] console.log(newArray); //['雷神', '浩克', '蜘蛛人', '鋼鐵人'] Array.join 會將陣列（或一個類陣列（array-like）物件）中所有的元素連接、合併成一個字串，並回傳這個字串。 arr.join([separator]) separator：用來隔開每個元素的字串，預設是英文逗號 (,) ，如果separator使用空字串的話，合併之後，元素之間不會有任何區隔。 let array = ['鋼鐵人','蜘蛛人','浩克','雷神']; let newArray = array.join('*'); console.log(newArray); //鋼鐵人*蜘蛛人*浩克*雷神 Array.prototype.concatMDN上的解釋： 用來合併兩個或多個陣列。不會改變現有的陣列，回傳一個包含呼叫者陣列本身的新陣列。 var new_array = old_array.concat(value1[, value2[, ...[, valueN]]]) 範例： let justice = ['超人','蝙蝠俠','神力女超人'] let avangers = ['鋼鐵人','蜘蛛人','浩克','雷神']; let justiceAvangers = justice.concat(avangers); console.log(justiceAvangers); //['超人', '蝙蝠俠', '神力女超人', '蜘蛛人', '浩克', '雷神', '鋼鐵人'] 也可以陣列合併字串： let avengers = ['鋼鐵人','蜘蛛人','浩克','雷神']; let newAvengers = avengers.concat('黑寡婦'); console.log(newAvengers); //['鋼鐵人', '蜘蛛人', '浩克', '雷神', '黑寡婦'] Array.prototype.sliceMDN上的解釋： 取出起始索引到結束索引的元素，並回傳由取出元素所組成的新陣列。原有陣列不會被修改 arr.slice([begin[, end]]) const avengers = ['鋼鐵人','蜘蛛人','浩克','雷神','奇異博士','黑豹']; let newAvengers = avengers.slice(2,4); console.log(newAvengers); //['浩克', '雷神'] Array.prototype.includes() includes() 方法會判斷陣列是否包含特定的元素，並以此來回傳 true 或 false。 const avengers = ['鋼鐵人','蜘蛛人','浩克','雷神','奇異博士','黑豹']; console.log(avengers.includes('雷神')); //true console.log(avengers.includes('黑寡婦')); //false Array.prototype.toString()MDN上的解釋： toString() 方法將回傳一個可以表達該陣列及其元素的字串。陣列的每個元素將被轉為字串，並以,連接，同時會回傳該字串。 const avengers = ['鋼鐵人','蜘蛛人','浩克','雷神']; let newAvengers = avengers.toString(); console.log(newAvengers); //\"鋼鐵人,蜘蛛人,浩克,雷神\" //每個元素被轉為字串，並以逗號連接。 參考資料-MDN : Array.prototype.sort-從 Array 的 sort 方法，聊到各瀏覽器的實作，沒想到 Chrome 和FireFox 的排序如此不同-淺談 JS sort() 到背後排序方法","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, JS直播班, array","slug":"JavaScript-JS直播班-array","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD-array/"}]},{"title":"何謂 hoisting(向上提升)？以 let、const、var、function 為例","slug":"hoisting","date":"2021-11-12T07:17:51.000Z","updated":"2022-05-01T16:49:44.000Z","comments":true,"path":"2021/11/12/hoisting/","link":"","permalink":"https://popeye-ux.github.io/2021/11/12/hoisting/","excerpt":"向上提升( Hoisting )指的是 JavaScript 允許函式與變數在宣告之前，就可以叫用而不會出錯的一種情況。","text":"向上提升( Hoisting )指的是 JavaScript 允許函式與變數在宣告之前，就可以叫用而不會出錯的一種情況。 以上就是我本來了解的「向上提升( Hoisting )」，我以為自己懂了，寫這篇筆記查資料時，我才發現自己並不懂。 先來談談變數的「向上提升( Hoisting )」。 變數的向上提升(hoisting)在 JavaScript 中建立變數包含2個動作： 宣告：就是給變數一個名稱。 初始化：給變數一個初始值。 ES6 的 let 與 const 出現之前，在 JavaScript 中都使用 var 來宣告變數。 程式碼的執行過程中，用var宣告變數可以在前面就先使用，後面才宣告。宣告之前叫用不會出現錯誤，只是會給變數 undefined 的值而已。 console.log(superMan); //Uncaught ReferenceError: superMan is not defined console.log(wonderWoman); //Uncaught ReferenceError: wonderWoman is not defined wonderWoman = '黛安娜'; console.log(batMan); //undefined 在程式碼的前面呼叫 var batMan = '布魯斯·韋恩'; //後面才宣告賦值 在上面的範例中， superMan 沒有被宣告，所以JavaScript在程式碼中找不到這個變數，直接報錯： Uncaught ReferenceError: superMan is not defined。 wonderWoman 雖然有宣告，但是並沒有使用 var 來宣告，在提前叫用的時候，console.log的結果也是： Uncaught ReferenceError: wonderWoman is not defined。 var宣告的變數只會提升宣告，不會提升賦值使用var來宣告的變數在JavaScript中有特別待遇，上面的範例用var宣告 superMan 之前，console.log(superMan)並不會報錯，而是出現 ‘undefined’。這是因為JavaScript在執行時發現有沒被宣告的變數，它會先在程式碼中找一找看是否在後面被宣告了，如果有宣告，那就把宣告「提升(Hosting)」到前面。 要注意的是： var 宣告的變數，宣告的部分會提升，但是賦值的部分不會提升，所以 console.log() 時雖然不會報錯，而是會出現 ‘undefined’，呈現一種沒有給值的狀態。 那提升的過程中發生了甚麼事呢？以上面的batMan為例： console.log(batMan); //undefined var batMan = '布魯斯·韋恩'; 其實是變成這樣： var batMan; //宣告被提前了 console.log(batMan); //undefined batMan = '布魯斯·韋恩'; //但是賦值還在後面 var宣告變數的提升(Hoisting)其實就是把宣告與賦值拆成兩個部分，宣告提到前面執行，賦值則還在後面本來的位置上。 but…在《我知道你懂 hoisting，可是你了解到多深？》看到兩個範例，我把它改寫一下，來增強自己的記憶，先看這個： var batMan = '布魯斯·韋恩'; var batMan; console.log(batMan); //布魯斯·韋恩 嗯，結果不是 ‘undefined’ 喔，而是 ‘布魯斯·韋恩’！上面那個例子，還是可以切分為「宣告」與「賦值」這兩部分： var batMan; var batMan; batMan = '布魯斯·韋恩'; console.log(batMan); //布魯斯·韋恩 再來看這個範例： function batManWeapon(arm)&#123; console.log(arm); var arm = '蝙蝠摩托'; &#125; batManWeapon('蝙蝠車') // '蝙蝠車' 答案是蝙蝠車喔！ 這個過程是這樣的： function batManWeapon(arm)&#123; var arm = '蝙蝠車'; //batManWeapon('蝙蝠車')呼叫函式，帶入的參數。 var arm; //變數提升 console.log(arm) arm = '蝙蝠摩托' &#125; batManWeapon('蝙蝠車') // '蝙蝠車' 這是變數提升(Hosting)需要特別注意的地方。 let與const宣告的變數有被提升的待遇嗎?我們來看看用let與const宣告的變數是否會有「向上提升」的待遇： console.log(superMan); //Uncaught ReferenceError: batMan is not defined let superMan = '克拉克'; console.log(batMan); const batMan = '布魯斯.偉恩' //Uncaught ReferenceError: batMan is not defined console.log的結果都是 “Uncaught ReferenceError: batMan is not defined”,這樣我們是否可以說用 let 與 const 宣告的變數沒有「向上提升」的待遇？ 再來看一下這個範例： let superMan = '克拉克'; function superHero()&#123; console.log(superMan); &#125; superHero() //'克拉克' superHero()函式的作用域中沒有宣告superMan，所以函式外的全域環境去找這個變數，找到 let superMan &#x3D; ‘克拉克’ ，就把這個同名的變數捉進函式內使用。 那如果題目改成這樣呢？ let superMan = '克拉克'; function superHero()&#123; console.log(superMan); let superMan = '攝影記者'; &#125; superHero() //Uncaught ReferenceError: Cannot access 'superMan' before initialization 這一題出現紅字：意思是 superMan 這個變數在初始化之前，無法使用。 這就有一個問題：如果 superHero 函式內的 superMan 變數沒被提升，那應該會去捉函式外部的 superMan &#x3D; ‘克拉克’ 這個變數，而不是跑出 Uncaught ReferenceError: Cannot access ‘superMan’ before initialization 這樣的紅字結果。 所以JavaScript在執行的時候，一定也有在函式內部找，找到在 console.log 後面有宣告 superMan這個變數，既然作用域裡面有宣告，就不去外面找，所以就給你報錯的結果：Uncaught ReferenceError: Cannot access ‘superMan’ before initialization。 差別只在 用var宣告的變數「提升」時會被賦予 ‘undefined’，但是用 let 與 const 宣告的變數「提升」時卻是紅字報錯，讓程式中斷執行不下去? 暫時死區Temporal Dead Zonelet宣告的變數在尚未賦值之前，不像var一樣會以undefined初始化，所以let與const宣告的變數從宣告到初始化之間，將會無法操作，這段時間稱為「暫時死區」(Temporal Dead Zone)。 const因為宣告時，必須給值，且之後不能再改變，所以沒有TDZ的問題。 函式的向上提升函式可以分為兩種： 以「函式宣告」定義的函式 函式運算式 其中以「函式宣告」定義的函式，可以在函式宣告前就使用，這就稱為「函式提升」。隨叫隨到，不管身在何方，真的是 JavaScript 裡面的超級英雄。 batMan();//布魯斯‧韋恩 function batMan()&#123; console.log('布魯斯‧韋恩') &#125; 但是，函式運算式在宣告前呼叫函式就會報錯。 batMan(); //Uncaught ReferenceError: batMan is not defined let batMan = function()&#123; console.log('布魯斯‧韋恩') &#125; 而且函式的提升，不像 var 宣告變數那樣用 ‘undefined’ 暫時充代，而是整個內容都被提升。 為什麼函式需要「向上提升」呢？之前對於「提升」( Hoisting )這個題目只是硬背了起來，直到這次寫筆記與作 BMI KATA 的練習才恍然大悟。 這是因為方便函式之間彼此呼叫使用，在前面宣告的函式可以去叫後面才宣告的函式來使用。如果沒有「提升」( Hosisting )的話，函式的使用會疊床架屋，十分冗長。 最後來個情境題，假設噗攏共星球的外星人來攻打地球，需要呼叫超級英雄們來幫忙，當然是不管在哪裡呼叫，都能把超級英雄叫來，是最方便的： crisis (); //Superman //Wonder woman //Batman function callSuperMan ()&#123; console.log('Superman'); callwonderWoman(); &#125; function crisis ()&#123; callSuperMan (); callBatMan (); &#125; function callBatMan ()&#123; console.log('Batman') &#125; function callwonderWoman()&#123; console.log('Wonder woman') &#125; 這樣不管函式在前面還是後面都可以叫的到，還可以在函式內呼叫別的函式。 地球的危機就解除了！ 總結 var 宣告的變數只會提升宣告，不會提升賦值，所以提升時，值會是 ‘undefined’。 let 與 const 宣告的變數，如果在宣告前使用，會報出錯誤。 只有「函式宣告」享有「向上提升」的待遇。 函式的提升是整個內容都被提升，可以在宣告之前就呼叫使用。 函式的提升是為了提供函式之間互相呼叫的便利性。 最後，養成好習慣，變數與函式應該先定義好再呼叫，避免誤用「 hoisting 」這項好設計！ 參考資料： MDN 提升(Hoisting)) 我知道你懂 hoisting，可是你了解到多深？ 鐵人賽：JavaScript Function 與 Hoisting [第十七週] JavaScript 進階：從 EC 來理解 Hoisting 【JavaScript 核心】函式提升","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, JS直播班, hoisting","slug":"JavaScript-JS直播班-hoisting","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD-hoisting/"}]},{"title":"何謂物件取值？在什麼時機上會用到？","slug":"objectKeyAndValue","date":"2021-11-10T07:12:50.000Z","updated":"2022-05-01T16:49:38.000Z","comments":true,"path":"2021/11/10/objectKeyAndValue/","link":"","permalink":"https://popeye-ux.github.io/2021/11/10/objectKeyAndValue/","excerpt":"先來談談何謂物件？ 在JavaScript中，所有基本型別( Primitive )以外的變數值，都是物件( Object )。","text":"先來談談何謂物件？ 在JavaScript中，所有基本型別( Primitive )以外的變數值，都是物件( Object )。 物件是 0 到多組屬性的集合。屬性是一對鍵( Key )與值( Value )的關聯，又稱 Key-Value pair。屬性的值可以是基本型別的字串、數字、布林…也可以是陣列、函式甚至是另一個物件。 當然物件也可以是瀏覽器或是執行環境是先定義好的，例如全域物件 window 或是用來取得日期的 Date 物件等等。 那要怎麼建立一個物件呢？ 一般會使用「物件實字」的方式，或是透過 new 關鍵字建立物件。 物件實字( Object literal)所謂的「物件實字」就是使用&#123;&#125;來建立一個新的物件，並指定屬性給物件。屬性之間以逗號( , )隔開，如果屬性名稱( key )有使用到符號字串則必須用 &#39;&#39;( 或是 &quot;&quot; )將 key 包起來。 這也是JSON格式的核心語法。 //使用「物件實字」建立一個郭靖(guoJing)的物件 let guoJing = &#123; name: '郭靖', gender: 'male', kungFu: ['降龍十八掌','空明拳'], useKungFu: function () &#123; alert(`$&#123;this.kungFu[0]&#125;`); &#125; &#125; 看看上面那張圖，鍵與值的配對關係就很清楚了。 在這裡小結一下： key： 就是屬性的名稱，任何字串都可以作為 key， value： 在 value 中可以放入任何型別的值，當然也包括物件。 透過 new 關鍵字建立物件另一種方法則是透過 new 關鍵字建立物件，再把屬性一一指定給物件。範例如下： let guoJing = new Object(); //建立物件 guoJing.name = '郭靖'; //指定屬性 guoJing.gender = 'male'; guoJing.kungFu = ['降龍十八掌','空明拳'], guoJing.useKungFu: function () &#123; alert(`$&#123;this.kungFu[0]&#125;`); &#125; 說到這裡，你應該對物件的結構十分了解了。所謂的「物件取值」，也就是要把物件的「值」給取出來，那要怎麼做呢？可以使用這兩種方法： 使用「.」(點)來存取屬性的值 透過 [ ] (中括號)來存取屬性的值 使用「.」(點)來存取屬性的值透過「.」(點)來存取屬性的值是最單純方便的方式。語法如下： 物件名稱 .屬性名稱 以前面的範例來說明： let guoJing = &#123; name: '郭靖', gender: 'male', kungFu: ['降龍十八掌','空明拳'], useKungFu: function () &#123; alert(`$&#123;this.kungFu[0]&#125;`); &#125; &#125; console.log(guoJing.gender); //'male' guoJing.useKungFu(); // 警告視窗跳出'降龍十八掌' 透過「.」(點)來存取屬性的值雖然方便直觀，但是也有它的限制，例如當物件的屬性名稱是數字或是特殊字元的時候，會出現錯誤，這時另一種存取物件屬性的方法就可以派上用場了。 透過 [ ] (中括號)來存取屬性的值物件的屬性也可以使用 [ ] 來存取， [ ] 裡面可以放字串也可以帶入變數 ，語法如下： 物件[&quot;屬性名稱&quot;] 先來看一下範例： let guoJing = &#123; name: '郭靖', gender: 'male', kungFu: ['降龍十八掌','空明拳'], useKungFu: function () &#123; alert(`$&#123;this.kungFu[0]&#125;`); &#125; &#125; console.log(guoJing['gender']); //'male' guoJing['useKungFu'](); // 警告視窗跳出'降龍十八掌' 乍看之下 [ ] 跟用點 . 沒有兩樣，讓我們改一下題目，把 kungFu 這個陣列拆成 01kungFu 跟 02kungFu 兩個屬性。屬性名稱的開頭使用數字的話，程式會報錯。前面有提到只要是字串都可以當作屬性名稱，所以在這裡把 01kungFu 跟 02kungFu 這兩個屬性名稱加上 &#39;&#39;( &quot;&quot; ) ,讓它們變成字串，這時就不能使用 點( . )來存取屬性了，而要改用可以放入字串的 [ ] 來取值。 let guoJing = &#123; name: '郭靖', gender: 'male', '01kungFu': '降龍十八掌', '02kungFu': '空明拳', useKungFu: function () &#123; alert(`$&#123;this['01kungFu']&#125;`); &#125; &#125;; console.log(guoJing[\"01kungFu\"]);//\"降龍十八掌\" console.log(guoJing[\"02kungFu\"]);//\"空明拳\" 使用 物件 [&quot;屬性名稱&quot;] 的方式就可以正常抓到屬性的值了。 前面提到中括號 [ ] 裡面可以放入變數，所以我們可以把屬性名稱賦值給變數，用 物件 [&quot;變數&quot;] 的方法來取得屬性的值。 讓我們再用上面的例子做一些變化： let guoJing = &#123; name: '郭靖', gender: 'male', '01kungFu': '降龍十八掌', '02kungFu': '空明拳', useKungFu: function () &#123; alert(`$&#123;this['01kungFu']&#125;`); &#125; &#125;; let sex = \"gender\"; console.log(guoJing.sex);//undefined console.log(guoJing.gender);//\"male\" console.log(guoJing[sex]);//\"male\" sex 這個變數雖然存著 “ gender “ 這個值，但是和 guoJing 這個物件並非指向相同的記憶體空間，所以取不到 guoJing.gender 的值，直接報出了 “ undefined “。 而 guoJing[sex] 這裡sex變數存的是”gender”字串，所以 guoJing[sex] 等於 guoJing[&quot;gender&quot;]，所以就成功取到 “ male “ 的值了。 新增物件屬性如何新增物件的屬性呢？可以直接使用( . )也可以用 [ ] 的方式。 物件.屬性名稱 &#x3D; 值; 物件[ &#39;屬性名稱&#39; ] &#x3D; 值; 讓我們看看範例： let guoJing = &#123; name: '郭靖', gender: 'male', '01kungFu': '降龍十八掌', '02kungFu': '空明拳', useKungFu: function () &#123; alert(`$&#123;this['01kungFu']&#125;`); &#125; &#125;; guoJing.wife = '黃蓉'; guoJing['pet'] = '白雕'; guoJing['03kungFu'] = '九陰真經'; console.log(guoJing); 刪除物件屬性要刪除物件的屬性可以使用 delete 指令來刪除。 let guoJing = &#123; name: '郭靖', gender: 'male', '01kungFu': '降龍十八掌', '02kungFu': '空明拳', pet : '白雕', useKungFu: function () &#123; alert(`$&#123;this['01kungFu']&#125;`); &#125; &#125;; delete guoJing.pet; delete guoJing['02kungFu']; console.log(guoJing'); 參考資料： JavaScript - 物件 與 屬性 JavaScript 核心篇 學習筆記: Chap.30 — 物件取值，新增與刪除","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, JS直播班, 物件","slug":"JavaScript-JS直播班-物件","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD-%E7%89%A9%E4%BB%B6/"}]},{"title":"何謂運算式( Expression )與陳述式( Statement )？","slug":"expressionAndStatement","date":"2021-11-05T07:06:33.000Z","updated":"2022-05-01T16:49:44.000Z","comments":true,"path":"2021/11/05/expressionAndStatement/","link":"","permalink":"https://popeye-ux.github.io/2021/11/05/expressionAndStatement/","excerpt":"電腦程式是由一堆命令電腦執行的「指示」所構成。就像人類日常溝通的語言，不同的語言有不同的文法結構；在不同的程式語言，指示電腦執行命令的語法也不相同，程式語言的文法稱為 syntax ，一個程式語言要能運作一定要按照規定的 syntax 來寫。","text":"電腦程式是由一堆命令電腦執行的「指示」所構成。就像人類日常溝通的語言，不同的語言有不同的文法結構；在不同的程式語言，指示電腦執行命令的語法也不相同，程式語言的文法稱為 syntax ，一個程式語言要能運作一定要按照規定的 syntax 來寫。 JavaScript的語法可以分成兩種： 陳述式( Statement ) 表達式( Expression )，也被稱為表示式或運算式。 陳述式MDN 對於陳述式( Statement )的定義： 陳述式與宣告JavaScript 應用程式由適當的陳述式組成。一個單一的陳述式可以跨用好幾行。 多個陳述式也可以藉由分號分隔來寫在同一行。 這不是一個關鍵字，而是一群關鍵字。 這段字每個字都看得懂，但是組在一起卻像是文言文，讓人看好幾次，還是一頭霧水。 讓我吃掉哆啦A夢的翻譯年糕來解釋一下，陳述式就是由一些程式碼所組成的指示，最重要的是陳述式執行後，不會回傳結果。像是變數的宣告．．． 簡單來說，就是陳述式(Statement)所傳的訊息，都被瀏覽器「已讀不回」。 陳述式常見的類型： 宣告(var、let及const) 流程控制：如if…else….、switch …等等 迴圈 函式(function) 區塊(block) 其他 我們繼續用《射鵰英雄歪傳》來模擬陳述式的運作： 有一天歐陽克想要約黃蓉吃飯，古代可能要飛鴿傳書，現代則只要傳 Line，但是結果都是一樣的，鴿子被射下來烤乳鴿，傳 Line 被蓉妹「已讀不回」。 讓我們把上面的對話寫成JavaScript的程式碼，在瀏覽器的console視窗測試一下，看看會有甚麼結果： 以上的那些程式碼都是陳述式(Statement)，都對瀏覽器做了某些指示，但是執行完畢，沒有回傳任何數值。所以上面那張圖裡面說了一大串，但是圖的最下面只跑出了undefined。 不過最後的if(…)那邊有貓膩喔？這點我在運算式的部分再深入解釋。 運算式(Expression)Expression ，中文有人翻譯成表達式、表示式或運算式，MDN 的定義如下： 運算式運算式是任何一段可以取得一個值的程式碼。任何合乎語法的運算式都能取得一個值，概念上， 有兩種不同型態的運算式: 有副作用的 (例如: 將一個值指定給一個變數) 以及只為了取得值而解析的運算式。 上面那段話最重要的地方就是「任何一段可以取得一個值的程式碼」，運算式(Expression)執行後一定會回傳一個值。這也是運算式( Expression )與陳述式( Statement )最大的不同。 在這裡繼續用《射鵰英雄歪傳》來模擬運算式的運作(筆者一定要這樣亂入嗎???)： 運算式就像是郭靖傳Line約黃蓉吃飯一樣，戀情正火熱燒著，就算是吃滷肉飯，黃蓉也會秒回答應！！不會「已讀不回」！ 在這裡也讓我們用console來模擬一下上面那一串對話： 比較需要注意的是if(…)的(…)，需要布林值 true 、 false 來判斷條件會不會成立，所以(…)裡面會放運算式( Expression )，但 if (…){…} 這段程式碼本身是陳述句，不會回傳任何值，也無法將它賦值給變數。 if (condition)&#123; //statement1 &#125; else&#123; statement2 &#125;; 由此可知運算式可能會混在陳述式之中，例如變數宣告本身式陳述式，但是 ＝ 號右側的部分卻屬於運算式。 要注意的是，我們這一段 if (…) 述句，執行之後雖然在 console 視窗下出現結果，不過那不是回傳一個值(存在記憶體中)，而是執行了 console.log() 印出的指令，印在 console 視窗上，這一個小小的坑在我剛學 JavaScript 時困惑了一陣子。 而且該放陳述式的地方是不允許放運算式的，例如 if (…) 的 (…) 裡面如果是陳述式，if述句就不知道該怎麼執行了。所以在一個會產生值的地方，是不能放入陳述式( Statement )。 最後整理一下重點： JavaScript 的語法可以分為兩種，分別是陳述式( Statement )與運算式( Expression )，兩者的區分如下： 陳述式( Statement )會執行一個指令，產生一個動作，但是不會回傳一個「值」。(已讀不回)。 運算式( Expression )會回傳一個值。 陳述式( Statement )中可以放入運算式來進行判斷，但是預期要放入運算式( Expression )的地方，也就是預期會產生一個值的地方，不能放入陳述式。 我是初踏入前端領域的老學徒，如果有寫錯的地方還請大家包涵與指正，謝謝大家！ 參考資料 重讀 Axel 的 Javascript 中的 Expression vs Statement 一文 Day16 函式陳述句與函式表示式 https://www.w3schools.com/js/js_statements.asp JavaScript 表達式觀念及運用 - JS Expression JavaScript 核心篇 學習筆記: Chap.17 — 陳述式與表達式 JS 原力覺醒 Day07 - 陳述式 表達式","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript,JS直播班","slug":"JavaScript-JS直播班","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD/"}]},{"title":"何謂強制轉型、以及如何作到轉換型別？","slug":"typeConversions","date":"2021-10-28T06:57:20.000Z","updated":"2022-05-01T16:49:36.000Z","comments":true,"path":"2021/10/28/typeConversions/","link":"","permalink":"https://popeye-ux.github.io/2021/10/28/typeConversions/","excerpt":"我們都知道JavaScript的基本型別有以下幾種：","text":"我們都知道JavaScript的基本型別有以下幾種： String ：字串，由一連串的字符 (characters) 組成。 Number ：數值，為 floating point number。 Boolean ：true 或 false。 undefined ：表示現在還沒有給值。 null ：不知道之前有沒有值，但是現在沒有值。 Symbol ：ES6 出現的新型別。 JavaScript 的型別不在於變數本身，而在於變數被賦予的值。 如果以上那些你都知道，那你該來看看JavaScript變態的部分—「強制轉型」( coercion )。 斯斯有兩種，「強制轉型」也有兩種： 隱含的強制轉型 — implicit coercion 明確的強制傳型（explicit coercion） 隱含的強制轉型 — implicit coercion剛剛提到 JavaScript 的型別不在於變數本身，而在於變數被賦予的值。 JavaScript 在運算的時候，如果看到兩個不同型別的值，就會自動判斷，把值轉換為相同型別，再做運算。很親切(變態)吧!!?? 不多說，讓我們看一下例子，比較容易進入狀況： let a = \"1\"; //字串 a = a + 2; //'12'， a為字串\"1\"，數字2與字串相加，被轉型為字串\"2\" a = a*2 //24 ， 在乘法的時候，字串\"12\"與2相乘，字串被轉型為數值，得出的結果是數值 12 a = a + true //25， 布林值遇到數值，被轉為數字1，相加後變成25 a = a * null //0 ， null遇到數值被轉為0，數值與0相乘變成0 a = a / undefined //NaN， undefined無法再被轉型為數字 以上這些「我變我變我變變變」的情形就是 JavaScript 變數的「強制轉型」，而且是 JavaScript 親切的、自動的、在背後運作的、「隱含的強制轉型」（ implicit coercion ）。一下變字串，一下有變成數字、一下變成布林值…比孫悟空72變還厲害。 這種「隱含的轉型」（ implicit coercion ）基本上可以轉成三種型別： 自動轉換為布林值( ToBoolean ) 自動轉換為數值( ToNumber ) 自動轉換為字串( ToString ) 四則運算時的強制轉型JavaScript在做四則運算的時候跟小學課本教的一樣，由左而右「先乘除後加減」。 其中以加法（＋）最需要注意！ 如果是數值的運算，那沒有轉型的問題。「字串」的相加也沒有轉型的問題。 var x = 1 + 2; console.log(x); //3 var y = '歐陽鋒是' + '一隻癩哈蟆'; console.log(y); //歐陽鋒是一隻癩哈蟆 只有在不同型別的狀況下才有轉型的問題： 當加號 + 兩側有一個是字串的情形下，會將「非字串」的那一邊「自動轉型」為字串，再將兩個字串連接在一起。如果另一方為 number 、 boolean 、 object 的情況下， number 、 boolean 、 object 會去叫用它們的** .toString 「原型方法」**，把自己變成字串，再去和另一個字串組合。 當一邊是數字，一邊是 undefined 的時候， undefined 會被試著轉為數字，變成 NaN ，任何數字與 NaN 相加都是 NaN 。 當一邊是數字，加號另一邊是 null 的時候， null 會被轉為數字 0 。 //數字與字串相加 77 + '49' //'7749' 77 + '四十九' //'77四十九' //字串與字串相加 '七七' + '四十九' //'七七四十九' 77 + &#123;&#125; //'77[object object]' //當數字要跟undefined相加的時候，udefined會被嘗試轉為數字，也就是NaN，還記得NaN的型別是number嗎？ 77 + unfined //NaN '七七' + unfined //'七七undefined' //當數字要與null相加時，null會被轉成數字 0 ; 77 + null //77 '七七' + null //77null 而如果是減乘除法（ － ＊ ／ ）的情況，除了數值以外的其他基本型別都會透過 Number() 方法轉為數字。物件則在乘除的時候會透過 Number() 方法，轉為數字，在減法時透過 valueOf() 方法轉為數字。 49 - '36' //13 //字串會被轉為數字，也就是NaN 49 - 'abc' //NaN //布林值的true，會被轉行為數字 1 49 - true //48 //布林值的false，會被轉行為數字 0 49 - false //49 49 - undefined //NaN //null會轉為數字0 49 - null //49 49 - &#123;&#125; //NaN 49 * '10' //490 49 * '四十九' //NaN 49 * true // 49 49 * false //0 49 * &#123;&#125; //NaN 下面附上變數在四則運算時的「自動轉型」規則： 四則運算 數字 基本型別非數字 物件 減法 正常運算 Number()方法轉為數字 透過valueOf()轉為數字 乘法 正常運算 Number()方法轉為數字 Number()方法轉為數字 除法 正常運算 Number()方法轉為數字 Number()方法轉為數字 加法 正常運算 如果是number、boolean透過toString()方法轉為字串，null或undefined透過String()轉為字串 toString()轉為字串 比較運算子的強制轉型比較運算子用來比較兩側的數值，比較之後得到布林值 true 或 false。 一個等號 &#x3D;，我們知道是「指定、賦值」的意思。 var x = 49; 在JavaScript中， == 是相等的意思，而 === 是全等的意思。 var x = 49; //數字 var y = '49'; //字串 console.log(x == y); //true，因為 == 在比較兩側的變數是否相等的時候，會自動幫變數轉型。 true == '1'; //true false == '0'; //true true === '1'; //false false === '0'; //false 使用 == 相等的時候，會自動替兩側的變數轉型。 當使用 === 全等的時候，不會替變數自動轉型，是比較嚴謹的模式，也是比較推薦使用的方法。 比較特別的是，NaN不等於NaN，不管是 == 還是 ===，都是一樣 NaN 不等於 NaN 。 &#x3D;&#x3D;的自動轉型規則： 當遇到「字串」與「數字」做比較的時候，字串會透過 Number() 嘗試轉為數字，再進行比較。 如果比較的一方為布林值，則 true 會轉為 1 ， false 會轉為 0 。 當== 的一側為物件型別，另一側為基本型別，物件型別會透過 valueOf() ，轉為對應的基本型別進行比較。 不等於!= 與 !== != 與「! &#x3D;&#x3D;」兩者都是不等於，但是 != 會替變數做自動轉型，而 !== 不會替變數自動轉型，推薦使用 !== 。 大於＞與小於＜的強制轉型我有看到一個數字比大小的有趣例子，借來筆記一下： console.log(1 &lt; 2 &lt; 3); // true console.log(3 &lt; 2 &lt; 1); // true 天哪！怎麼會是這樣的結果！ 3 &lt; 2 &lt; 1 的布林值竟然是 true ．．．天要塌了！ 其實是因為 ＜ 是由左向右( left to right )去做比較，下面來解釋一下： console.log(1 &lt; 2 &lt; 3); 1&lt;2 //true true &lt; 3 //true轉為數字1，1&lt;3，結果為true。 console.log(3 &lt; 2 &lt; 1); 3 &lt; 2 //false false &lt; 1 // false轉為數字0，0&lt;1，所以結果為true 所以才會得出 console.log( 3 &lt; 2 &lt; 1 );會變成 true 的結果。 Boolean的強制傳型邏輯運算子( Logical Operator )有 AND &amp;&amp; 、 OR || 、NOT ! 三種。運算子兩側的值經過 ToBoolean 轉換後會得到一個布林值，再由邏輯運算子比較後傳回其中一個值。 &amp;&amp; 以及 || 進行判斷時，會對左邊的數值進行檢查，如果原本是布林值，就進行後續判斷。如果不是，則透過 ToBoolean 轉換為 true 或 false 。 AND &amp;&amp; ：(條件&#x2F;運算式 A ) &amp;&amp; (條件&#x2F;運算式 B )，如果兩側的值都為 true ，得到 true 的結果；如果其中一方為 false ，則得到 false 。如果第一個值轉換為true，則回傳第二個值，否則回傳第一個值。 OR || ：(條件&#x2F;運算式A) || (條件&#x2F;運算式B)，兩側的值只要有一側為 true ，就得到 true 的結果；如果兩側都為 false ，才得到 false 。如果第一個值轉換為true，則回傳第一個值，否則回傳第二個值。 NOT ! ： true 的結果透過 ! 轉換會得到 false ，而 false 的結果會變成 true。 那些經過ToBoolean轉換後會得到true的狀況太多，而會得到false的值只有以下五種： undefined Null +0、-0 NaN 空字串””或’’ 其他的值都會轉為true。 明確的強制傳型（explicit coercion）也就是透過JavaScript提供的函式來進行變數型別轉換，例如： 轉換為數值型別： Number() 、 parseInt() 、 parseFloat() 轉換為字串型別： toString() 、 String() 轉換為布林型別： Boolean() Number()、parseInt()、parseFloat()Number()可以將值「嘗試轉型」為「數值型別」，但要並非每種物件都可以順利轉成 number 型別，如果轉型失敗就會變成 NaN (非數值的數值)！ parseInt(str [, radix]) 函式能將輸入的字串轉成整數，第二個參數 radix 代表使用哪種進位制轉換。 它會忽略前後空白，在遇到字元被無法解析時，會忽略那個字元與後面的所有字元，停止解析，並回傳目前為止的結果。 如果第一個字元就無法被解析，會回傳 NaN。 parseFloat(str)能將字串轉換為以十進位表示的浮點數。 來看一下範例： Number('123'); //123 Number('華山論劍'); //NaN Number('9陰真經'); //NaN Number(null); //0 Number(true) //1 Number([]); //0 Number([1]); //1 Number([1,2,3]); //NaN Number(&#123;&#125;); //NaN parseInt('9陰真經'); //9 parseInt('九陰真經'); //NaN parseInt(101010,2); //42 parseFloat('3.1416') //3.1416 .toString()、String()String() 與 .toString() 都可以將值轉換為字串型別，差別在於 .toString() 在收到 null 、 undefined 和數字時會報錯。 String(123) //'123' String(null) //'null' String('undefined') //'undefined' String(true) //'true' true.toString() //'true' 123.toString() //Uncaught SyntaxError: Invalid or unexpected token null.toString() //Uncaught TypeError: Cannot read properties of null (reading 'toString') undefined.toString() //Uncaught TypeError: Cannot read properties of undefined (reading 'toString') Boolean()Boolean() 可以用來將其他的資料型態轉型成布林值型態。還記得前面提過幾種會變成 false 的值嗎? Boolean(100) //true Boolean('100') //true Boolean('') //false Boolean(false) //false Boolean(undefined) //false Boolean(null) //false Boolean('\"\"') //true Boolean('false') //true 本來以為這個題目很好寫…..結果寫得一點都不輕鬆，也找不到方法寫得很有趣。幾乎每個知識點都有再深入研究的餘地，就像《浪人劍客》裡面老人對宮本武藏說的：「技是無限的，卻有鑽研的餘地！」 重點整理一下，如果可以掌握一些概念，之後還可以再仔細琢磨： 強制轉型分為兩種： 隱含的強制轉型：就是 JavaScript 在運算的過程中，依照它的規則在背地裡把值的型別轉換成其他類的型別。 四則運算中加法如果遇到「字串」的轉型最需要留意，其他的減乘除都會試圖轉換成數字來處理。 使用「＝＝＝」相等的時候，會自動替兩側的變數轉型。當使用「＝＝＝」全等的時候，不會替變數自動轉型，建議使用「＝＝＝」來進行比較。 在布林值的轉型部分，請記得： undefined 、 Null 、 +0 、 -0 、 NaN 、空字串都會轉換成 false。 明顯的強制轉型：透過 JavaScript 提供的函式來進行變數型別轉換。 轉換為數值型別： Number() 、 parseInt() 、 parseFloat() 轉換為字串型別： toString() 、 String() 轉換為布林型別： Boolean() 我是初踏入前端領域的老學徒，如果有寫錯的地方還請大家包涵與指正，謝謝大家！ 參考資料 你懂 JavaScript 嗎？#8 強制轉型（Coercion） JavaScript 全攻略：克服 JS 的奇怪部分 Javascript型別轉換的技巧 JavaScript資料型別轉換 https://jimmywei01.github.io/2019/05/28/JS-紀錄2-包裹物件、自動轉型/ 認識 parseInt、parseFloat 與 Number 轉換成數字的三種方法 前端工程研究：關於 JavaScript 中 Number 型別的常見地雷與建議作法 淺談JS中String()與 .toString()的區別","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, JS直播班","slug":"JavaScript-JS直播班","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD/"}]},{"title":"if else 與 switch 的使用時機","slug":"ifElseAndSwitch","date":"2021-10-27T06:44:54.000Z","updated":"2022-05-01T16:49:42.000Z","comments":true,"path":"2021/10/27/ifElseAndSwitch/","link":"","permalink":"https://popeye-ux.github.io/2021/10/27/ifElseAndSwitch/","excerpt":"日常生活中充滿了各式各樣的邏輯判斷：「如果」怎樣，就去做某件事，「否則」就去做另外一件事。 「如果降雨機率超過30%，就帶傘！」每天早上出門要做的判斷。 「如果肚子餓了，就吃香蕉！」這是猴子也會的事情！","text":"日常生活中充滿了各式各樣的邏輯判斷：「如果」怎樣，就去做某件事，「否則」就去做另外一件事。 「如果降雨機率超過30%，就帶傘！」每天早上出門要做的判斷。 「如果肚子餓了，就吃香蕉！」這是猴子也會的事情！ 而上帝也教你怎麼做判斷，古早的聖經就說了： 「如果有人打你的右臉，連左臉也轉過來由他打！」我的臉好腫呀！ if…else「如果 A 條件成立，就做甲這件事！否則就做乙這件事！」這句話，其實是一個條件式，可以轉換為布林值來判斷： 「如果A條件成立」就是 A 條件為true的情況。 「否則…」就是 A 條件為 false 的情況。 寫成JavaScript就會是這樣子： if (條件式)&#123; //條件成立(true)的話，執行&#123; 甲 &#125;區塊內的內容 &#125; else &#123; //如果條件不成立(false)，執行&#123; 乙 &#125;區塊中的內容 &#125; 如果條件不只一個，可以使用 else…if 來新增條件。 if (條件式 1)&#123; //條件1成立(true)的話，執行&#123; 甲 &#125;區塊內的內容 &#125; else if (條件式 2)&#123; //條件2成立(true)的話，執行&#123; 乙 &#125;區塊內的內容 &#125; else if (條件式 3)&#123; //條件3成立(true)的話，執行&#123; 丙 &#125;區塊內的內容 &#125; else &#123; //如果上面的條件都不成立(false)，執行&#123; 丁 &#125;區塊中的內容 &#125; 補充一點， if 跟 else 在一個邏輯判斷流程中只能使用一次，但是 else if 卻可以使用很多次。 讓我們繼續請郭靖….他爹來示範「if….else….」的用法： 話說郭靖他爹郭嘯天與楊康他爹楊鐵心在妻子懷孕的時候就約定，如果孩子生出來都是男生，就結拜為兄弟；如果是一男一女就結為夫妻。 //guoChildSex代表郭家的孩子，yangChildSex代表楊家的孩子，因為孩子未出生，還不知性別。 let guoChildSex = 'male'; let yangChildSex = 'female'; if ( guoChildSex === yangChildSex )&#123; console.log('郭家孩子與楊家孩子結拜為金蘭'); &#125;else &#123; console.log('郭家孩子與楊家孩子結為夫妻'); &#125; //考慮到多元成家的話，邏輯會更複雜，這個....我們就先停在這裡 這是一個簡單的雙向分歧決策，但是如果是更複雜的情況呢？我們看看下個例子： 話說在《射鵰英雄傳》中，長春子丘處機在嘉興酒樓和江南七怪比賽喝酒這一段十分精彩。但是七怪有七個人，到底要派誰出去呢？猜拳嗎？ 讓我們請 JavaScript 來幫我們決定人選吧！ 我想隨機選出 1 到 7 之間的數字，從七個人中選出一個來跟丘處機鬥酒，例如數字等於1就印出「飛天蝙蝠–柯鎮惡出來喝酒」，數字等於2就印出「妙手書生–朱聰出來喝酒」，依此類推。 Math.random() 會隨機產生 0 到 1 之間的小數。 而 Math.ceil(x) 會將x無條件進位。 //Math.random() 會隨機產生 0 到 1 之間的小數。 而 Math.ceil(x) 會將x無條件進位。 let drinkWineOrder = Math.ceil(Math.random()*7); if(drinkWineOrder===1)&#123; console.log('飛天蝙蝠--柯鎮惡出來喝酒'); &#125; else if (drinkWineOrder===2)&#123; console.log('妙手書生--朱聰出來喝酒'); &#125; else if (drinkWineOrder===3)&#123; console.log('馬王神--韓寶駒出來喝酒'); &#125; else if (drinkWineOrder===4)&#123; console.log('南山樵子--南希仁出來喝酒'); &#125; else if (drinkWineOrder===5)&#123; console.log('笑彌陀--張阿生出來喝酒'); &#125; else if (drinkWineOrder===6)&#123; console.log('鬧市俠隱--全金發出來喝酒'); &#125; else&#123; console.log('越女劍--韓小瑩出來喝酒'); &#125; 寫了這麼落落長的一段，看得眼都花了，if … else … 跑了7次小括號裡面的條件，也判斷了 7 次，這種邏輯判斷稱之為「多向分歧決策」。 switchJavaScript 還有另一種的 switch 條件判斷式，比較適合這樣的情況，它的寫法是這樣的： switch (expression) &#123; case value1: //當 expression 的值符合 value1 //要執行的陳述句 [break;] case value2: //當 expression 的值符合 value2 //要執行的陳述句 [break;] ... case valueN: //當 expression 的值符合 valueN //要執行的陳述句 [break;] [default: //當 expression 的值都不符合上述條件 //要執行的陳述句 [break;]] &#125; switch 括號中可以放入「運算式」( switch 語句會先執行指定的 expression ，得到一個值)、「變數」或「值」，然後一一去和 case 後面的值比對，如果兩者相吻合，就得出一個 true 的值，然後執行 true 那個 case 區塊的程式敘述。如果每個 case 都不符合則執行 default 區塊的程式敘述。 當滿足 case 列出來的條件，執行完程式敘述之後，break 指令會中止流程判斷，不去執行後面的 case 條件判斷。 switch(Math.ceil(Math.random()*7))&#123; case 1: console.log('飛天蝙蝠--柯鎮惡出來喝酒'); break; case 2: console.log('妙手書生--朱聰出來喝酒'); break; case 3: console.log('馬王神--韓寶駒出來喝酒'); break; case 4: console.log('南山樵子--南希仁出來喝酒'); break; case 5: console.log('笑彌陀--張阿生出來喝酒'); break; case 6: console.log('鬧市俠隱--全金發出來喝酒'); break; case 7: console.log('越女劍--韓小瑩出來喝酒');; break; default: console.log('七個人都喝醉了，認輸！！'); break; &#125; 使用 switch 之後，程式碼沒有夾雜一堆()與{}，看起來簡潔、清楚多了。 if…else 與 switch的差別前面簡單介紹了 if…else 與 switch 的語法，現在來看看兩者的差異。 「範圍取值」適合使用if…else，「確定取值」則使用switch如果是「範圍取值」，也就是判斷的示範為區間，適合使用 if… else 語句。 如果是「確定取值」，也就是判斷的結果有明確的值，則使用 switch 是一個不錯的選擇。 讓我們看看下面的這個範例： 郭靖為了與黃蓉約會參加桃花島主黃藥師的考試，依考試成績的範圍，有不一樣的獎賞。 如果用 if….else if 要這樣寫： //郭靖參加桃花島的黃藥師的考試，考試成績超過85分可以娶黃蓉，不及格就去白陀山養癩蛤蟆 let guoScore = 87; if(guoScore >= 85)&#123; console.log('郭靖可以得到跟黃蓉約會的資格'); &#125;else if(guoScore &lt; 85 &amp;&amp; guoScore >= 70)&#123; console.log('郭靖可以學得黃藥師的一樣功夫'); &#125;else if(guoScore &lt; 70 &amp;&amp; guoScore >= 60)&#123; console.log('郭靖可以桃花島一日遊'); &#125;else&#123; console.log('郭靖考試不及格，去白駝山養養癩蛤蟆'); &#125; //郭靖可以得到跟黃蓉約會的資格 使用 switch 的寫法，如果原樣照搬 if…else 的寫法的話，會變成這樣： let guoScore =87; switch(guoScore)&#123; case (guoScore >= 85): //87 !== true console.log('郭靖可以得到跟黃蓉約會的資格'); break; case (guoScore &lt; 85 &amp;&amp; guoScore >= 70); //87 !== false console.log('郭靖可以學得黃藥師的一樣功夫') break; case (guoScore &lt; 70 &amp;&amp; guoScore >= 60): //87 !== false console.log('郭靖可以桃花島一日遊'); break; default: console.log('郭靖考試不及格，去白駝山養癩蛤蟆'); break; &#125; //郭靖考試不及格，去白陀山養養癩蛤蟆 //switch()小括號帶入的是變數guoScore，會判斷為全部條件都不吻合，直接去執行default區塊。 什麼！明明郭靖考了87分，怎麼還要去白陀山養癩蛤蟆！！！這一定有黑幕！！！ 等等！別急著打我！讓我來解說一下！ 先記得這件事： switch() 括號中的條件跟 case 後面的值比較的結果必須為 true ，才會去執行case 後面的程式碼區塊。 因為每個 case 括號裡的 guoScore 是去跟外面的 let guoScore &#x3D; 87 比較，比較的結果不是 true 就是 false，其中只有「 case (guoScore &gt;&#x3D; 85) 」為 true ，其他的範圍區間都是false。 而 switch() 小括號所帶入變數 guoScore 的值為 87 ，去跟每個 case 的布林值比對， 87 不等於true，也不等於false，當然找不到符合的條件，所以就直接去執行所有條件都不成立的 default 區塊。 如果要讓這個 switch 區塊能夠執行，就要這樣寫： let guoScore = 87; switch(true)&#123; case (guoScore >= 85): //true == true console.log('郭靖可以得到跟黃蓉約會的資格'); break; case (guoScore &lt; 85 &amp;&amp; guoScore >= 70): //true !== false console.log('郭靖可以學得黃藥師的一樣功夫') break; case (guoScore &lt; 70 &amp;&amp; guoScore >= 60): //true !== false console.log('郭靖可以桃花島一日遊'); break; default: console.log('郭靖考試不及格，去白駝山養癩蛤蟆'); break; &#125; //'郭靖可以得到跟黃蓉約會的資格' 由上面可以看出 switch() 的小括號裡帶入的就不是郭靖的分數 guoScore 了，而是布林值 true ，這時去和 case 後面的布林值比對，才會在「 case (guoScore &lt; 80 &amp;&amp; guoScore &gt;&#x3D; 60) 」得到 true &#x3D;&#x3D;&#x3D; true 相等的結果，進而得到「’郭靖可以得到跟黃蓉約會的資格’」的結果。 這種情況之下，使用 switch 就不如 if…else if… 直觀了。 所以在這裡我們得到的重點是： 「 if…else if … 」適合使用在不同的條件區間的判斷，如果都沒符合條件，則執行「 else 」的程式碼。 而「switch」適合使用在有明確的「值」的情況下。 switch 是用嚴謹模式( &#x3D;&#x3D;&#x3D; )在比對 case 後面的數值最後讓我們用情境題來解釋一下這個情形： 黃藥師對於郭靖考到 87 分非常不爽，於是拿出了三個信封，上面分別寫了”1”、”2”、”3”，要郭靖從裡面挑一個。 讓我們看一下 if…else if 怎麼寫： let guoPick = \"3\"; if(guoPick == 1)&#123; console.log('到東海餵鯊魚！'); &#125;else if (guoPick == 2)&#123; console.log('到南海騎烏龜'); &#125;else if(guoPick == 3)&#123; console.log('在桃花島當島主') &#125;else&#123; console.log('去白駝山養癩蛤蟆') &#125; //在桃花島當島主 運氣好！你打我呀！挑到”3”，可以’在桃花島當島主’。 讓我們看看用 switch 來判斷，會發生甚麼悲劇… let guoPick = \"3\"; switch(guoPick)&#123; case 1: console.log('到東海餵鯊魚！'); break; case 2: console.log('到南海騎烏龜'); break; case 3: console.log('在桃花島當島主'); break; default: console.log('去白駝山養癩蛤蟆'); &#125; //去白陀山養癩蛤蟆 蛤！為甚麼挑到”3”，還要’去白駝山養癩蛤蟆’！ 郭靖的拳頭又硬了！ 這是因為switch判斷式是使用嚴格模式，遇到 ‘3’ 這種狀況，會把它當字串處理，所以才會所有 case 條件都不符合，直接去執行 default 區塊。 講了那麼多，前面說的忘記了沒關係，讓我們重點整理一下， switch 與 if…else 的差別與使用時機： if…else 適合「單向決策」與「雙向分歧決策」； switch 適合「多向分歧決策」。 「範圍取值」適合使用 if…else ；「確定取值」則適合使用 switch 。 switch 是用嚴謹模式( &#x3D;&#x3D;&#x3D; )在比對 case 後面的數值 我不是老司機，而是初踏入前端領域的老學徒，如果有寫錯的地方還請大家包涵與指正，謝謝大家！ 參考資料 JavaScript 基礎知識-switch &amp; if else 的判別差異 JavaScript switch case JavaScript switch 語法 Javascript 中 switch 的彈性用法 JavaScript 的 if 跟 switch 效能 switch - 程式碼教學 流程控制 if&#x2F;else 條件判斷 switch…case &amp;&amp; if…else效率比較和優化","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, JS直播班","slug":"JavaScript-JS直播班","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD/"}]},{"title":"null 與 undefined 的差別","slug":"nullUndefined","date":"2021-10-23T02:34:52.000Z","updated":"2022-05-01T16:49:40.000Z","comments":true,"path":"2021/10/23/nullUndefined/","link":"","permalink":"https://popeye-ux.github.io/2021/10/23/nullUndefined/","excerpt":"undefined是基本型別之一，指的是「變數目前還沒有給值」，如果宣告一個變數，卻沒有初始化(沒有給值)，那變數的值就預設為undefined。","text":"undefined是基本型別之一，指的是「變數目前還沒有給值」，如果宣告一個變數，卻沒有初始化(沒有給值)，那變數的值就預設為undefined。 let a; console.log(a)//undefined Number(undefined); //NaN console.log(1+undefined); //NaN typeof(undefined); //'undefined' Boolean(undefined);//false，在求布林值時會轉成false null也是基本型別之一，指的是「不管前500年，還是後500年有沒有值，總之現在沒有值」。 在指定DOM元素時，如果那個DOM元素不存在，也會回傳null。 let b = null; console.log(b);//null Number(null) //0 console.log(1+null); //0,1 + 0 =1 typeof(null) //'object' Boolean(null) //false，在求布林值時會轉成false 但是要注意的是： null == undefined; //true，因為在JS中用布林去查詢null跟undefined都是falsy null === undefined; //false 最後的重點整理： undefined和null相似處: 都没有屬性和方法，也不能額外添加屬性方法 皆為Falsy Value(Boolean判斷時為false) 皆為原始型別(Primitive Type) undefined和null相異之處： typeof null 會回傳 object ; typeof undefined 會回傳 undefined。 當要取用一個物件的屬性或陣列的元素時，若該屬性&#x2F;元素不存在，回傳undefined。或原本一個函數需要傳入參數，但是調用函數時卻沒有傳入參數，則回傳值將會是undefined。 在做DOM元素操作時，若要獲取的DOM元素不存在，則會回傳null。 參考資料 undefined 和 null 的差別 Javascript中undefined和null的差異","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, JS直播班","slug":"JavaScript-JS直播班","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD/"}]},{"title":"by reference (傳參考)、by value(傳值)的差別","slug":"byReferenceByValue","date":"2021-10-15T15:35:46.000Z","updated":"2022-05-01T16:49:46.000Z","comments":true,"path":"2021/10/15/byReferenceByValue/","link":"","permalink":"https://popeye-ux.github.io/2021/10/15/byReferenceByValue/","excerpt":"在參加鐵人賽的時候，因為這個題目了解的朦朦朧朧、似懂非懂，所以不敢寫這個題目。直到JS直播班聽了老師的解說，才一秒突破盲腸，恍然大悟。","text":"在參加鐵人賽的時候，因為這個題目了解的朦朦朧朧、似懂非懂，所以不敢寫這個題目。直到JS直播班聽了老師的解說，才一秒突破盲腸，恍然大悟。 談這個題目之前，先來做一下六角學院JS直播班第一週的周末作業《記憶體接龍》，以了解變數與記憶體儲存位置的關係，這樣對於by reference (傳參考)、by value(傳值)會有更深入的了解。 第 1 題// 1. console.log 的值為？ // 2.出現幾個變數、型別、記憶體空間? let a ; a = 1; a = \"hello\"; console.log(a) //答案1：console.log 的值為 hello //答案2：1個變數a；3個型別(undefined、number、string)；3個記憶體空間 記憶體空間畫圖來表示： 備註： let a ;的值為 “ undefined “ ，也會佔記憶體空間。所以答案2應該是： 1 個變數， 3 個型別， 3 個記憶體空間 助教的回答：let a因為並沒有宣告a的值，所以a會有一個undefined 的值，並且佔了一個記憶體空間，所以這題答案應該是1個變數， 3 個型別（數字、字串、 undefined ）， 3 個記憶體空間。 第 2 題// 1. console.log 值為？ // 2.出現幾個變數、型別、記憶體空間? let b = 3 ; b=5; let c = 4; b=8; c=c+b; let d = b+c; console.log(e) //答案1：console.log 的值為「Uncaught ReferenceError: e is not defined」 //答案2：3個變數；1個型別(number)；6個記憶體空間 記憶體空間畫圖來表示： 第 3 題// 1. console.log 值為？ // 2. 出現幾個變數、型別、記憶體空間? let e=0; e = 5; e = \"hello\" e = true; e = 3; e+=1; console.log(e) //答案 1：console.log 的值為 4 //答案 2： 1 個變數； 3 個型別(number、string、boolean)； 7 個記憶體空間 記憶體空間畫圖來表示： 我們由上面的作業可以發現，不同的變數指向不同的記憶體位置，只要變數重新賦值之後，就會把新的值存到新的記憶體空間之中，舊的值就從記憶體上面清空，而運算過程中的值也會佔到記憶體的空間。 這就是JS變數與記憶體之間運作的過程。 還有一個觀念要先記一下， JS 的變數本身沒有型別，它被賦予的值才有。 理解了這些才能進一步來談 by reference (傳參考)、 by value (傳值)的差別。 by value(傳值)讓我們繼續來《射鵰英雄歪傳》，郭靖跟黃蓉小倆口結婚後，在大漠開起了寵物店，專門賣汗血寶馬和神雕，因為都是珍稀之物，所以定價都是1000兩黃金。 // 設一個汗血寶馬(horsePrice)的變數，給它1000的值 let horsePrice = 1000; //設一個神雕(eaglePrice)的變數，也給它1000的值 let eaglePrice = 1000; console.log(horsePrice === eaglePrice); //true 我們可以觀察到，在基本型別的時候，不同的變數指向不同的記憶體位置，兩個變數賦予的值一樣，也就是記憶體儲存的值一樣，兩個變數就相等。所以我們可以歸納出，基本型別變數的比較，我們看的是它被賦予的值，值相等，兩個變數就相等。 繼續來《射鵰英雄歪傳》，有一天楊康來寵物店想買一隻汗血馬，問郭靖多少錢？因為楊康之前買過神雕，郭靖隨口就說：「汗血馬跟神雕一樣的價格！」 楊康心想：「老子最近沒錢！」就說：「兄弟！這馬也太貴了！」郭靖說：「蓉妹說不二價，兄弟！聽某嘴大富貴！」於是楊康只好忍痛去跟大漠的高利貸歐陽克借錢買了一匹汗血馬。 結果過幾天，成吉斯汗打敗大宛國，擄獲許多汗血寶馬，造成大漠上汗血寶馬的價格大跌價，一匹馬變成300兩黃金。 我們就用 JavaScript 來說說這件事： //設一個神雕(eaglePrice)的變數，也給它1000的值 let eaglePrice = 1000; //郭靖跟楊康說：汗血馬和神雕的價格是一樣的 let horsePrice = eaglePrice; console.log(eaglePrice); //1000 console.log(horsePrice); //1000 console.log(eaglePrice === horsePrice); //true //結果成吉思汗擄獲許多汗血馬，造成汗血馬價格大崩壞 horsePrice = 300; console.log(eaglePrice); //1000 console.log(horsePrice); //300 console.log(horsePrice === eaglePrice); //false //true 楊康哭哭！汗血馬的價格不是跟神雕一樣嗎？ 讓我們用前面畫圖的練習來理解一下JavaScript發生了甚麼事！ //設一個神雕(eaglePrice)的變數，也給它1000的值 let eaglePrice = 1000; //郭靖跟楊康說：汗血馬和神雕的價格是一樣的 let horsePrice = eaglePrice; console.log(eaglePrice === horsePrice); //true 宣告一個eaglePrice變數，給它1000的值 宣告一個horsePrice變數，給它的值是變數eaglePrice。 這時發生的事情就是，horsePrice 去拷貝了 eaglePrice 的值 1000 到自己目前占用的記憶體空間。前面有提到「基本型別變數的比較，我們看的是它被賦予的值，值相等，兩個變數就相等」。 let horsePrice &#x3D; eaglePrice;這時候eaglePrice &#x3D;&#x3D;&#x3D; horsePrice的布林值為true。 //horsePrice重新賦值為300 horsePrice = 300; console.log(horsePrice === eaglePrice); //false horsePrice重新賦值為300這個行為指的是，horsePrice去佔用了新的記憶體空間儲存了新的值300，這時horsePrice &#x3D;&#x3D;&#x3D; eaglePrice的布林值就是false。 汗血馬的價格horsePrice與神雕的價格eaglePrice是各自獨立的，當值相等時，兩個變數才相等，汗血馬價格崩盤的時候，神雕的價格依然不受影響。 所以我們可以說「基本型別」變數之間的比較，看的是它被賦予的值相不相等，這種現象被稱為「by value(傳值)」。 by reference (傳參考)但是在「物件型別」的比較上，是另外一種情形。 繼續來《射鵰英雄歪傳》，郭靖的寵物店因為生意太好，所以開了分店，分店裡面汗血馬的價格跟總店是一樣的。 //mainStore物件儲存總店汗血馬的價格 let mainStore = &#123;horsePrice: 1000&#125;; let branchStore = mainStore; console.log(mainStore.horsePrice); //1000 console.log(branchStore.horsePrice);//1000 branchStore.horsePrice = 300; console.log(mainStore.horsePrice); //300 console.log(branchStore.horsePrice);//300 console.log(mainStore === branchStore); //true 我們發現當分店汗血馬的價格branchStore.horsePrice被重新賦值為300時，總店的汗血馬的價格也跟著變為300。 而console.log(mainStore &#x3D;&#x3D;&#x3D; branchStore)的結果為true，我們可已發現mainStore與branchStore指向的是同一個實體。 我們來看看宣告物件型別變數時，記憶體是如何運作的。 當我們let mainStore &#x3D; {horsePrice: 1000};其實是把mainStore的參考位置指向記憶體中存放物件的位置。 所以當我們let branchStore &#x3D; mainStore;也是把branchStore變數參考的位置指向mainStore所參考的變數位置，所以當物件horsePrice屬性的值改變的時候，mainStore跟branchStore的值都會跟著變動。 物件型別是透過「引用」的方式在傳遞資料，物件型別的物件的屬性值其實引用的是記憶體儲存資料的參考， 所以我們會說在物件型別的比較是by reference(傳參考)，看這兩個物件是否指向相同的記憶體空間，參考相同的值。 凡事都有例外，物件的例外讓人特別困惑。 繼續來《射鵰英雄歪傳》，郭靖寵物店生意很好，所以黃蓉也開了一家分店，有一天夫妻倆吵架，黃蓉一氣之下脫離加盟體系，開始削價競爭。 //husbandStore物件儲存郭靖寵物店汗血馬的價格 let husbandStore = &#123;horsePrice: 1000&#125;; //把husbandStore的值指定給wifeStor let wifeStore = husbandStore; //wifeStore物件重新賦值 wifeStore = &#123;horsePrice: 500&#125;; console.log(husbandStore.horsePrice); //1000 console.log(wifeStore.horsePrice);//1000 wifeStore.horsePrice = 300; console.log(husbandStore.horsePrice); //1000 console.log(wifeStore.horsePrice);//300 console.log(husbandStore === wifeStore); //false 在這種情形之下，husbandStore與wifeStore原本是引用相同的參考位置，但是wifeStore重新賦值之後，則引用新的參考位置，所以汗血馬價格變動的時候，husbandStore與wifeStore兩者不會連動，因為兩者參考的是不同的物件實體。 許國政先生認為這種物件型別的比較應該更像是「by sharing」，這有點玄！ 且讓我們引用他在《0 陷阱！0 誤解！8 天重新認識JavaScript！》的一段話作為總結： 「由於JavaScript的物件類型是可變的(mutable)，當物件更新時，會影響到所有引用這個物件的變數與副本，修改時會變動到原本的參考。但當賦與新值時，卻會產生新的實體參考。」 參考資料 談談 JavaScript 中 by reference 和 by value 的重要觀念 重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？ 傳值跟傳參考概念","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript,JS直播班","slug":"JavaScript-JS直播班","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD/"}]},{"title":"var、let、const 的差異","slug":"jsLive-varLetConst","date":"2021-10-09T15:25:52.000Z","updated":"2022-05-01T16:49:42.000Z","comments":true,"path":"2021/10/09/jsLive-varLetConst/","link":"","permalink":"https://popeye-ux.github.io/2021/10/09/jsLive-varLetConst/","excerpt":"以下為我今年參加iT邦幫忙鐵人賽寫的文章，原文連結： 【Day2】變數宣告var、let、const的區別 但是老師教我用 var 宣告變數，但我也看到有同學用 let 與 const 宣告變數，這是怎麼一回事呢？","text":"以下為我今年參加iT邦幫忙鐵人賽寫的文章，原文連結： 【Day2】變數宣告var、let、const的區別 但是老師教我用 var 宣告變數，但我也看到有同學用 let 與 const 宣告變數，這是怎麼一回事呢？ //建立一個變數郭靖(guoJing) var guoJing; 也可以看到這樣： //建立一個建立一個名為黃蓉(huangRong)的變數，給她'打狗棒法'的值 let huangRongKungFu = '打狗棒法'; //建立一個洪七公(hongQigong)的常數，給他「北丐」的值 const hongQigong = '北丐'; var 、 let 、 const 這三兄弟到底有甚麼差別呢？ 原來除了用var宣告變數之外，在ES6之後，變數區分為變數與常數，透過 var 與 let 宣告「變數」，透過const宣告「常數」。 var 和 let 最大的區別在於「作用域」不同，這一點我們先放在心上，之後再深入探討。 在這裡補上let與var作用域的區別： var 是以function為作用域。 let 則是以大括號{}區塊的程式碼為作用的範圍。 作用域外層的程式捉不到作用域內的宣告的變數，但是作用域內的程式可以捉到外層的變數。 先來看看var： //建立一個變數郭靖(guoJing) var guoJingKungFu; console.log(guoJingKungFu); //未賦值，所以出現的結果為 undefined guoJingKungFu = '降龍十八掌'; console.log('郭靖使出 ' + guoJingKungFu); //結果為\"郭靖使出 降龍十八掌\" guoJingKungFu = '空明拳'; console.log('郭靖使出 ' + guoJingKungFu); //結果為\"郭靖使出 空明拳\" var guoJingKungFu = '九陰真經'; //再次用var宣告 guoJing = '九陰真經'; console.log('郭靖使出 ' + guoJingKungFu); //結果為\"郭靖使出 九陰真經\" 使用var的時候，同一個變數名稱可以再重新「宣告」，重新賦值。 再看看使用 let 的狀況： //建立一個建立一個名為黃蓉(huangRong)的變數，給她'打狗棒法'的值 let huangRongKungFu; huangRongKungFu = '打狗棒法'; console.log('黃蓉使出 ' + huangRongKungFu); //結果為\"黃蓉使出 打狗棒法\" huangRongKungFu = '落英神劍掌'; console.log('黃蓉使出 ' + huangRongKungFu); //結果為\"黃蓉使出 落英神劍掌\" let huangRongKungFu = '蘭花拂穴手'; //Uncaught SyntaxError: Identifier 'huangRong' has already been declared 使用 let 比使用 var 來宣告變數嚴謹，如果宣告時未賦值，並不會以undefined初始化，所以從宣告到初始化這段時間會無法使用，這個時間差稱為「暫時死區」。 let 能重複賦值，禁止於同個區塊作用域重複宣告，如果重複宣告會出現： 「Uncaught SyntaxError: Identifier ‘huangRong’ has already been declared」 提醒你已經用 let 宣告過這個變數了。 讓我們來試試 const： //建立一個洪七公(hongQigong)的常數，給他「北丐」的值 const hongQigong = '北丐'; console.log('洪七公是 ' + hongQigong); hongQigong = '美食家'; //Uncaught TypeError: Assignment to constant variable. const hongQigong = '美食家'; //Uncaught SyntaxError: Identifier 'hongQigong' has already been declared const 是用來宣告常數，也就是不會變動的常量，所以禁止於同個區塊作用域重複宣告，也不能重新賦值。而且宣告時一定要給值。 重複宣告會告訴你： 「Uncaught SyntaxError: Identifier ‘hongQigong’ has already been declared」 重複賦值則會提醒你： 「Uncaught TypeError: Assignment to constant(持續的) variable.」 因為以上這些區別，使用 var 、 let 、 const 來宣告變數的時機與場景有不同的區別，語意上也有明確區分。而沒有經過 var 、 let 與 const 宣告就直接賦值使用的變數會變成全域變數。 const 有一個例外，就是在宣告物件時，因為物件是 call by reference ，變數參考的是物件存放的位置，當修改物件屬性的時候，不會改變物件參考的記憶體位置，所以用 const 宣告物件時，其屬性是可以修改的，但是重新賦值則是禁止的。 參考資料 JavaScript: var, let, const 差異 在 JavaScript 中，Var、Let、Const 的差異？ 搞懂變數作用域(2)- let 與const","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript,JS直播班","slug":"JavaScript-JS直播班","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD/"}]},{"title":"Day35:最終章：Todo List實作","slug":"21-day35-toDoList","date":"2021-10-05T01:43:17.000Z","updated":"2022-04-18T10:44:46.000Z","comments":true,"path":"2021/10/05/21-day35-toDoList/","link":"","permalink":"https://popeye-ux.github.io/2021/10/05/21-day35-toDoList/","excerpt":"前面提到了物件、陣列、DOM元素的選取、事件監聽，以及最後的localStorage。這些足夠我們用JavaScript做一個小小的網頁程式，來驗證一下之前提到的方法。","text":"前面提到了物件、陣列、DOM元素的選取、事件監聽，以及最後的localStorage。這些足夠我們用JavaScript做一個小小的網頁程式，來驗證一下之前提到的方法。 這次我們要來做的是Todo List。 假設金庸先生要邀請武林高手來參加華山論劍，要邀請的人太多了，他記性不好，所以寫了一個小程式來記錄與會者名單。大概是長這個樣子。 然後在來拆解畫面上的功能： 我們可已先把上面的的那張圖區分為三種程式區塊： 事件： 加入邀請名單：點擊，使用者輸入的資料加入「邀請名單」的localStorage，並渲染到畫面 寄出：將資料從「邀請名單」的localStorage中移除，加入已寄出名單的localStorage，並渲染到畫面 移除：將資料由「已寄出名單」的localStorage中移除，並渲染到畫面 資料： 邀請名單的localStorage資料 寄出名單的localStorage資料 畫面：將localStorage的資料渲染到網頁 所以我們就可以開始實作了！ 畫面上的HTML碼如下： &lt;div class=\"content\"> &lt;div class=\"logo\"> &lt;img src=\"https://imgur.com/uEvCO7p.png\" width=\"150px\" alt=\"\"> &lt;div class=\"logotext\">TODO LIST&lt;/div> &lt;/div> &lt;div class=\"addList\"> &lt;input type=\"text\" size=\"30\" class=\"text\" placeholder=\"請輸入與會者姓名\" required> &lt;button type=\"button\" class=\"send\">新增邀請名單&lt;/button> &lt;/div> &lt;/div> &lt;div class=\"item\"> &lt;h3>計畫邀請&lt;span class=\"noneNum\">&lt;/span>人&lt;/h3> &lt;ul class=\"list\"> &lt;/ul> &lt;/div> &lt;div class=\"finishedItem\"> &lt;h3>已邀請&lt;span class=\"doneNum\">&lt;/span>人&lt;/h3> &lt;ul id=\"finishlist\"> &lt;/ul> &lt;/div> 進入JavaScript的部分，先把DOM元素選取起來： //指定DOM let send = document.querySelector('.send'); let list = document.querySelector('.list'); let finishList = document.getElementById('finishlist'); 接下來定義資料的部分： 計畫邀請的名單，要把它變成陣列物件的格式 已經寄出邀請函的名單，也要轉成陣列物件的格式 //資料：設定計畫邀請名單「listData」的localStorage資料，轉為陣列物件 let data = JSON.parse(localStorage.getItem('listData')) || []; //資料：設定寄出名單「listFinish」的localStorage資料，轉為陣列物件 let finishData = JSON.parse(localStorage.getItem('listFinish')) || []; 接下來把事件綁訂到前面指定的DOM元素上。然後更新資料，此時尚未輸入資料，localStorage的key應該還沒建立，所以為空陣列。 //事件綁定，監聽與更新 send.addEventListener('click', addData); list.addEventListener('click', toggleDone); finishList.addEventListener('click', deleDone); //更新畫面上的資料 updateList(data); updateFinish(finishData); 按下「新增邀請名單後」把資料新增到data中，並叫用updateList這個函式，把資料組字串，渲染到畫面中。 //按下「新增邀請名單後」，把資料新增到data中，並叫用updateList function addData(e) &#123; var txt = document.querySelector('.text'); if (txt.value == \"\") &#123; alert('必須輸入與會者姓名'); return; &#125; var toInvite = &#123; content: txt.value &#125; data.push(toInvite); updateList(data); localStorage.setItem('listData', JSON.stringify(data)); txt.value = ''; &#125; //更新邀請清單 function updateList(items) &#123; str = ''; let len = items.length; //for迴圈組字串 for (let i = 0; len > i; i++) &#123; console.log(items[i]) str += `&lt;li>&lt;a href=\"#\" data-index=$&#123;i&#125;>移到已邀請&lt;/a>&lt;span>$&#123;items[i].content&#125;&lt;/span>&lt;/li>`; &#125; list.innerHTML = str; let noneNum = document.querySelector('.noneNum'); noneNum.textContent = len; &#125; 按下「移到已邀請」時，執行以下程式區塊： //將與會者由邀請清單移至邀請函已寄出清單 function toggleDone(e)&#123; //避免事件冒泡 e.preventDefault(); //如果點選的不是a標籤，那就不往下執行 if(e.target.nodeName !== 'A')&#123; return; &#125; let index = e.target.dataset.index; //把點選的資料推送到finishData中 finishData.push(data[index]); //清除計畫邀請data中的資料 data.splice(index,1); //更新計畫邀請的名單 localStorage.setItem('listData',JSON.stringify(data)); //渲染網頁 updateList(data); //更新已寄出邀請函的名單 localStorage.setItem('listFinish',JSON.stringify(finishData)); //渲染網頁 updateFinish(finishData); &#125; 然後是渲染「已邀請名單」的部分： //更新已寄邀請函清單 function updateFinish(finishItems)&#123; let mailStr = ''; let len = finishItems.length; console.log(finishItems); console.log(len); //for迴圈組字串 for(let i=0;i&lt;len; i++)&#123; console.log(finishItems[i]); mailStr+= `&lt;li>&lt;a href=\"#\" data-num=$&#123;i&#125;>移除&lt;/a>&lt;span>$&#123;finishItems[i].content&#125;&lt;/span>&lt;/li>` &#125; finishList.innerHTML = mailStr; var doneNum = document.querySelector('.doneNum'); doneNum.textContent = len; &#125; 如果點選「刪除」，執行以下程式： //刪除已邀請的貴賓 function deleDone(e)&#123; e.preventDefault(); if(e.target.nodeName !== 'A')&#123; return; &#125; let num = e.target.num; //清除計畫邀請data中的資料 finishData.splice(num,1); //更新已寄出邀請函的名單 localStorage.setItem('listFinish',JSON.stringify(finishData)); //渲染到網頁 updateFinish(finishData); &#125; 來看看我的實作吧！ https://codepen.io/popeye_ux&#x2F;pen&#x2F;KKqbMwq","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day34:好記性的瀏覽器：Localstorage","slug":"21-day34-localstorage","date":"2021-10-03T01:40:56.000Z","updated":"2022-04-18T10:42:26.000Z","comments":true,"path":"2021/10/03/21-day34-localstorage/","link":"","permalink":"https://popeye-ux.github.io/2021/10/03/21-day34-localstorage/","excerpt":"談這個主題之前，我們先來回憶一下日常的場景，你來到桃子購物網站，選了你要的商品往下捲動網頁，結果竟然發現網頁下方秀出你上次來買東西時，看的那幾樣商品，你心中覺得這個網站真貼心，好聰明。","text":"談這個主題之前，我們先來回憶一下日常的場景，你來到桃子購物網站，選了你要的商品往下捲動網頁，結果竟然發現網頁下方秀出你上次來買東西時，看的那幾樣商品，你心中覺得這個網站真貼心，好聰明。 然而，真正貼心、聰明的是你的瀏覽器。這項技術叫做Web Storage，是HTML5之後出來的新技術，網頁可以透過JavaScript把你瀏覽的資料寫入瀏覽器裡儲存，可以儲存的資料容量有5mb大小。 Web Storage有兩種： localStorage：如果沒有清除瀏覽器的話，資料將永久存在瀏覽器中，使用者關掉瀏覽器或分頁，資料仍會存在瀏覽器中，跨瀏覽器分頁也可以使用。 sessionStorage：使用者關掉瀏覽器或分頁，資料就會被清空。 如何看到localStorage的資料呢？ 在Chrome瀏覽器按下F12，瀏覽器會分割稱瀏覽畫面跟Dev Tool，在Dev Tool那一邊點開Application分頁，就可以看到localStorage儲存的資料。 我們可以觀察到它是以Key - Value pair的方式儲存的，而且是以自存的格式儲存的。 那要如何存入資料呢？我們可以使用setItem()方法： localStorage.setItem(key, value) sessionStorage.setItem(key, value) 取出資料則是使用getItem()： localStorage.getItem(key) sessionStorage.getItem(key) 讓我們來砍看如何實作： &lt;h2>報名參加華山論劍&lt;/h2> &lt;input type=\"text\" class=\"nameClass\" /> &lt;input type=\"button\" class=\"btnApply\" value=\"報名\" /> &lt;input type=\"button\" class=\"btnCheck\" value=\"檢查報名狀況\" /> var apply= document.querySelector('.btnApply'); var check=document.querySelector('.btnCheck'); function applyTalk(e)&#123; var str= document.querySelector('.nameClass').value; localStorage.setItem('applyName',str); &#125; apply.addEventListener('click',applyTalk); check.addEventListener('click',function(e)&#123; var str = localStorage.getItem('applyName'); alert(`$&#123;str&#125;，你已經報名成功！！！`) &#125;) 前面有提到localStorage只接受字串(String)的資料，如果存存的資料不是字串，而是陣列或是物件，就會發生問題。 如何解決這個問題呢？ 再用setItem()儲存資料到localStorage裡面的時候，要先用JSON.stringify()轉為字串。 而用getItem()從localStorage取出資料時，要用JSON.parse()方法傳換為本來的資料格式。 讓我們來看一下怎麼做： var island = [ &#123; islandName: '桃花島', owner: '黃藥師' &#125; ]; var islandStr = JSON.stringify(island); console.log(islandStr); //[&#123;\"islandName\":\"桃花島\",\"owner\":\"黃藥師\"&#125;] localStorage.setItem('islandItem',islandStr); var getData = localStorage.getItem('islandItem'); console.log(typeof getData); //string var getDataAry = JSON.parse(getData); //轉換為陣列 console.log(getDataAry); 這就是localStorage的基本用法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day33-「this」好奇怪！","slug":"21-day33-thisStrange","date":"2021-10-01T17:13:01.000Z","updated":"2022-04-18T10:48:12.000Z","comments":true,"path":"2021/10/02/21-day33-thisStrange/","link":"","permalink":"https://popeye-ux.github.io/2021/10/02/21-day33-thisStrange/","excerpt":"聽前輩說，「this」在JavaScript裡面是一個大坑。","text":"聽前輩說，「this」在JavaScript裡面是一個大坑。 前面有提過「this」在事件監聽中，不考慮事件冒泡的情況下，this就等同是e.target，但是如果是被事件冒泡觸發的this則為e.currentTarget。 現在來談談「this」在其他地方要注意的事情。 首先要記住這句話，只要理解這個原則，大部分遇到「this」的狀況都可以輕鬆掌握： 「this代表的是function執行時所屬的物件，而不是function本身」 「this」是在函式被呼叫的時候被自動生成的內部物件，this不等於function，隨著呼叫函示的物件不同，「this」所指向的值也不同。 沒有特別指定this的情況下，this預設綁定(Default Binding)「全域物件」，也就是window。 但在ES5的嚴格模式下，禁止this自動指定為全域物件，這點要特別注意。 var seven = \"江南七怪\"; console.log(window.seven); //\"江南七怪\" function monster()&#123; console.log(this.seven + \"脾氣古怪\"); &#125; monster(); //\"江南七怪脾氣古怪\" var obj = &#123; seven : \"七喜汽水\", func: monster &#125; obj.func(); //\"七喜汽水脾氣古怪\" 所以在全域環境中直接呼叫monster()函式時，this.seven是指向全域變數的var seven &#x3D; “江南七怪”；當monster()作為obj物件func屬性的方法的時候，this.seven會指向obj物件的seven屬性”七喜汽水”。 var seven = \"江南七怪\"; var call = function() &#123; console.log(this.seven); &#125; var soda = function()&#123; let seven = \"七喜汽水\"; this.call(); &#125; soda(); //\"江南七怪\" soda()透過this.call()來叫用call()，這時call()裡面的this.seven是指向全域變數的seven，所以得到的結果是”江南七怪”。 如何強制指定this在JavaScript有三種方式可以強制指定this給function，這種方式也叫「顯式綁定」，分別是： .call() .apply() .bind() 先來說說.call與.apply function funcA()&#123; //做某件大事 &#125; funcA.call(context, arg1, arg2...) funcA.apply(context,[arg1,arg2...]) 上面的程式碼式使用.call與.apply去呼叫執行funcA，第一個參數context為所帶入的物件，也就是強制用那個物件來當成function執行時的物件。 .call與.apply作用一樣，差別在.apply第一個參數(帶入的物件)之後的參數以陣列方式傳入，而.call則是使用逗號隔開。 let kuo = &#123; name: \"郭靖\", wife: \"黃蓉\" &#125; let yung = &#123; name: \"楊過\", wife: \"小龍女\" &#125; function funcA()&#123; console.log(`$&#123;this.name&#125;的老婆是$&#123;this.wife&#125;`) &#125; funcA.call(kuo) //郭靖的老婆是黃蓉 funcA.apply(yung) //楊過的老婆是小龍女 funcA.call(null,\"周伯通\",\"瑛姑\")//的老婆是undefined 我們可以看見this.name與this.wife綁定到帶入的物件上。而this隨著所帶入的物件不同，指向也會動態地改變。 而bind的用法如下： let kuo = &#123; name: \"郭靖\", wife: \"黃蓉\" &#125; let yung = &#123; name: \"楊過\", wife: \"小龍女\" &#125; function funcA()&#123; console.log(`$&#123;this.name&#125;的老婆是$&#123;this.wife&#125;`) &#125; let kuoWife = funcA.bind(kuo); kuoWife() //郭靖的老婆是黃蓉 let yungWife = funcA.bind(yung); yungWife() //楊過的老婆是小龍女 藉由‵let kuoWife &#x3D; funcA.bind(kuo) ‵也可以把this指向所帶入的物件。 其實以上的應用，萬變不離其宗，只要記得：「this代表的是function執行時所屬的物件，而不是function本身」","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day32:暗通款曲的閉包","slug":"21-day32-clouse","date":"2021-10-01T09:42:20.000Z","updated":"2022-04-18T02:13:58.000Z","comments":true,"path":"2021/10/01/21-day32-clouse/","link":"","permalink":"https://popeye-ux.github.io/2021/10/01/21-day32-clouse/","excerpt":"在「閉包」這一關，我一直有一種似懂非懂，玄之又玄的感覺。","text":"在「閉包」這一關，我一直有一種似懂非懂，玄之又玄的感覺。 MDN上對「閉包」的定義： 「閉包為函式的組合、還有該宣告函式的作用域環境。這個環境包含閉包建立時，所有位於該作用域的區域變數。」 每個字都看得懂，但是合起來是甚麼意思？ 唉！我們重新來看一下函式的寫法： 小龍女在絕情谷底養的玉峰，飛到周伯通住的百花谷，要如何分辨一班的蜜蜂與小龍女養的玉峰呢？當然是看看翅膀上有沒有寫：「我在絕情谷底」，有寫的就是玉蜂。 這是一般函式的寫法： var bee=\"蜜蜂\"; function flyOut()&#123; var bee = \"玉蜂\"; return `$&#123;bee&#125;翅膀上有寫「我在絕情谷底」`; &#125; flyOut(); //\"玉蜂翅膀上有寫「我在絕情谷底」\" 如果我們在flyout()再內嵌一個inner函式，這時直接呼叫flyout()，出來的結果會是undefined。 var bee=\"蜜蜂\"; function flyOut()&#123; var bee = \"玉蜂\"; function inner()&#123; return `$&#123;bee&#125;翅膀上有寫「我在絕情谷底」`; &#125; &#125; flyOut(); //undefined 沒有回傳值 但是如果我們再flyout那一層，加上「return inner();」，會回傳「”玉蜂翅膀上有寫「我在絕情谷底」”」。 var bee=\"蜜蜂\"; function flyOut()&#123; var bee = \"玉蜂\"; function inner()&#123; return `$&#123;bee&#125;翅膀上有寫「我在絕情谷底」`; &#125; return inner(); &#125; flyOut(); //\"玉蜂翅膀上有寫「我在絕情谷底」\" 再來把return inside()的小括號拿掉。 var bee=\"蜜蜂\"; function flyOut()&#123; var bee = \"玉蜂\"; function inner()&#123; return `$&#123;bee&#125;翅膀上有寫「我在絕情谷底」`; &#125; return inner; &#125; flyOut(); //ƒ inner()&#123; return `$&#123;bee&#125;翅膀上有寫「我在絕情谷底」`; &#125; 結果回傳的是inside()的程式碼： ƒ inner()&#123; return `$&#123;bee&#125;翅膀上有寫「我在絕情谷底」`; &#125; 再更進一步，在外層用變數outBee來存取flyOut()： var bee=\"蜜蜂\"; function flyOut()&#123; var bee = \"玉蜂\"; function inner()&#123; return `$&#123;bee&#125;翅膀上有寫「我在絕情谷底」`; &#125; return inner; &#125; var outBee = flyOut(); flyBee(); //\"玉蜂翅膀上有寫「我在絕情谷底」\" var honeyBee = flyout(); //\"玉蜂翅膀上有寫「我在絕情谷底」\" 還記得「切分變數最小的範圍是function」這句話嗎？ inner()被內嵌在flyOut()之內，所以inner()裡的變數能夠存取的範圍就是flyOut()跟全域的範圍，它在flyOut()裡面找到了bee &#x3D; “玉蜂”，就不會再往外層去找。這種訪問機制就是「作用域鍊(Scope chain)」 JavaScript 引擎的回收機制會釋放不再使用的記憶體，清空不再使用的變數，但閉包為了保留函式記得和存取其執行環境的能力，就會予以保留，不做記憶體回收。所以當程式執行完var outBee &#x3D; flyOut();這一行，原本應該被記憶體釋放掉的flyOut()裡面的變數bee變成了「自由變數」，還是可以拿來運算。 這種可以適用自由變數的函式，就是「閉包」。 雖然 outBee 位於 flyOut()函式所定義的範疇之外，但由於閉包的緣故， 所以能正常執行inner()函式，並存取到 bee 的值，進而執行出”玉蜂翅膀上有寫「我在絕情谷底」”的結果。 所以在flyout()的函示內部回傳inner函式的同時，除了傳回程式碼之外，也回傳了內部函式建立時的變數值bee&#x3D;”玉蜂”，連同執行環境一起被回傳了。 嗯！這樣在絕情谷外的楊過就可以依據蜜蜂身上的資訊找到小龍女了！XD 這就是一種「閉包」的資料結構，包含函式及函式被建立時的當下環境。 許國政先生在《0 陷阱！0 誤解！8 天重新認識 JavaScript！》一書中： 「當你在呼叫函式的以前，範圍鍊就已經被建立了。因此我們可以在函式(outer)裡面「回傳」另一個內部函式(inner)給外層的範圍，使得外層也可以透過『範圍鍊』取得內部的變數(msg)。」 這句話直白易懂，是大神才寫得出來的！ 所以我們可以透過「閉包」的方式，呼叫「函式」內的「函式」，我們可以把變數封裝在函式中，避免變數汙染全域環境，而且可以重複存取叫用函式及其內部環境。許多框架也是透過這種方式運作的。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day31:IIFE立即執行函式","slug":"21-day31-IIFE","date":"2021-10-01T09:40:01.000Z","updated":"2022-04-18T10:48:06.000Z","comments":true,"path":"2021/10/01/21-day31-IIFE/","link":"","permalink":"https://popeye-ux.github.io/2021/10/01/21-day31-IIFE/","excerpt":"IIFE（Immediately Invoked Function Expression），是一種「可以立即執行的函式」。","text":"IIFE（Immediately Invoked Function Expression），是一種「可以立即執行的函式」。 一般的函式長這樣： function doSomething (x)&#123; //do something &#125;; doSomething(參數); //呼叫doSomething，執行程式區塊 而立即執行函式長成這個樣子： (function doSomething (x) &#123; //do something &#125;)(參數); //不用呼叫doSomething函式，X帶入參數，立即在程式區塊中執行 立即執行函式，不透過呼叫函式的方式，瀏覽器讀到函式後面附加的小括號( )，就知道要在函式宣告的當下立即執行。 假設洪七公嘴饞想吃叫化雞，叫黃蓉馬上烤一隻叫化雞來吃： (function cooking(food)&#123; console.log(`丫頭去弄個$&#123;food&#125;來吃吃！！！`); &#125;)('叫化雞') //丫頭去弄個叫化雞來吃吃！！！ cooking('東坡肉'); //Uncaught ReferenceError: cooking is not defined 如果在立即執行函式的外面再呼叫一次cooking函式，就會出現「Uncaught ReferenceError: cooking is not defined」。 既然提到了立即執行函式，讓我們利用它來解一下面試中常常會出現的考題： 「每次間隔一秒，依次印出0、1、2、3、4」 你會怎麼解呢？直覺應該利用for迴圈 + window.setTimeout()來解題： for(var i = 0; i &lt; 5; i++)&#123; window.setTimeout(function()&#123; console.log(i); &#125;,1000) &#125; 圖 結果是直接印出五個5，說好的0、1、2、3、4呢？ 還記得前面提過「切分辨數最小範圍是function」，所以for迴圈和window.setTimeout()是個跑各的。 for迴圈是急驚風，而window.setTimeout()是慢郎中，window.setTimeout()剛剛過了一秒去捉外面的i來console.log()的時候，for迴圈已經跑完五次，i++變成5，不符合i&lt;5的條件跳出迴圈了，所以window.setTimeout()捉迴圈的i，每次都捉到5。 那要怎麼解決這個問題呢? 我們可以把window.setTimeout()封裝在一個立即執行函式裡面，後面的小括號則帶入迴圈每次跑出來的 i，讓 i 把值帶入 x 裡面丟到 window.setTimeout() 去執行。 for(var i = 0; i &lt; 5; i++)&#123; (function(x)&#123; window.setTimeout(function()&#123; console.log(x); &#125;,x*1000); &#125;)(i); &#125; 這樣就會每隔1秒依序印出0、1、2、3、4了。 當然另外一個更簡單的解法則是把for迴圈的變數宣告「var i &#x3D; 0」直接改成「let i &#x3D; 0」，利用let是以大括號區塊為作用域的概念，讓for迴圈必須與window.setTimeout()一起跑。 for(let i = 0; i &lt; 5; i++)&#123; window.setTimeout(function()&#123; console.log(i); &#125;,1000) &#125; 這樣就會間格1秒，依序印出0、1、2、3、4了。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day30:回頭呼喊你的愛情：Callback回呼函式","slug":"21-day30-callBack","date":"2021-09-30T09:34:09.000Z","updated":"2022-04-17T18:38:48.000Z","comments":true,"path":"2021/09/30/21-day30-callBack/","link":"","permalink":"https://popeye-ux.github.io/2021/09/30/21-day30-callBack/","excerpt":"甚麼是「Callback function」?","text":"甚麼是「Callback function」? MDN的解釋如下： 「回呼函式（callback function）是指能藉由參數（argument）通往另一個函式的函式。它會在外部函式內調用、以完成某些事情。」 我改寫一下MDN上的範例： function aFunc(name) &#123; alert('Hello ' + name); &#125; function bFunc(callback) &#123; var name = prompt('報名華山論劍大會，請輸入你的名字：'); callback(name); &#125; bFunc(aFunc); 最後呼叫函式 bFunc (aFunc)，aFunc是bFunc的callback參數，bFunc的變數name又藉由callback傳入bFunc之中。所以我們可以理解「把A函式當成B函式的參數，透過B函式來呼叫它」，A函式就是一個Callback function。 解釋有點抽象嗎？讓我們換個場景，想想之前提過的「事件監聽」。 例如：看到紅燈，然後踩剎車！踩剎車這個動作，在「看到紅燈」這個條件滿足的時候才執行。所以我們會監聽「看到紅燈」這個事件，一旦事件觸發，就去呼叫「剎車」這個動作(函式)。這也是把「剎車」這個函式當成事件監聽的參數。 還有一個常常會用到的window.setTimeout()也是callback function的經典案例： window.setTimeout(function()&#123;//do something&#125;,1000); 所以我們可以歸納出： 「把A函式當成B函式的參數，透過B函式來呼叫它」，A函式就是一個Callback function。 滿足某個條件才去執行的函式，就可以稱為Callback function。 那在甚麼時候適合使用callback function呢？我想是在「控制函式執行的時機」的情境下適合使用： 滿足條件，才去執行的函式。 控制函式執行的先後順序。 假設郭靖跟歐陽克都中了毒： let poisonA = function()&#123; alert('歐陽克中毒身亡！'); &#125;; let poisonB = function()&#123; alert('郭靖中毒身亡！'); &#125; poisonA(); poisonB(); 這樣的執行順序當然是先跳(‘歐陽克中毒身亡！’)的視窗，再跳(‘郭靖中毒身亡！’)。但是如果加上一個隨機生成的等待時間，那視窗的彈跳順序就不一定了。 let poisonA = function()&#123; var i = Math.random()+1; window.setTimeout(function () &#123; alert('歐陽克中毒身亡！'); &#125;, i * 1000) &#125;; let poisonB = function()&#123; var i = Math.random()+1; window.setTimeout( () &#123; alert('郭靖中毒身亡！'); &#125;, i * 1000 ) &#125; poisonA(); poisonB(); 有時是(‘郭靖中毒身亡！’)會先跳出來，有時是(‘歐陽克中毒身亡！’)會先跳出來！ 如果我們想確保(‘歐陽克中毒身亡！’)比(‘郭靖中毒身亡！’)早跳出來，可以這樣寫： const poisonA = function(callback)&#123; const i = Math.random() + 1; window.setTimeout(function () &#123; alert('歐陽克中毒身亡！'); if (typeof callback === 'function')&#123; callback(); &#125;; &#125;, i * 1000) &#125;; const poisonB = function()&#123; const i = Math.random() + 1; window.setTimeout (function() &#123; alert('郭靖中毒身亡！'); &#125;, i* 1000 ); &#125; poisonA( poisonB ); 這樣歐陽克就會比郭靖還要早毒發身亡了！ 但是如果中毒的人越來越多，一個函式呼叫另一個函式，一層一層包下去，就變成「回呼地獄」了。 再假設另外一個情境： 「王重陽參加華山論劍，只要打敗黃藥師、洪七公、段皇爺與歐陽鋒，就會奪得『武功第一』的封號。但是不用去管王重陽與人決鬥的先後順序，只要與每個人都打過就可以。」 這時候我們可以這樣做： let fightProcess = []; //設一個空陣列，王重陽每次比武，都push到陣列中 let step = 4; //王重陽與4個人比武 function fightA () &#123; window.setTimeout(function()&#123; fightProcess.push('王重陽打敗黃藥師'); console.log('王重陽打敗黃藥師'); if (fightProcess.length === step)&#123; //比較空陣列fightProcess的長度是否與step相等，如果相等，就執行ightWinner() fightWinner(); &#125; &#125;,(Math.random()+1) * 1000); &#125;; function fightB () &#123; window.setTimeout(function()&#123; fightProcess.push('王重陽打敗洪七公'); console.log('王重陽打敗洪七公'); if (fightProcess.length === step)&#123; fightWinner(); &#125; &#125;,(Math.random()+1) * 1000); &#125; function fightC () &#123; window.setTimeout(function()&#123; fightProcess.push('王重陽打敗段皇爺'); console.log('王重陽打敗段皇爺'); if (fightProcess.length === step)&#123; fightWinner(); &#125; &#125;,(Math.random()+1) * 1000); &#125; function fightD () &#123; window.setTimeout(function()&#123; fightProcess.push('王重陽打敗歐陽鋒'); console.log('王重陽打敗歐陽鋒'); if (fightProcess.length === step)&#123; fightWinner(); &#125; &#125;,(Math.random()+1) * 1000); &#125; function fightWinner()&#123; console.log('王重陽天下武功第一，人稱「中神通」'); console.log(fightProcess); &#125; fightA(); fightB(); fightC(); fightD(); Promise物件Promise物件是ES6之後新增的物件，照字面的解釋就是「承諾」，回傳的結果只有兩種：「解決」與「拒絕」。 Promise物件長成這個樣子： let myPromise = new Promise((resolve, reject) =>&#123; resolve('解決'); reject('拒絕'); &#125;) 要在一個函式中使用Promise功能，只要讓它回傳一個Promise物件就行了： function urPromise()&#123; return new Promise((resolve,reject) => &#123; //resolve()或reject() &#125;); &#125; Promise還提供了三種方法： .then()：依順序串聯執行多個promise功能。 Promise.all()：直到全部函式都回覆resolve，或其中一個reject，才繼續後面功能 Promise.race()：只要其中一個函式resolve，不等待其他含式執行，直接行後續動作， 像剛剛那個「王重陽與四大高手比武」的過程就可以這樣寫： function fightA () &#123; return new Promise(function(resolve,reject)&#123; window.setTimeout(function() &#123; console.log('王重陽打敗黃藥師'); resolve('王重陽打敗黃藥師'); &#125;,(Math.random()+1) * 1000); &#125;); &#125; function fightB () &#123; return new Promise((resolve,reject) =>&#123; window.setTimeout(() =>&#123; console.log('王重陽打敗洪七公'); resolve('王重陽打敗洪七公'); &#125;,(Math.random()+1) * 1000); &#125;); &#125; function fightC () &#123; return new Promise((resolve,reject) =>&#123; window.setTimeout(() =>&#123; console.log('王重陽打敗段皇爺'); resolve('王重陽打敗段皇爺'); &#125;,(Math.random()+1) * 1000); &#125;); &#125; function fightD () &#123; return new Promise((resolve,reject) =>&#123; window.setTimeout(() =>&#123; console.log('王重陽打敗歐陽鋒'); resolve('王重陽打敗歐陽鋒'); &#125;,(Math.random()+1) * 1000); &#125;); &#125; function fightWinner()&#123; console.log('王重陽天下武功第一，人稱「中神通」'); &#125; //加上.then可以做到依次執行 fightA() .then(fightB) .then(fightC) .then(fightD) .then(fightWinner); 我們在呼叫fightA()之後，用.then串接後面要執行的函式，這樣我們就可以做到依順序執行了。 來看看promise.all的情況： function fightA () &#123; return new Promise(function(resolve,reject)&#123; window.setTimeout(function() &#123; console.log('王重陽打敗黃藥師'); resolve('王重陽打敗黃藥師'); &#125;,(Math.random()+1) * 1000); &#125;); &#125; function fightB () &#123; return new Promise((resolve,reject) =>&#123; window.setTimeout(() =>&#123; console.log('王重陽打敗洪七公'); resolve('王重陽打敗洪七公'); &#125;,(Math.random()+1) * 1000); &#125;); &#125; function fightC () &#123; return new Promise((resolve,reject) =>&#123; window.setTimeout(() =>&#123; console.log('王重陽打敗段皇爺'); resolve('王重陽打敗段皇爺'); &#125;,(Math.random()+1) * 1000); &#125;); &#125; function fightD () &#123; return new Promise((resolve,reject) =>&#123; window.setTimeout(() =>&#123; console.log('王重陽打敗歐陽鋒'); resolve('王重陽打敗歐陽鋒'); &#125;,(Math.random()+1) * 1000); &#125;); &#125; function fightWinner()&#123; console.log('王重陽天下武功第一，人稱「中神通」'); &#125; //不管fightA(),fightB(),fightC(),fightD()的執行順序，只要都執行了就繼續後面的程式 Promise.all([fightA(),fightB(),fightC(),fightD()]) .then(fightWinner); Promise.all()則會等待全部的Promise函式都執行了，才會進行後面的.then函式。 然後是promise.race： function fightA () &#123; return new Promise(function(resolve,reject)&#123; window.setTimeout(function() &#123; console.log('王重陽打敗黃藥師'); resolve('王重陽打敗黃藥師'); &#125;,(Math.random()+1) * 1000); &#125;); &#125; function fightB () &#123; return new Promise((resolve,reject) =>&#123; window.setTimeout(() =>&#123; console.log('王重陽打敗洪七公'); resolve('王重陽打敗洪七公'); &#125;,(Math.random()+1) * 1000); &#125;); &#125; function fightC () &#123; return new Promise((resolve,reject) =>&#123; window.setTimeout(() =>&#123; console.log('王重陽打敗段皇爺'); resolve('王重陽打敗段皇爺'); &#125;,(Math.random()+1) * 1000); &#125;); &#125; function fightD () &#123; return new Promise((resolve,reject) =>&#123; window.setTimeout(() =>&#123; console.log('王重陽打敗歐陽鋒'); resolve('王重陽打敗歐陽鋒'); &#125;,(Math.random()+1) * 1000); &#125;); &#125; function fightWinner()&#123; console.log('王重陽天下武功第一，人稱「中神通」'); &#125; //只要fightA(),fightB(),fightC(),fightD()其中之一執行，就繼續執行後面的程式 //但是fightA(),fightB(),fightC(),fightD()都會執行，不會取消 Promise.race([fightA(),fightB(),fightC(),fightD()]) .then(fightWinner); Promise.race就如同「競賽」一樣，只要有其中一個Promise函式先做到，不待其它的Promise函式完成，就直接進行.then後面的程式。但是其他的Promise函式還是會繼續執行，不會取消。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day29:事件監聽的 this :「這個」到底是哪一個?-this","slug":"21-day29-this","date":"2021-09-29T09:31:58.000Z","updated":"2022-04-17T18:38:46.000Z","comments":true,"path":"2021/09/29/21-day29-this/","link":"","permalink":"https://popeye-ux.github.io/2021/09/29/21-day29-this/","excerpt":"","text":"歐陽克是誰殺的? 這個 this 是誰？要看兇手是誰而定！ 前面有提到，這個 e 是在當事件發生時，事件處理器自動建立的「事件物件」，裡面紀錄了跟事件有關係的資訊，並把這個e當參數傳入事件發生時設定要執行的函式。 如果我們想要印出，滑鼠所點擊的元素的標籤名稱，可以這樣寫： element.addEventListener('click', function (e)&#123; console.log(e.target.tagName); &#125;,false) 「 e.target 」就是「觸發事件的元素」。在這種狀況下，我們可以使用「 this 」來取代 「 e.target 」。 當我們選取 DOM 元素來做事件監聽的時候， this 會指向那個DOM元素。以下這段程式，滑鼠點擊 &lt;li&gt; 之後，字體會變成紅色的。 &lt;div id=\"sword\"> &lt;ul class=\"fiveHero\"> &lt;li class=\"firstHero\">1 東邪&lt;/li> &lt;li class=\"secondHero\">2 西毒&lt;/li> &lt;li class=\"thirdHero\">3 南帝&lt;/li> &lt;li class=\"fifthHero\">4 北丐&lt;/li> &lt;li class=\"lastHero\">5 中神通&lt;/li> &lt;/ul> &lt;/div> var elements = document.getElementsByTagName('li'); function changeColor(e) &#123; console.log(e.target); e.target.style.color = 'red'; &#125; for (var i = 0; i &lt; elements.length; i++) &#123; elements[i].addEventListener('click', changeColor, false); &#125; 我們用「 this 」來取代「 e.target 」，跟上面那個JavaScript 程式區塊呈現一樣的效果。 var elements = document.getElementsByTagName('li'); //沒有用e當function的參數 function changeColor() &#123; console.log(this); this.style.color = 'red'; &#125; for (var i = 0; i &lt; elements.length; i++) &#123; elements[i].addEventListener('click', changeColor, false); &#125; 但是當「事件監聽」是被其他元素的事件所觸發的時候，「 this 」就不等於「 e.target 」了。來看看下面的例子： &lt;div class=\"outer\"> &lt;div class=\"inner\">&lt;/div> &lt;/div> var inner = document.querySelector('.inner') var outer =document.querySelector('.outer'); inner.addEventListener('click', function(e) &#123; console.log(e.target.className,1) console.log(this.className,1) &#125;,false) outer.addEventListener('click', function(e)&#123; console.log(e.target.className,2) console.log(this.className,2) &#125;,false) 點擊黃色區塊後，出來的結果是： \"inner\" 1 //黃色區塊所觸發的事件,e.targer = 觸發事件的元素 \"inner\" 1 //黃色區塊所觸發的事件,e.target = this = 觸發事件的元素 \"inner\" 2 //黃色區塊事件冒泡所觸發的事件 , e.target = 觸發事件的元素 \"outer\" 2 //黃色區塊事件冒泡觸發紅色區塊的事件， this = 被事件冒泡所觸發的元素，而非e.target 在這個例子中， outer.addEventListener() 是被 inner.addEventListener() 的事件冒泡所觸發， e.target 為觸發事件的元素，真正的凶手當然就是 inner 。而 outer.addEventListener() 的 this 卻是指向 outer ，它是被事件冒泡所觸發的元素，也就是 e.currentTarget ，也就是被害者，被 inner 害的。 在沒有事件冒泡影響的情況下， e.target &#x3D; this ，兇手與被害者是同一人，也就是自作自受。 當元素的事件是被事件冒泡所觸發的時候： e.target 是兇手，郎是伊抬ㄟ！ e.currentTarget 就是被害者！ this 就是 e.currentTarget ！也就是被事件冒泡影響所觸發的元素。 歐陽克是被楊康殺的！ 咦！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day28:e.stopPropagation()停止事件冒泡","slug":"21-day28-stopPropagation","date":"2021-09-28T09:29:35.000Z","updated":"2022-04-17T18:38:50.000Z","comments":true,"path":"2021/09/28/21-day28-stopPropagation/","link":"","permalink":"https://popeye-ux.github.io/2021/09/28/21-day28-stopPropagation/","excerpt":"當事件發生的時候，如果想要阻擋事件向上傳遞，只要利用「事件物件」( Event Object )所提供的 e.stopProoagation() ，就可以阻止事件由觸發的元素向外冒泡。","text":"當事件發生的時候，如果想要阻擋事件向上傳遞，只要利用「事件物件」( Event Object )所提供的 e.stopProoagation() ，就可以阻止事件由觸發的元素向外冒泡。 當我們有兩個區塊，一個叫 inner ，一個叫 outer ， inner 被包在 outer 中間。 &lt;div class=\"outer\"> &lt;div class=\"inner\">&lt;/div> &lt;/div> .outer &#123; width: 400px; height: 400px; background: red; margin: 0 auto 0; &#125; .inner &#123; width: 200px; height: 200px; background: yellow; margin: 0px auto 0px; transform: translateY(50%); &#125; var elOuter = document.querySelector('.outer'); elOuter.addEventListener('click',function () &#123; alert('outer'); &#125;,false); var elInner = document.querySelector('.inner'); elInner.addEventListener('click',function () &#123; alert('inner'); &#125;,false); 因為「事件冒泡」的關係，點擊 inner 會先跳出 「 inner 」的警告視窗，而 click 事件會傳遞到 outer 區塊，跟著跳出「 outer 」的警告視窗。 如果要阻止事件冒泡向上傳遞，就要在 addEventLister() 的 function(e){ } 參數裡面加上 e ，在 function 區塊前面加上 e.propagation ，這樣就能阻止事件向上傳遞了。 var elOuter = document.querySelector('.outer'); //在outer的節點上綁定事件監聽，點擊後跳出'outer'的警告視窗 elOuter.addEventListener('click',function () &#123; alert('outer'); &#125;,false) var elInner = document.querySelector('.inner'); //在inner的節點上綁定事件監聽，點擊後跳出'inner'的警告視窗 elInner.addEventListener('click',function (e) &#123; //阻止事件向外冒泡，只執行'inner'這個區塊的程式碼 e.stopPropagation(); alert('inner'); &#125;,false)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day27:e是咱ㄟ寶貝","slug":"21-day27-eventTarget","date":"2021-09-27T09:27:45.000Z","updated":"2022-04-17T18:38:54.000Z","comments":true,"path":"2021/09/27/21-day27-eventTarget/","link":"","permalink":"https://popeye-ux.github.io/2021/09/27/21-day27-eventTarget/","excerpt":"前面提到那個 e ，蘊含著我們與網頁互動豐富的資訊。","text":"前面提到那個 e ，蘊含著我們與網頁互動豐富的資訊。 例如： type ：代表事件的類別。 target ：為觸發事件的元素。 screenX &#x2F; screenY：代表事件觸發時，滑鼠座標在螢幕解析度上的相對位置。 pageX &#x2F; pageY： 表示事件觸發時，滑鼠座標在網頁上的相對位置。 clientX &#x2F; clientY： 代表事件觸發時，滑鼠座標在瀏覽器視窗內的相對位置。 我做了一個列表，裡面放了倚天劍、屠龍刀還有碧血劍。 &lt;ul id=\"box\"> &lt;li class=\"sky\">倚天劍&lt;/li> &lt;li class=\"dragon\">屠龍刀&lt;/li> &lt;li class=\"blood\">碧血劍&lt;/li> &lt;/ul> &lt;h1>顯示e的資訊&lt;/h1> &lt;ul> &lt;li>target: &lt;span class=\"target\">&lt;/span>&lt;/li> &lt;li>tagName: &lt;span class=\"tagName\">&lt;/span>&lt;/li> &lt;li>className: &lt;span class=\"className\">&lt;/span>&lt;/li> &lt;li>textContent: &lt;span class=\"textContent\">&lt;/span>&lt;/li> &lt;li>screenX: &lt;span class=\"screenX\">&lt;/span>&lt;/li> &lt;li>screenY: &lt;span class=\"screenY\">&lt;/span>&lt;/li> &lt;li>pageX: &lt;span class=\"pageX\">&lt;/span>&lt;/li> &lt;li>pageY: &lt;span class=\"pageY\">&lt;/span>&lt;/li> &lt;li>clientX: &lt;span class=\"clientX\">&lt;/span>&lt;/li> &lt;li>clientY: &lt;span class=\"clientY\">&lt;/span>&lt;/li> &lt;/ul> 然後從列表的 ul 標籤來監聽滑鼠的點擊事件，讓 getInformation 這個函式去捉「事件物件」( event )裡面的資訊。 var el = document.getElementById('box'); var target = document.querySelector('.target') var tagName = document.querySelector('.tagName'); var className = document.querySelector('.className'); var content = document.querySelector('.textContent'); var screenX = document.querySelector('.screenX'); var screenY = document.querySelector('.screenY'); var pageX = document.querySelector('.pageX'); var pageY = document.querySelector('.pageY'); var clientX = document.querySelector('.clientX'); var clientY = document.querySelector('.clientY'); function getInformation (e) &#123; target.textContent = e.target; tagName.textContent = e.target.tagName; className.textContent = e.target.className; content.textContent = e.target.textContent; screenX.textContent = e.screenX; screenY.textContent = e.screenY; pageX.textContent = e.pageX; pageY.textContent = e.pageY; clientX.textContent = e.clientX; clientY.textContent = e.clientY; &#125; el.addEventListener('click', getInformation, false); https://codepen.io/popeye_ux&#x2F;pen&#x2F;VwbWrXL 可以到 Codepen 看看我做的範例，應該有進一步的體會。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day26:事件物件—天外飛來一個e","slug":"21-day26-eventObject","date":"2021-09-26T09:24:35.000Z","updated":"2022-04-17T18:38:52.000Z","comments":true,"path":"2021/09/26/21-day26-eventObject/","link":"","permalink":"https://popeye-ux.github.io/2021/09/26/21-day26-eventObject/","excerpt":"剛開始學 JavaScript 的時候，在書上看到事件綁定的範例：","text":"剛開始學 JavaScript 的時候，在書上看到事件綁定的範例： //HTML &lt;a id=\"link\" href=\"http://yahoo.com\">雅虎&lt;/a> //JavaScript var link = document.getElementById('link'); btn.addEventListener('click', function(e)&#123; e.preventDefault(); console.log('yahoo'); &#125;,false); 老師有教 preventDefault() 是阻止事件的預設行為，讓人在點擊連結的時候，連結沒有發生作用，不會連到雅虎的頁面上去。 但是…但是…那個 e，也就是 function(e) 括號中的那個 e……，還有 e.preventDefault() 的那個 e ，到底是從哪來的? 就是這個 e 把我搞得一頭霧水，頭上三條線！ 後來再深入學習，知道當 addEventListener() 監聽事件發生的時候，瀏覽器會找事件處理器( Event Handler )來執行原本設定要執行的任務，事件處理器就是 addEventListener() 的第二個參數 function 的部分。 而那個放在 function(e) 的 e 就是這個 eventListener 建立的「事件物件」( event object )，裡面放著跟這個事件有關係的所有屬性，並且用參數的方式傳入事件處理器，也就是 addEventListener() 的第二個參數 function 中。 &lt;button id=\"btn\">點我...點點我&lt;/btn> var btn = document.getElementById('btn'); btn.addEventListener('click', function(e)&#123; console.log(e); &#125;,false); 當你點了「點我…點點我」，打開瀏覽器控制台的 console ，點開 MouseEvent 可以看到所有 event 物件包含的屬性： 所以我們了解： 這個 e 是在當事件發生時，事件處理器自動建立的「事件物件」，裡面紀錄了跟事件有關係的資訊，並把這個 e 當參數傳入事件發生時設定要執行的函式。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day25:派一個Spy到網頁中竊聽—事件監聽","slug":"21-day25-addEventListener","date":"2021-09-25T09:22:04.000Z","updated":"2022-04-17T18:38:54.000Z","comments":true,"path":"2021/09/25/21-day25-addEventListener/","link":"","permalink":"https://popeye-ux.github.io/2021/09/25/21-day25-addEventListener/","excerpt":"先來說說什麼是「事件」吧？","text":"先來說說什麼是「事件」吧？ 舉個例子：看到紅燈，就踩剎車！ 「看到紅燈」就是事件；「踩剎車」就是事件發生後所採取的行動。而在網頁上所發生的事件，可能是使用者滑鼠點擊、滑鼠移入、滾動瀏覽器卷軸、改變視窗大小…等等。 瀏覽器載入網頁時，會把所有的 JavaScript 程式碼載入，但是並不是所有程式碼都會馬上執行，有些必須等到「事件發生」，才會執行相對應的程式碼，例如，「按下按鈕」，跳出「對話框」。「按下按鈕」是事件( Event )，「跳出對話框」就是執行相對應的程式碼( Event Handler )。 當然你必須要把監聽的事件( Event )跟你要執行的程式碼( Event Handler )綁定在一起，事件發生時兩者才會連動。 目前綁定的方法有： 由網頁上HTML元素上綁定 on-event 處理器 利用 DOM API 所提供的 on-event 處理器來綁定 在網頁上HTML元素上綁定 on-event 處理器在HTML元素上透過「on + 事件名稱」來綁定事件，只要事件被觸發，就會執行 JavaScript。 &lt;button id=\"btn\" onclick=\"alert('降龍十八掌之亢龍有悔')\">點擊出招&lt;/button> 在早期都是透過這種方式綁定事件，但隨著觀念的進化，這種「侵入式的寫法」容易造成資安漏洞，也不符合「關注點分離」，由HTML 負責架構與內容， JavaScript 負責互動的觀念。現在比較少用這種綁定事件的方式了。 利用DOM API所提供的on-event處理器來綁定也可以在 JavaScript 中藉由 document.getElementById() 或 document.querySelector() 選取 HTML 元素當節點，然後將 on-event 綁定在選取的節點上。 &lt;button id=\"btn\">點擊出招&lt;/button> //選取節點 let btn = document.getElementById('btn'); //將on-event綁定在事件上 btn.onclick = function()&#123; alert('降龍十八掌之見龍在田'); &#125;; 如果希望 HTML 一載入瀏覽器， JavaScript 就自動執行，可以這樣寫： window.onload = function()&#123; alert('飛雪連天射白鹿，笑書神俠倚碧鴛'); &#125; 事件監聽為了要偵測使用者對網頁所做的行為，如果可以在網頁中埋伏一個間諜，監看使用者是否有對指定的元素做出設定好的動作，如果有的話，就給予相對的回應，這樣就會方便得多。 那該如何來做事件監聽呢？基本上「事件監聽」長成這個樣子： HTML元素節點.addEventListener('事件名稱'，事件處理器，boolean值) 「事件名稱」指的是使用者對綁定的 HTML 元素節點所做的事情，例如點擊( click )、滑鼠移入( mouseenter )…等事件。 「事件處理器」( Event Handler )指的是事件發生時，要叫用的 function()。 布林值( boolean )， false 代表事件冒泡( Event Bubbling )，而 true 代表事件捕捉( Event Capturing )。這是甚麼意思呢？ 事件冒泡( Event Bubbling )：由啟動事件的元素節點開始，向外層傳遞。 事件捕捉( Event Capturing )：由最外層開始，一層一層找到啟動事件的元素節點。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>標題&lt;/title> &lt;/head> &lt;body> &lt;div>點我--隔山打牛--點我&lt;/div> &lt;/body> 事件觸發的傳遞順序會是： &lt;div&gt;點我–隔山打牛–點我&lt;/div&gt; &lt;body&gt; &lt;html&gt; document 因為&lt;div&gt;點我–隔山打牛–點我&lt;/div&gt;也是在&lt;body&gt;的範圍中，所以點擊它的同時也會傳遞到&lt;body&gt;，跟著也會傳到&lt;html&gt;與document。這種click事件一層一層往上依序被觸發，就是「事件冒泡」機制。 而「事件捕獲」傳遞的順序則相反，同樣是點擊&lt;div&gt;點我–隔山打牛–點我&lt;/div&gt;，但是傳遞順序卻如下： document &lt;html&gt; &lt;body&gt; &lt;div&gt;點我–隔山打牛–點我&lt;/div&gt; 講解完事件綁定，來看一下事件綁定的簡單例子： &lt;button id=\"btn\">用滑鼠點穴&lt;/button> let btn = document.getElementById('btn'); btn.addEventListener('click',function()&#123; alert('腳麻袂凍行'); &#125;,false) **而且同元素的同一事件可以重複指定addEventListener()**： let btn = document.getElementById('btn'); btn.addEventListener('click',function()&#123; alert('腳麻袂凍行'); &#125;,false) btn.addEventListener('click',function()&#123; alert('快吃循力寧'); &#125;,false) 如果是 on-event 的方法如果重複綁定的話，則只會出現最後一個綁定的事件。 &lt;input type=\"button\" onclick = \"alert('見龍在田')\" value=\"行內綁定\"> &lt;!-- 使用on-event綁定 --> &lt;input type=\"button\" class=\"btnOn\" value=\"on-event點擊\"> &lt;!-- 使用addEventListener綁定 --> &lt;input type=\"button\" class=\"btnAdd\" value=\"addEvent點擊\"> var elOn = document.querySelector('.btnOn'); elOn.onclick = function()&#123; alert('on-1'); &#125; //雖然同一物件綁訂了兩個on事件處理器，但是只會出現最後一個on-2 elOn.onclick = function()&#123; alert('on-2'); &#125; var elAdd = document.querySelector('.btnAdd'); elAdd.addEventListener('click',function()&#123; alert('add點擊1'); &#125;,false) //同一物件綁訂了兩個addEventListener，兩個綁定的事件處理器都會執行 elAdd.addEventListener('click',function()&#123; alert('add點擊2'); &#125;,false) 那如果要解除 addEventListener() 綁定的事件，可以使用 removeEventListener() 。 HTML元素節點.addEventListener('事件名稱'，事件處理器，boolean值) but，要注意的是「事件處理器」必須要指向同一個「實體」，在下面範例中指的是相同名稱的 function。 let btn = document.getElementById('btn'); btn.addEventListener('click',function()&#123; alert('腳麻袂凍行'); &#125;,false) //愛到不能動，還有甚麼值得我心痛，沒辦法移除事件，因為指向不同實體 btn.removeEventListener('click',function()&#123; alert('腳麻袂凍行'); &#125;,false) 要這麼做才行： &#96;&#96;&#96;jsxlet btn &#x3D; document.getElementById(‘btn’); let canNotMove &#x3D; function() { alert(‘腳麻袂凍行’);} btn.addEventListener(‘click’, canNotMove, false); btn.removeEventListener(‘click’, canNotMove, false);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day21:我變我變我變變變：如何改變HTML元素的樣式","slug":"21-day24-htmlElementStyle","date":"2021-09-24T09:19:18.000Z","updated":"2022-04-17T18:38:56.000Z","comments":true,"path":"2021/09/24/21-day24-htmlElementStyle/","link":"","permalink":"https://popeye-ux.github.io/2021/09/24/21-day24-htmlElementStyle/","excerpt":"「DOM API定義了JavaScript存取、改變HTML架構、內容、樣式的方法，甚至對節點綁定的事件。」","text":"「DOM API定義了JavaScript存取、改變HTML架構、內容、樣式的方法，甚至對節點綁定的事件。」 前面幾篇提到了JavaScript改變HTML架構與內容的方法，這一篇我們來談談怎麼改變HTML的樣式。 再來看一下前面提到的「前端三要素」： HTML負責網頁的結構與內容 CSS負責網頁的外觀與樣式 JavaScript負責網頁的互動與行為 樣式是由CSS負責，所以當我們想要改變HTML的樣式，當然就是要用JavaScript來處理CSS這一塊，而這都要先從選取到某個節點開始。 選取HTML元素，直接修改style屬性 透過className屬性來修改style樣式。 用classList屬性，透過刪除或新增class來修改style樣式 用setAttribute()來更改class屬性 直接修改HTML元素的style使用JavaScript直接修改HTML元素的style，因為這種方式是透過DOM API直接修改元素的行內樣式，樣式的優先權會比其他樣式的寫法高出許多。 //可以在'string'中指定許多種樣式，樣式之間用;隔開就 node.style.cssText = 'string'; //也可以把某個樣式，例如字型大小單獨挑出來 node.style.fontSize = '24px'; 我們試著把黃藥師寫的詩，用JavaScript來改變其樣式： &lt;div class=\"style1\" style=\"color: red; font-size: 45px; border: 3px solid;width: 400px;\"> 桃花影落飛神劍， &lt;/div> &lt;div class=\"style2\" style=\"color: yellow;font-size: 45px;text-decoration:underline;\"> 碧海潮生按玉簫 &lt;/div> 看看下面的JavaScript，cssText將要改的樣式寫在同一行，而且會完全蓋掉本來寫在style1的全部樣式，我在cssText裡面並沒有輸入border的參數，而本來寫在行內樣式的border卻被完全清除了，最後網頁上呈現的結果並沒有border。 如果用「style.CSS屬性名稱」的方式，就可以針對想要改變的屬性來做處理。唯一要注意的是有些CSS屬性名稱中間有 - 的破折號，如font-size、font-weight… 等等屬性，但是在JavaScript的變數及物件屬性名稱是不允許使用 - 破折號，這時屬性名稱就要改成「駝峰式」寫法，如fontSize。 var el1 = document.querySelector(\".style1\").style.cssText = 'font-size: 24px; color: green;'; var el2 = document.querySelector(\".style2\"); el2.style.fontSize = \"16px\"; el2.style.color = \"blue\"; 透過className屬性來修改style樣式透過修改HTML「行內樣式」來調整網頁的外觀，雖然很方便，但是我們說過「CSS負責網頁的外觀與樣式」，如果老是透過「行內樣式」來調整網頁外觀，就做不到HTML、CSS、JavaScript三者「關注點分離」，而且實務上，大多是以HTML連結CSS檔案的方式來設定網頁的外觀與樣式。 那要如何透過修改HTML標籤的class屬性，來改變元素的樣式呢? JavaScript提供了className的屬性來修改HTML元素的class。 node.className = '元素的class名稱' 我們一樣用黃藥師的詩來講解，我們給它兩個class屬性，分別為 redfont與bigtitle。 &lt;h1 class=\"redfont bigtitle\">桃花影落飛神劍，碧海潮生按玉簫&lt;/h1> 以下為外部CSS檔的內容： .redfont &#123; color: red; &#125; .bigtitle &#123; font-size: 40px; &#125; .bluefont &#123; color: blue; &#125; 先選取節點，然後用className的方法，把 &lt;h1&gt; 標籤的本來的 class 取代為 bluefont，我們會發現，除了本來的redfont 之外，連 bigtitle 也被清除掉了。所以如果本來HTML標籤有設定多組 class 屬性，用 className 的方法並不會保留其他沒有被修改的屬性，而是整個 class 被清空，再以className 新增的屬性取代。 var el = document.querySelector('.redfont'); el.className = 'bluefont' 用classList屬性，透過刪除或新增class來修改style樣式classList 與 className 不同之處在於不能直接修改，而是必須透過 claaList.add() 與 classList.remove() 來增加與刪減 HTML 標籤的 class 屬性，如果你的 HTML 標籤有 red 與 big 兩個 class 樣式，你想把 red 改成 green，必須先 classList.remove(red) ，把 red 這個 class 移除，然後再 classList.add(green) ，把 green 這個 class 加入。 &lt;h1 class=\"redfont bigtitle\">桃花影落飛神劍，碧海潮生按玉簫&lt;/h1> 這是CSS檔： .redfont &#123; color: red; &#125; .bigtitle &#123; font-size: 40px; &#125; .greenfont &#123; color: green; &#125; 而這是JavaScript，用來改變 &lt;h1&gt; 標籤內的class，redfont會被greenfont置換，而bigtitle會保留下來。 var el = document.querySelector('.redfont'); el.classList.remove('redfont'); el.classList.add('greenfont'); 還有一個切換 class 的方法，那就是el.classList.toogle(‘class名稱’) ，當所選的元素沒有這個class樣式的時候，就新增這個樣式；如果已經有這個 class 樣式的時候，就會變成刪除它。 var el = document.querySelector('.redfont'); el.classList.toggle('redfont'); //現在是增加 el.classList.toggle('redfont'); //現在是刪除 用setAttribute()來更改class屬性還有一種方式可以用來更改 HTML 元素的 class 屬性，但是它的使用範圍更廣泛一些： element.setAttribute('屬性名稱','屬性值'); //屬性名稱可以是 class、 id、 href //屬性值對應的分別是 class名稱、 id名稱 及 網址 讓我們來看看怎麼做： &lt;h1 class=\"redfont bigtitle\">桃花影落飛神劍，碧海潮生按玉簫&lt;/h1> .redfont &#123; color: red; &#125; .bigtitle &#123; font-size: 40px; &#125; .bluefont &#123; color: blue; &#125; var el = document.querySelector('.redfont'); el.setAttribute('class','bluefont'); 用 setAttribute() 來修改 HTML 元素的 class ，跟className 一樣，也是會先把 class 清空，再用新增的class 設定值取代，所以 bigtitle 這個 class 也會被清除掉。 以上就是幾種修改HTML元素樣式的方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day23:在網頁中插入HTML標籤的實務做法","slug":"21-day23-createElementVsInnerHtml","date":"2021-09-23T01:13:54.000Z","updated":"2022-04-17T18:38:56.000Z","comments":true,"path":"2021/09/23/21-day23-createElementVsInnerHtml/","link":"","permalink":"https://popeye-ux.github.io/2021/09/23/21-day23-createElementVsInnerHtml/","excerpt":"前一篇介紹了在網頁中利用DOM API改變HTML架構與內容的方法，這篇來談談createElement()與innerHTML這兩種做法的差異。","text":"前一篇介紹了在網頁中利用DOM API改變HTML架構與內容的方法，這篇來談談createElement()與innerHTML這兩種做法的差異。 要在HTML中插入HTML標籤有兩種做法： createElement()：這種方法安全性高，但是效能較差。 innerHTML：效能高，必須確認資料來源的資安沒有問題才能使用這種方法，避免有心人是把不好的東西藏在資料中，讓我們經由innerHTML寫入網頁裡。 使用createElement()組字串假設一個情境，有一天華山論劍大會的主辦人金小庸要擬一份參加者名單列表，他只有拿到一個陣列，要把陣列的資料輸出到網頁上，如果是利用DOM API提供的方法，請問他要怎麼做？ 這是金小庸拿到的陣列： var heros = [ &#123; name:'黃藥師', nickname:'東邪' &#125;, &#123; name:'歐陽鋒', nickname:'西毒' &#125;, &#123; name:'段皇爺', nickname:'南帝' &#125;, &#123; name:'洪七公', nickname:'北丐' &#125;, &#123; name:'王陽明', nickname:'中神通' &#125; ]; 金小庸要把名單輸出到&lt;ul class=&#39;list&#39;&gt;&lt;/ul&gt;中間： &lt;h1>華山論劍參加名單&lt;/h1> &lt;ul class=\"list\"> &lt;/ul> 如果以我們前一篇談到的方法，會用for迴圈的方式去捉資料，然後創造一個 &lt;li&gt; 的元素節點，把資料塞入&lt;li&gt;元素節點，再把他們利用迴圈一個一個appendChild()到 &lt;ul class=&quot;list&quot;&gt; &lt;/ul&gt; 中間。 var inviteList = document.querySelector('.list'); var len = heros.length; console.log(len); for (var i=0; i &lt; len; i++)&#123; var guest = document.createElement('li'); guest.textContent = heros[i].nickname + ' : ' + heros[i].name; inviteList.appendChild(guest); &#125; 以上就是利用createElement()創造節點在網頁中插入HTML標籤的方式。 使用innerHTML來組字串而另外一種方法是以迴圈用 innerHTML 組完字串之後，再將它渲染出來。這種方法的優點是效能快，缺點是有資安風險，必須確定拿到的資料沒有問題，才能用innerHTML在網頁中插入標籤。 一樣的情境，金小庸一樣拿到了一個陣列，跟一個準備要填的空白網頁，這次要用innerHTML來加入邀請名單： 這是金小庸拿到的陣列： var heros = [ &#123; name:'黃藥師', nickname:'東邪' &#125;, &#123; name:'歐陽鋒', nickname:'西毒' &#125;, &#123; name:'段皇爺', nickname:'南帝' &#125;, &#123; name:'洪七公', nickname:'北丐' &#125;, &#123; name:'王陽明', nickname:'中神通' &#125; ]; 金小庸要把名單輸出到&lt;ul class=&#39;list&#39;&gt;&lt;/ul&gt;中間： &lt;h1>華山論劍參加名單&lt;/h1> &lt;ul class=\"list\"> &lt;/ul> 使用innrHTML組字串的具體步驟如下： 抓取要插入內容的父容器節點，將它賦值給inviteList變數。 宣告一個名為guest的變數，賦予它空字串的值。 宣告一個名為len的變數，指定給他的值是heros陣列的長度。 利用迴圈去跑陣列，每跑一次把「’‘ + heros[i].nickname + ‘ : ‘ + heros[i].name」塞到guest這個原本為空字串的變數中，直到條件滿足跳出迴圈。 然後把塞好塞滿的guest變數，用innerHTML的方法插入名為inviteList變數的目容器節點後面。 var inviteList = document.querySelector('.list'); var guest = ''; var len = heros.length; for(var i = 0; i &lt; len ; i++)&#123; guest += '&lt;li>' + heros[i].nickname + ' : ' + heros[i].name; &#125; inviteList.innerHTML = guest; 不論是innerHTML或是createElement()都是組字串的好方法，如果沒有資安疑慮，innerHTML效能高，是首選。如果有資安疑慮，那就以createElement()來處理。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day22:給我一個節點，我可以把網頁改頭換面","slug":"21-day22-element","date":"2021-09-22T01:09:30.000Z","updated":"2022-04-17T18:38:48.000Z","comments":true,"path":"2021/09/22/21-day22-element/","link":"","permalink":"https://popeye-ux.github.io/2021/09/22/21-day22-element/","excerpt":"「DOM API 定義了 JavaScript 存取、改變 HTML 架構、內容、樣式的方法，甚至對節點綁定的事件。」","text":"「DOM API 定義了 JavaScript 存取、改變 HTML 架構、內容、樣式的方法，甚至對節點綁定的事件。」 前一篇的內容，是關於 JavaScript 如何「存取」 HTML 節點的方法；這一篇來談談 JavaScript 用甚麼方法改變 HTML 架構、內容與樣式。 JavaScript 改變 HTML 的方法有以下步驟： 新增元素節點或文字節點 利用 appendChild()、 insertBefore 或 replaceChild() 等方法將新增的元素節點與文字節點插入指定的位置。 新增元素節點或文字節點document.createElement(tagName)document.createElement(tagName) 可以幫我們建立一個新的元素節點，但是你利用appendChild() 等方法把它加入指定位置之後才會在網頁上顯示出來。 let newLi = document.createElement('li'); 同時也可針對我們新建立的&lt;li&gt;，指定id及class名稱。 newLi.id = \"goodNewLi\"; newLi.className = \"betterNewLi\"; document.createTextNode()我們也可以利用 document.createTextNode() 建立文字節點，在括號中放入想要新增的字串。跟document.createElement(tagName) 一樣，要用 appendChild() 等方法把新增的文字節點插入指定的位置後面，網頁上才會顯現出來。 let txt = document.createTextNode('string'); document.writedocument.write() 應該是JavaScript 的新手最熟悉的老朋友了！ 利用它不用甚麼 append 方法，馬上可以將括號中的內容輸出到網頁上，而且括號中不只可以放字串，還可以放HTML標籤。 document.write('Hollow World！') 將DOM節點新增到網頁中或是刪改節點Node.appendChild(childNode)Node.appendChild(childNode) 可以讓我們將新增的元素節點或文字節點新增到父容器節點的最尾端。 &lt;ul id=\"fiveHero\"> &lt;li id=\"firstHero\">1 東邪&lt;/li> &lt;li id=\"secondHero\">2 西毒&lt;/li> &lt;li id=\"thirdHero\">3 南帝&lt;/li> &lt;li id=\"fourthHero\">4 北丐&lt;/li> &lt;/ul> 讓我們看看如何將 &lt;li id=&quot;lastHero&quot;&gt;5 中神通&lt;/li&gt; 加入列表的最末端： //取得父容器節點 let heros = document.getElementById('fiveHero'); //新增&lt;li>節點 let newLi = document.createElement('li'); //指定新增節點的id名稱 newLi.id = \"lastHero\"; //新增文字節點 let text = document.createTextNode('5 中神通'); //將文字節點加入到新增的&lt;li>節點中 newLi.appendChild(text); //將新增的&lt;li>節點加入到父容器節點中 heros.appendChild(newLi); Node.insertBefore(newNode,refNode)Node.insertBefore(newNode,refNode) 方法可以將新的節點 (newNode) ，插入到參考節點(refNode) 之前。 &lt;ul id=\"fiveHero\"> &lt;li>1 東邪&lt;/li> &lt;li>2 西毒&lt;/li> &lt;li>4 北丐&lt;/li> &lt;li>5 中神通&lt;/li> &lt;/ul> //取得父容器節點 let heros = document.getElementById('fiveHero'); //建立新節點&lt;li> let newHero = document.createElement('li'); //建立新的文字節點 let thirdHeroTxt=document.createTextNode('3 南帝'); //將文字節點加入新建立的節點&lt;li> newHero.appendChild(thirdHeroTxt); //抓取參考的節點&lt;li id=\"fourthHero\">4 北丐&lt;/li> let refHero = document.querySelectorAll('li')[2]; //將新的節點&lt;li>插到參考節點前面 heros.insertBefore(newHero,refHero); Node.replaceChild(newChildNode,oldChildNode)Node.replaceChild(newChildNode,oldChildNode) 可以將原本的節點及內容更換為新的節點及內容。 &lt;div id=\"sword\"> &lt;ul id=\"fiveHero\"> &lt;li id=\"firstHero\">1 東邪&lt;/li> &lt;li id=\"secondHero\">2 西毒&lt;/li> &lt;li ids=\"thirdHero\">3 南帝&lt;/li> &lt;li id=\"fifthHero\">4 北丐&lt;/li> &lt;li id=\"lastHero\">5 中神通&lt;/li> &lt;/ul> &lt;/div> //取得父容器節點 let heros = document.getElementById('fiveHero'); //建立新節點&lt;li> let newHero = document.createElement('li'); //建立新的文字節點 let newHeroTxt=document.createTextNode('5 中頑童'); //將文字節點加入newHero元素節點 newHero.appendChild(newHeroTxt); //抓取參考的節點&lt;li id=\"lastHero\">5 中神通&lt;/li> let oldHero = document.getElementById('lastHero'); heros.replaceChild(newHero,oldHero); Node.removeNode(childNode)那要如何刪除元素節點呢?利用 Node.removeNode(childNode) 就可以辦到！但是這個方法只能刪除單一網頁節點。 &lt;ul id=\"fiveHero\"> &lt;li>1 東邪&lt;/li> &lt;li>2 西毒&lt;/li> &lt;li>3 南帝&lt;/li> &lt;li>4 北丐&lt;/li> &lt;li>5 中神通&lt;/li> &lt;/ul> //取得父容器節點 let heros = document.getElementById('fiveHero'); //取得要移除的元素節點 let removeHero = document.querySelectorAll('li')[1]; //將heros裡的removeHero移除 heros.removeChild(removeHero); 以上就是改變HTML架構的方法，新增一個元素節點或文字節點，將其新增、替換原本就有的節點，或是清除本來就有的節點。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day21:比較Nodelist與HTML collection的差異","slug":"21-day21-nNodelistAndHTMLcollection","date":"2021-09-21T01:06:36.000Z","updated":"2022-04-17T18:38:58.000Z","comments":true,"path":"2021/09/21/21-day21-nNodelistAndHTMLcollection/","link":"","permalink":"https://popeye-ux.github.io/2021/09/21/21-day21-nNodelistAndHTMLcollection/","excerpt":"前面提到透過DOM API取得網頁節點的方法：","text":"前面提到透過DOM API取得網頁節點的方法： //根據傳入的id 名稱，找到DOM裡面相同id名稱的節點。 document.getElementById('idName'); //根據傳入的tag名稱，回傳所有符合條件的NodeList物件。 document.getEleMentsByTagName('tagName'); //根據傳入的class名稱,回傳所有符合條件的NodeList物件。 document.getElementsByClassName('className') //根據所設定的selector條件(class或id都可以)，回傳第一個符合條件的節點。 document.querySelector('selector'); //根據所給定的selector條件，回傳所有符合條件的 NodeList。 document.querySelectorAll; 由以上方法所回傳的可能會有以下三種節點： HTML元素節點(element nodes) 文字節點(text node)，包含空白 註解節點(comment node) getElementById與querySelector都是取得單一元素或節點，沒有 index 及 length 屬性。 DOM提供2種節點集合，用於容納多個節點： HTML collection：由「document.getElementsByTagName()」及「document.getElementsByClassName」查詢後回傳，HTML Collection只收集HTML 元素節點，這個集合不是陣列，不能使用陣列型別所提供的方法，但是有陣列索引(index)及length屬性可以使用，是一個有序的動態集合。 NodeList：由「document.querySelectorAll()」查詢後回傳，除了HTML節點外，也包括文字節點、屬性節點，這個集合同樣不是陣列，不能使用陣列所提供的方法，但是有陣列索引(index)及length屬性可以使用。 HTML Collection是一個動態的集合，節點的變動會及時反應在集合中。 &lt;div id=\"sword\"> &lt;ul id=\"fiveHero\"> &lt;li id=\"firstHero\">1 東邪&lt;/li> &lt;li id=\"secondHero\">2 西毒&lt;/li> &lt;li id=\"thirdHero\">3 南帝&lt;/li> &lt;li id=\"fifthHero\">4 北丐&lt;/li> &lt;li id=\"lastHero\">5 中神通&lt;/li> &lt;/ul> &lt;/div> var outside = document.getElementById('fiveHero'); var collection = document.getElementsByTagName('li'); console.log(collection.length); //5 得出5個HTML元素節點 console.log(collection[1].textContent); //\"2 西毒\" //清空&lt;ul id=\"fiveHero\">下面的節點 outside.innerHTML = ''; console.log(collection.length); //0 即時更新為0個元素節點 本來抓取到的HTML collection集合中有5個&lt;li&gt;元素，但是我們用outside.innerHTML &#x3D;’’清空之後，再console.log(collection.length)一次，已經即時更新為0個了。 NodeList大部分都是即時更新的，由childNodes屬性返回的NodeList物件是一個動態的集合，但是透過document.querySelectorAll() 及 document.querySelector()取得的NodeList是靜態的集合。 &lt;div id=\"sword\"> &lt;ul id=\"fiveHero\"> &lt;li id=\"firstHero\">1 東邪&lt;/li> &lt;li id=\"secondHero\">2 西毒&lt;/li> &lt;li id=\"thirdHero\">3 南帝&lt;/li> &lt;li id=\"fifthHero\">4 北丐&lt;/li> &lt;li id=\"lastHero\">5 中神通&lt;/li> &lt;/ul> &lt;/div> var outside = document.querySelector('ul'); var list = document.querySelectorAll('li'); //抓取所有&lt;li>元素節點 console.log(list.length); //5 console.log(list[2].textContent); //\"3 南帝\" //清空&lt;ul id=\"fiveHero\">下面的節點 outside.innerHTML = ''; console.log(list.length); //5 沒有即時更新狀態 「outside.innerHTML &#x3D; ‘’」清空了底下的&lt;li&gt;元素，但是 console.log(list.length)仍然為5，沒有更新為0，所以 document.querySelector() 回傳的是一個靜態的集合。 But 人生最厲害的就是那個but！由 childNodes 屬性返回的 NodeList 物件是一個動態的集合，可以即時更新集合的狀態。 &lt;div id=\"sword\"> &lt;ul id=\"fiveHero\"> &lt;li id=\"firstHero\">1 東邪&lt;/li> &lt;li id=\"secondHero\">2 西毒&lt;/li> &lt;li id=\"thirdHero\">3 南帝&lt;/li> &lt;li id=\"fifthHero\">4 北丐&lt;/li> &lt;li id=\"lastHero\">5 中神通&lt;/li> &lt;/ul> &lt;/div> var outside = document.querySelector('ul'); console.log(outside.childNodes.length); //5 console.log(outside.childNodes); // [object NodeList] (11) //[\"#text\",\"&lt;li/>\",\"#text\",\"&lt;li/>\",\"#text\",\"&lt;li/>\",\"#text\",\"&lt;li/>\",\"#text\",\"&lt;li/>\",\"#text\"] outside.innerHTML = ''; console.log(outside.childNodes.length); //0 我們抓取了&lt;ul&gt;，存在變數 outside 裡面，利用 coconsole.log() 查詢它 childNodes 的長度，然後清空了outside裡面的內容，再查詢一次childNodes.length，果然即時更新變成0了。 HTML collection 還有一個 nameItem() 方法，可以返回集合中 name 屬性和 id 屬性值的元素。 &lt;div id=\"sword\"> &lt;ul id=\"fiveHero\"> &lt;li id=\"firstHero\">1 東邪&lt;/li> &lt;li id=\"secondHero\" name=\"1\">2 西毒&lt;/li> &lt;li id=\"thirdHero\">3 南帝&lt;/li> &lt;li id=\"fifthHero\">4 北丐&lt;/li> &lt;li id=\"lastHero\">5 中神通&lt;/li> &lt;/ul> &lt;/div> var one = document.getElementsByTagName('li').namedItem('firstHero'); var two = document.getElementsByTagName('li').namedItem('2'); console.log(one); //&lt;li id=\"firstHero\">1 東邪&lt;/li> console.log(two); //&lt;li id=\"secondHero\" name=\"2\">2 西毒&lt;/li>","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day20:文件物件模型--DOM","slug":"21-day20-DOM","date":"2021-09-20T00:31:16.000Z","updated":"2022-04-14T09:32:32.000Z","comments":true,"path":"2021/09/20/21-day20-DOM/","link":"","permalink":"https://popeye-ux.github.io/2021/09/20/21-day20-DOM/","excerpt":"BOM(Browser Object Model 瀏覽器物件模型)的重點在於瀏覽器的功能，完全由各家瀏覽器廠商自行開發。而DOM(Document Object Model 文件物件模型)則是W3C所制定的共同文件規範，提供跨瀏覽器且標準的文件處理介面。","text":"BOM(Browser Object Model 瀏覽器物件模型)的重點在於瀏覽器的功能，完全由各家瀏覽器廠商自行開發。而DOM(Document Object Model 文件物件模型)則是W3C所制定的共同文件規範，提供跨瀏覽器且標準的文件處理介面。 DOM(Document Object Model 文件物件模型)，是一個有階層的樹狀結構，一個節點就是一個標籤，根節點下有子節點，子節點下還有子節點，形成上下結構的關係，這樣的樹狀結構，我們稱之為「DOM Tree」。 《0陷阱！0誤解！8天重新認識JavaScript》一書中有提到： 「DOM API定義了讓JavaScript可以存取、改變HTML架構、樣式和內容的方法，甚至對節點綁定的事件。」 當瀏覽器載入一個網頁時，瀏覽器會分析這個網頁的HTML，依照它的HTML結構建立一個DOM Tree。DOM的學習重點就在於掌握節點根結點之間的關係，學會如何控制DOM就可以控制網頁 做出良好的互動體驗。 如何透過DOM API取得節點： //根據傳入的id 名稱，找到DOM裡面相同id名稱的節點。 document.getElementById('idName'); //根據傳入的tag名稱，回傳所有符合條件的NodeList物件。 document.getEleMentsByTagName('tagName'); //根據傳入的class名稱,回傳所有符合條件的NodeList物件。 document.getElementByClassName('className') //根據所設定的selector條件(class或id都可以)，回傳第一個符合條件的節點。 document.querySelector('selector'); //根據所給定的selector條件，回傳所有符合條件的 NodeList。 document.querySelectorAll; 假設網頁上有一個h1的標籤節點，裡面沒有任何內容： &lt;h1 id=\"hello\">&lt;/h1> 我們利用document.getElementById(‘hello’)來取得#hello節點，然後修改textContent屬性： document.getElementById('hello').textContent = '郭靖在華山論劍向大家說 Hello World!' 這就是取得節點，改變HTML內容的方法。 你有發現嗎？不管是document.getElementById(‘idName’) 或是document.querySelector(‘selector’)都是由document開頭。讓我們來看看DOM Tree的圖，可以發現document是整個DOM Tree的根結點，所以在存取DOM節點時，都要從document出發。 我們觀察一下DOM Tree的圖可以發現，節點之間有上下分層的關係，也有同一層節點間相鄰的關係，所以節點與節點之間的關係可以區分為： 父子關係：document在最上層，其他的節點若有上層的節點，上層的節點稱為「父節點」(Parent Node)，下層的節點稱為「子節點」(Child Node)。就像王陽明的徒弟是「全真七子」，而全真七子之一的丘處機，他的徒弟是尹志平等人。 兄弟關係：同一層的節點如果它們有同一個「父節點」，那它們之間就是「兄弟關係」，就像王陽明的徒弟「全真七子」，他們之間是師兄弟關係。 Node.childNodes「所有的DOM節點物件都有childNodes屬性，且這種屬性無法修改」，那我們要如何知道一個節點是否有子節點? 這時候可以利用Node.hasChildNodes()來檢查： &lt;div id=\"sword\"> &lt;ul> &lt;li>1 東邪&lt;/li> &lt;li>2 西毒&lt;/li> &lt;li>3 南帝&lt;/li> &lt;li>4 北丐&lt;/li> &lt;li>5 中神通&lt;/li> &lt;/ul> &lt;/div> var node = document.getElementById('sword'); if(node.hasChildNodes())&#123; for(var i=0; i &lt;node.childNodes.length; i++) console.log(i + node.childNodes[i].nodeName); &#125; 來看一下console出來的結果： cosole視窗中列出了查詢的結果，我為查詢的節點加上了編號，除了”LI”之外，還出現了”0#text”之類的字串，這是因為換行符號的空白節點也被查詢了出來。如果不換行的話，”0#text”就不會出現。 Node.firstChildNode.firstChild用來取得Node節點的第一個子節點，如果沒有子節點的話，則回傳null。而子節點包括空白節點，例如HTML Tag之間的換行符號。 &lt;div id=\"sword\"> &lt;ul id=\"fiveHero\">&lt;li class=\"firstHero\">1 東邪&lt;/li>&lt;li>2 西毒&lt;/li>&lt;li>3 南帝&lt;/li>&lt;li>4 北丐&lt;/li>&lt;li>5 中神通&lt;/li> &lt;/ul> &lt;/div> var node = document.getElementById('fiveHero'); console.log(node.firstChild.className); //firstHero Node.lastChildNode.lastChild可以取得Node節點的最後一個子節點，如果沒有子節點的話，則一樣是傳回null。而子節點包括空白節點，例如HTML Tag之間的換行符號。 &lt;div id=\"sword\"> &lt;ul id=\"fiveHero\">&lt;li class=\"firstHero\">1 東邪&lt;/li>&lt;li>2 西毒&lt;/li>&lt;li>3 南帝&lt;/li>&lt;li>4 北丐&lt;/li>&lt;li class=\"lastHero\">5 中神通&lt;/li>&lt;/ul> &lt;/div> var node = document.getElementById('fiveHero'); console.log(node.lastChild.className); //\"lastHero\" Node.parentNodeNode.parentNode可以取得Node節點的父節點。 &lt;div id=\"sword\"> &lt;ul id=\"fiveHero\">&lt;li class=\"firstHero\">1 東邪&lt;/li>&lt;li>2 西毒&lt;/li>&lt;li>3 南帝&lt;/li>&lt;li>4 北丐&lt;/li>&lt;li class=\"lastHero\">5 中神通&lt;/li>&lt;/ul> &lt;/div> var node = document.getElementById('fiveHero'); console.log(node.parentNode.tagName); //\"DIV\" Node.previousSibling有同一個父元素，位於同一層的節點稱為「兄弟節點」，而Node.previousSibling可以取得Node節點的前一個兄弟節點。 &lt;div id=\"sword\"> &lt;ul id=\"fiveHero\"> &lt;li class=\"firstHero\">1 東邪&lt;/li>&lt;li class=\"secondHero\">2 西毒&lt;/li>&lt;li class=\"thirdHero\">3 南帝&lt;/li>&lt;li class=\"fifthHero\">4 北丐&lt;/li>&lt;li class=\"lastHero\">5 中神通&lt;/li> &lt;/ul> &lt;/div> var node = document.querySelector('.secondHero'); console.log(node.previousSibling.className); //\"firstHero\" Node.nextSiblingNode.nextSibling可以取得Node節點的下一個兄弟節點。 &lt;div id=\"sword\"> &lt;ul id=\"fiveHero\"> &lt;li class=\"firstHero\">1 東邪&lt;/li>&lt;li class=\"secondHero\">2 西毒&lt;/li>&lt;li class=\"thirdHero\">3 南帝&lt;/li>&lt;li class=\"fifthHero\">4 北丐&lt;/li>&lt;li class=\"lastHero\">5 中神通&lt;/li> &lt;/ul> &lt;/div> var node = document.querySelector('.secondHero'); console.log(node.nextSibling.className); //\"thirdHero\" 由上面幾個操作，可以知道透過節點的抓取，我們可以取得節點的資訊，進而改變網頁的結構、內容以及樣式，懂得控制節點，就可以控制網頁的呈現與使用者互動。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day19:瀏覽器物件模型--BOM","slug":"21-day19-BOM","date":"2021-09-19T00:28:53.000Z","updated":"2022-04-14T09:30:38.000Z","comments":true,"path":"2021/09/19/21-day19-BOM/","link":"","permalink":"https://popeye-ux.github.io/2021/09/19/21-day19-BOM/","excerpt":"我們學習前端語言就是為了跟瀏覽器溝通，讓網頁可以渲染出想要的效果，創造使用者互動的良好體驗。所以要跟瀏覽器溝通必須要熟悉HTML、CSS與JavaScript三種技術（有些看法不認為HTML與CSS是程式語言）。","text":"我們學習前端語言就是為了跟瀏覽器溝通，讓網頁可以渲染出想要的效果，創造使用者互動的良好體驗。所以要跟瀏覽器溝通必須要熟悉HTML、CSS與JavaScript三種技術（有些看法不認為HTML與CSS是程式語言）。 HTML、CSS、JavaScript分別扮演這三種角色： HTML負責網頁的結構與內容 CSS負責網頁的外觀與樣式 JavaScript負責網頁的互動與行為 我們透過這三種技術與網頁溝通，讓網頁的渲染引擎把我們寫的網頁渲染出來，前端語言在網頁上的操作方法都是由瀏覽器所提供的。也就是藉由操控BOM(Browser Object Model 瀏覽器物件模型)與旗下的DOM(Document Object Model 文件物件模型)所提供的API來加以實現。 雖然每家瀏覽器廠商的作法可能不太相同，但在瀏覽器上基本都遵循ECMA標準所提供的JavaScript來進行操作。 所以BOM(Browser Object Model)是甚麼呢？ BOM(Browser Object Model 瀏覽器物件模型)是瀏覽器提供的物件，也是瀏覽器所有功能的核心，但是它與網頁的內容無關。例如開啟關閉視窗、彈跳警告方塊、取得位址…. BOM 的核心是 window 物件，而 window 物件提供的屬性主要為 document、location、navigator、screen、history 以及 frames。 window物件在瀏覽器中扮演著兩種角色： ECMA標準裡的「全域物件」(Global Object) JavaScript用來與瀏覽器溝通的橋樑 我們一開始寫JavaScript最常寫的alert() alert('洪七公和歐陽鋒牽手說：「We are the world!」'); 我們常常省略alert()前面的window，其實它作為全域物件的屬性應該是寫成這樣： window.alert('洪七公和歐陽鋒牽手說：「We are the world1」'); 而你在全域範圍所下的變數： var man = '郭靖'; console.log(window.man); //郭靖 在全域範圍所宣告的變數、物件、函式，都是全域物件window的屬性，只是我們通常都把前面的window省略不打。 讓我們來看看常用的window屬性 window.screen當我們在瀏覽器的console視窗打了window.screen可以得到以下資訊： window.location而在瀏覽器的console視窗打了window.location會出現href的訊息： window.navigator而在瀏覽器的console視窗打了window.navigator會出現瀏覽器的相關資訊：","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day18:期間限定：函式的參數","slug":"21-day18-parameter","date":"2021-09-18T00:26:52.000Z","updated":"2022-04-14T09:28:16.000Z","comments":true,"path":"2021/09/18/21-day18-parameter/","link":"","permalink":"https://popeye-ux.github.io/2021/09/18/21-day18-parameter/","excerpt":"函式會將參數傳入函式裡面，讓它們成為函式裡的變數，讓程式碼去做運算。參數只能在函式裡刷存在感（期間限定?），一旦函式執行完畢，就會被消失。(Mission Impossible音樂響起……)","text":"函式會將參數傳入函式裡面，讓它們成為函式裡的變數，讓程式碼去做運算。參數只能在函式裡刷存在感（期間限定?），一旦函式執行完畢，就會被消失。(Mission Impossible音樂響起……) arguments物件一般的函式長成這個樣子： const multiply = function funA(numA, numB)&#123; return numA + numB; &#125; //呼叫multiply()函式 multiply(1,2) //2 plus(1,2)，小括號中的1跟2就是參數，傳到multiply這個函式，numA就是1，numB就是2，傳出來的值就是2。 JavaScript呼叫函式的時候，不會對函式的數量做檢查，超過函式小括號裡面函式數量的參數，沒有配對到的就會被以undefined定義。如果呼叫函式的時候，參數數量少於函式小括號裡面定義的數量，也會以undefined表示。 如果擔心呼叫函式的時候，傳入函式的參數少於函式定義的參數數量，沒有配對到的參數會變成undefined，也可以幫參數指定預設值。 const plus = function funA(numA = 0, numB = 0)&#123; return numA + numB; &#125; //呼叫plus()函式 plus(5) //2 當函式被呼叫的時候，會生成一個arguments物件，裡面的放的就是呼叫函式的時候，小括號裡面放的「參數」。 argruments物件並非陣列，它是帶有「索引」特性的物件，擁有length屬性，而且只能在函式裡面使用。這意味著：就算我們呼叫函式時帶入的變數數量超過原本函式設定的數量，也可以利用迴圈把超過預設數量的變數撈出來運算，還可以透過使用arguments物件讓函式能夠呼叫數量不定的引數 const plus = function (numA,numB)&#123; var num = 0; console.log(arguments.length); for( var i = 0; arguments.length > i; i++ )&#123; num += arguments[i]; &#125; return num; &#125; //呼叫plus()函式 plus(1,2,3,4,5,6) //console.log(arguments.length)會跑出6 //然後參數相加的部分會跑出21 其餘參數(…args)前面提到的箭頭函式，並沒有arguments物件可以使用，但是ES6提供了「其餘參數」(rest parameter)讓箭頭函式來使用。 只要在函式的小括號中以…三個點開頭，後面接上參數名稱，就變成了「其餘參數」(rest parameter)，所有參數都存在裡面。而且「其餘參數」是一個陣列，所有陣列的方法它都可以使用。 const plus = (...args) => &#123; var num = 0; console.log(args.length); for( var i = 0; args.length > i; i++ )&#123; num += args[i]; &#125; return num; &#125; //呼叫plus()函式 plus(1,2,3,4,5,6) //console.log(args.length)會跑出6 //然後參數相加的部分會跑出21 arguments物件與 …args其餘參數都讓函式在取用參數的時候，不用拘泥於原本定義的參數數量，讓參數的使用有更大的彈性與擴充性。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day17:箭頭函式","slug":"21-day17-arrowFunction","date":"2021-09-16T17:29:49.000Z","updated":"2022-04-14T09:26:30.000Z","comments":true,"path":"2021/09/17/21-day17-arrowFunction/","link":"","permalink":"https://popeye-ux.github.io/2021/09/17/21-day17-arrowFunction/","excerpt":"","text":"箭頭函式可以讓函式的寫法變得十分精簡！ 一般我們見到的函式長成這個樣子： var fight = function(nameA, nameB) &#123; return nameA + '打敗' + nameB; &#125; fight('洪七公','歐陽鋒'); //洪七公打歐陽鋒 但是從ES6之後，增加了一種「箭頭函式表達式」(Arrow Function expression)，可以使用它來簡化函式的表達，讓我們一步一步還簡化： 把function刪除，在()小括號後面加上&#x3D; &gt;，其他保持原樣。 var fight = (nameA, nameB) => &#123; return nameA + '打敗' + nameB; &#125; fight('洪七公','歐陽鋒'); //洪七公打歐陽鋒 跟著進一步簡化，把{}拿掉，也把return省略掉： var fight = (nameA, nameB) => nameA + '打敗' + nameB; fight('洪七公','歐陽鋒'); //洪七公打歐陽鋒 當函式只有一個參數的時候，小括號()可以省略： var fight = nameA => console.log(nameA + '武功天下第一'); fight('洪七公'); //洪七公武功天下第一 但是沒有參數時，小括號()是不能省略的： var fight = () => console.log('洪七公武功天下第一'); fight(); //洪七公武功天下第一 箭頭函式的精簡寫法在乍看之下讓人一頭霧水，但是拆解之後，卻是簡單又一目了然，這種寫法應該很多人會喜歡用。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day16:公園跟你家院子—全域變數與區域變數的區別","slug":"21-day16-globalAndScope","date":"2021-09-15T17:27:45.000Z","updated":"2022-04-14T02:33:08.000Z","comments":true,"path":"2021/09/16/21-day16-globalAndScope/","link":"","permalink":"https://popeye-ux.github.io/2021/09/16/21-day16-globalAndScope/","excerpt":"JavaScript的變數依使用的切分範圍（作用域）可以分為兩種：","text":"JavaScript的變數依使用的切分範圍（作用域）可以分為兩種： 區域變數 全域變數 前面提到透過var宣告的變數，最小的切分範圍為function，在函式內宣告的變數只能在函式內部使用，無法由外層叫用，其他的函式也不能使用，當函式執行完之後，變數就由記憶體中清除。這就是「區域變數」。 而在外層用var宣告的變數則為「全域變數」，即使寫在function裡面，沒用var宣告的變數都是「全域變數」。就如同前面有提到的，function內可以去捉外層的變數來用，而外層無法捉到function內的變數來用，也就是說「全域變數」是大家公用的。而「區域變數」則只能在function內使用。 舉個簡單的例子，公園裡的盪鞦韆，大家都可以去玩，這就是「全域變數」；但是你家院子裡的盪鞦韆，外面的人沒辦法進來玩，就是「區域變數」。 而其實「全域變數」指的是「全域物件」的屬性，以瀏覽器來說，「全域物件」就是window物件，window物件的部分在提到BOM的時候會再詳細解釋，我們先知道就好。 var man = '郭靖'; console.log(window.man); //郭靖 「var man &#x3D; ‘郭靖’」變成window物件的屬性了。 而使用var宣告的全域變數，無法使用delete關鍵字刪除。 var man = '郭靖'; console.log(window.man); delete window.man //false console.log(window.man); // 郭靖 但是透過window宣告的全域變數，卻可以使用delete刪除。 window.man = '郭靖'; console.log(window.man); delete window.man //true console.log(window.man); // undefined 這一點是需要特別注意的。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day15:變數的地盤—作用域(scoop)與提升(Hoisting)","slug":"21-day15-scoopHoisting","date":"2021-09-15T09:17:36.000Z","updated":"2022-04-13T18:35:12.000Z","comments":true,"path":"2021/09/15/21-day15-scoopHoisting/","link":"","permalink":"https://popeye-ux.github.io/2021/09/15/21-day15-scoopHoisting/","excerpt":"作用域(scoop)簡單來說，就是變數的地盤，在地盤內，變數都有作用，出了地盤，變數就undefined了。","text":"作用域(scoop)簡單來說，就是變數的地盤，在地盤內，變數都有作用，出了地盤，變數就undefined了。 舉個不倫不類的例子，丐幫的幫主洪七公武功再強也沒有辦法命令桃花島黃老邪的弟子梅超風去烤一隻土窯雞來吃。因為根本就不同門不同派。 那要怎麼區分變數的範圍呢？ 在ES6之前，切分變數最小的範圍是function為單位，函式裡面的變數只能存活在函式裡面。 在ES6之後，可以使用let、const來定義變數，這種狀況下切分變數最小範圍則為{}大括號區塊。 var man = '歐陽克'; var marriage = function ()&#123; var man = '郭靖'; return man + '娶了黃蓉'; &#125; console.log(marriage()); //郭靖娶了黃蓉 console.log(man); //歐陽克 好險！歐陽克娶不到黃蓉！ 因為使用var定義變數man，前面提到作用域最小的範圍是function，所以marriage()會去捉「var man &#x3D; ‘郭靖’ 」來用，而不會去抓外層的「 var man &#x3D; ‘歐陽克’」來用。 var man = '歐陽克'; var marriage = function ()&#123; return man + '娶了黃蓉'; &#125; console.log(marriage()); //歐陽克娶了黃蓉 console.log(man); //歐陽克 糟糕！歐陽克娶了黃蓉…郭靖哭哭！ 但是如果在marriage()裡面找不到「var man &#x3D; ‘郭靖’」，就會往外層去找，此時「var man &#x3D; ‘歐陽克’」就會被捉來用了！郭靖真的會哭！ 在外層console.log(man)一直都是歐陽克是因為，切分變數最小的範圍是function，所以「var man &#x3D; ‘郭靖’ 」的作用域只在marriage()函式裡面，如果marriage()裡面找不到，才會往外層找，一直找到作外層的全域變數，所以console.log(man)才會一直都是’歐陽克’。如果都找不到就會報錯：ReferenceError：man is not defined 情人眼裡出西施！但重點是你要先進入情人的眼裡（作用域）！不管她的眼界是「全域」還是「區域」。 所以我們要記得： ES6之前，切分變數最小範圍是function。 function可以捉外層變數還使用，但是從外層捉不到function內的變數。 提升(Hoisting)繼續來看看郭靖有沒有辦法跟黃蓉有情人終成眷屬！ var man = '歐陽克'; var marriage = function ()&#123; console.log(man); //undefined var man = '郭靖'; return man + '娶了黃蓉'; &#125; console.log(marriage()); //郭靖娶了黃蓉 console.log(man); //歐陽克 我們在「var man &#x3D; ‘郭靖’」前面加了一個console.log(man)，雖然「var man &#x3D; ‘郭靖’」宣告在後面，但是console.log(man)並沒有去外層抓「var man &#x3D; ‘歐陽克’」來用。 那是因為console.log(man)和「var man &#x3D; ‘郭靖’」在同一個作用域，只要確認後面 man這個變數有宣告，那就會宣告變數這件事提到上面來，然後先給它一個undefined的值。 var man = '歐陽克'; var marriage = function ()&#123; console.log(man); //Uncaught ReferenceError: Cannot access 'man' before initialization let man = '郭靖'; return man + '娶了黃蓉'; &#125; console.log(marriage()); console.log(man); 如果是使用 let來宣告「let man &#x3D; ‘郭靖’」，在還沒宣告前，使用console.log(man)來查詢，就會報錯：Uncaught ReferenceError: Cannot access ‘man’ before initialization。因為let和const不允許在宣告卻沒有初始化的狀況下使用，從宣告到初始化這中間的時間差稱為「暫時死區」(Temporal Dead Zone)(TDZ)。 所以在這裡提一下重點： let&#x2F;const 是使用區塊作用域，以一對大括號{}為單位；var 是使用函式(function)作用域 在 let&#x2F;const 宣告之前就存取對應的變數與常數，會拋出ReferenceError錯誤；但在 var 宣告之前就存取對應的變數，則會得到undefined 綜上所述，最好在作用域(scope)的一開始就宣告好所有的變數再使用，避免發生慘案。 函式的提升前面提到的是用var設參數的提升，還有一種是「函式的提升」。 而透過「函式宣告」的方式建立的函式，也可以在前面叫用，後面再宣告函式。 marriage('郭靖'); //\"郭靖娶了黃蓉\" function marriage(man) &#123; return man + '娶了黃蓉'; &#125; 而「函式表達式」就沒這樣的待遇了，提前叫用只會出現：TypeError。 變數的提升只有宣告被提升，但是沒有初始化。但是函式的提升則是函式的內容整個被提升。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day14:return的妙傳得分","slug":"21-day14-return","date":"2021-09-14T09:12:51.000Z","updated":"2022-04-13T18:16:16.000Z","comments":true,"path":"2021/09/14/21-day14-return/","link":"","permalink":"https://popeye-ux.github.io/2021/09/14/21-day14-return/","excerpt":"當我們在Chrome的console視窗鍵入如下程式碼，執行一個say()的函式，除了console.log 列印出 Hello World! 之外，下列有個往左的灰色箭頭接著undefined，這個 undefined 就是函式表達式的回傳值。","text":"當我們在Chrome的console視窗鍵入如下程式碼，執行一個say()的函式，除了console.log 列印出 Hello World! 之外，下列有個往左的灰色箭頭接著undefined，這個 undefined 就是函式表達式的回傳值。 回傳值(return value)就是函式表達式輸出的值，可以讓其他的程式碼取用。在say()這個函式裡，並沒有要它回傳任何值，只要求它console.log在控制台印出Hello World!，並沒有回傳任何值。等於是打籃球時都是自幹自的，不往外傳與隊友合作得分。 我們在 say 函式中加入 return “Hello World!” 這一串，告訴它把值傳出來。 結果可以看到，往左邊的箭頭之後接的灰色 undefined變成紅色的”Hello world!”了。 函式表達式的輸出值叫做回傳值( return value )，在呼叫帶有回傳值的函式的時候，可以把回傳值儲存在變數中，與其他程式碼結合使用，或是傳遞給另一個函式使用。 在square這個函式中，帶入number這個參數，讓number相乘。 接著在下面呼叫square函式，帶入square(2)當參數，所以等於是先算 2 * 2 &#x3D; 4，再把值傳給外層的square函式，算出4 * 4 &#x3D; 16。 函式可以接受多個參數，卻只能回傳一個值，如果沒告訴它要回傳什麼，它就回傳undefined。 而return的另一個妙用，就是用來中斷函式的執行：「如果函式的任一個參數無效，就提前跳出函式。無效指的是，參數不是函式正常執行所需的那種參數。」 var nickName = function(name)&#123; if(name==='歐陽鋒')&#123; return; &#125; return name; &#125; nickName('郭靖'); //郭靖 nickName('歐陽鋒'); //undefined 跳出函式 所以return也可以拿來中斷函式的執行喔。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day13:能力封裝–函式","slug":"21-day13-function","date":"2021-09-13T08:48:10.000Z","updated":"2022-04-13T18:36:20.000Z","comments":true,"path":"2021/09/13/21-day13-function/","link":"","permalink":"https://popeye-ux.github.io/2021/09/13/21-day13-function/","excerpt":"函式的作用在於將一段或多段函式包裝在一起，方便反覆使用，一目了然也方便維護。當需要重複執行一次計算或重複做一件事的時候，就會需要用到函式。","text":"函式的作用在於將一段或多段函式包裝在一起，方便反覆使用，一目了然也方便維護。當需要重複執行一次計算或重複做一件事的時候，就會需要用到函式。 像這樣就是一個函式： function firstFun () &#123; console.log('桃花島的五行八卦陣'); &#125; 函式執行前要先被定義，但是定義好的函式不會自動執行，要在程式中呼喊愛情，啊！不對！是呼叫函式，函式才會動起來！ 最常見的函式宣告方式有以下三種： 函式宣告(Function Declaration) 函式表達式(Function Expression) 透過new Function關鍵字建立函式 函式宣告(Function Declaration)function 函式名稱 (參數1, 參數2...)&#123; //do something &#125; 用function開頭，後面接著函式名稱。 ()小括號中放的式參數，參數可以不只一個，每個參數中間以逗號 「,」隔開。 {}大括號中放的是執行的程式內容。 我們已可以把參數帶入function中使用： function firstFun (name) &#123; console.log( name + '闖入桃花島的五行八卦陣'); &#125; firstFun('郭靖') //郭靖闖入桃花島的五行八卦陣 函式表達式(Function Expression)函式表達式長這個樣子： var 變數名稱 = function 函式名稱()&#123; //do something &#125; 函式表達式清楚地展示了如何將一個函式儲存在一個變數中，從而透過變數我們可以反覆地叫用函式。函式的名稱只有在「自己函式的區塊內」有效，離開這個函式的範圍，函式的名稱就失去了效用。 透過「變數名稱()」就可以呼叫函式，所以「函式名稱」不是一定要的，這種沒有名字的函式在JavaScript是允許的，通常被稱為「匿名函式」。 var 變數名稱 = function ()&#123; //do something &#125; var firstFun = function (name) &#123; console.log( name + '闖入桃花島的五行八卦陣'); &#125; firstFun('郭靖') //郭靖闖入桃花島的五行八卦陣 透過new Function關鍵字建立函式第三種則是透過 new關鍵字 + Function的方式來建立函式物件。 var 變數名稱 = new Fnction ('參數','do something') 因為這種方式，每次執行都要解析字串，效能甚差，實務上很少使用。 return對一個新手而言，剛遇到這個return實在是丈二金剛摸不著腦？return到底是要轉到哪裡去？ 後來搞懂了，原來函式執行後，return會中止程式執行並回傳一個值(value)，如果沒有值可以回傳，則會會傳undefined。 var funNoReturn = function square(num)&#123; num * num; &#125; funNoReturn(2); //undefined 沒有回傳值，所以undefined var funReturn = function square(num)&#123; return num * num; &#125; funReturn(2); //4 加上retrurn之後，就有回傳值了 回傳值是函式輸出的值，可以帶入其他的程式碼中繼續運算。函式可以接受多個參數，但是只能回傳一個值，如果沒有告訴函是要回傳什麼，就會回傳undefined。 也可以把函式呼叫當作值來使用： var funReturn = function square(num)&#123; return num * num; &#125; funReturn(2) + funReturn(3); //13 我們也可以利用return來結束函示執行，如果函式的任意一個參數無效，就提前跳出函式。無效指的是，參數不符合函式所定義的條件。 var fun = function (num)&#123; if(num > 5)&#123; return; &#125; return num * num; &#125; fun(6); //undefined fun(2); //\"4\" fun(6)因為num &gt;5，參數符合if條件 ，就執行{}內程式碼，return跳出了函式，回傳undefined。 fun(2)因為num&lt;5，參數不符合if條件，所以繼續往下執行return num * num，回傳值為4。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day12:忙得團團轉的迴圈","slug":"21-day12-loop","date":"2021-09-12T05:05:07.000Z","updated":"2022-04-13T14:06:06.000Z","comments":true,"path":"2021/09/12/21-day12-loop/","link":"","permalink":"https://popeye-ux.github.io/2021/09/12/21-day12-loop/","excerpt":"迴圈指的是「重複做某件事，次數隨著數值『遞增」或『遞減』，當數值滿足所設的條件，則退出迴圈」。","text":"迴圈指的是「重複做某件事，次數隨著數值『遞增」或『遞減』，當數值滿足所設的條件，則退出迴圈」。 所以當我們要「重複做某件事」的時候，第一個進入腦海中的方法應該就是迴圈。例如console.log(1)到(9)、求某數值範圍的平方或是九九乘法表之類的。 最常見的迴圈有 for 與 while 兩種。 for迴圈for迴圈的語法如下： for(var i = 0; i &lt; n; i++ )&#123; /執行某件事 &#125; var i &#x3D; 0; 是在設定初始值，變數i的有效範圍與for迴圈相同。 i &lt; n; 則是在為for迴圈設定條件，變數i的有效範圍跟for迴圈的有效範圍是相同的，一旦變數i滿足這個條件，迴圈就會結束。如果還為滿足就去執行{}內的程式敘述。 i++; 則在迴圈跑完一次時遞增，直到迴圈結束。 讓我們來試試看99乘法表該如何利用迴圈來執行： for (var = 1; i &lt;= 9; i++) &#123; for (var j = 1; j &lt;= 9; j++)&#123; console.log( i * j); &#125; &#125; while迴圈while迴圈通常長成這個樣子： var i = 0; while (i &lt; 10)&#123; /執行某個程式敘述 i++; &#125; var i &#x3D; 0; 設定初始值。 (i &lt; 10) 這定迴圈執行的條件。 i++;在{}的結尾處讓變數遞增或遞減，直到變數i滿足所設條件，結束迴圈。 讓我們試著用while迴圈來印出1~9的平方： var i = 1; while (i &lt;= 9) &#123; console.log(i * i); i++; &#125; while迴圈最常見的疏忽就是忘了在結尾設定變數遞增(i++)，結果造成條件一直無法滿足，於是無窮迴圈的一直執行下去。 那何時該用for迴圈？何時該用while迴圈呢？ 在《0陷阱！0誤解！8天重新認識JavaS》一書中有提到： 「 for迴圈的使用情境，大多是用在迴圈執行次數「明確」的狀態。 而while迴圈剛好相反，當迴圈執行次數「不確定」的時候更適合。 」 讓我們利用for迴圈來選出大樂透的號碼，有1到49個號碼，要選出6個不重複號碼： var lottery = []; var n; for (var i = 0; i &lt; 6; i++)&#123; n = Math.floor(Math.random() * 49) + 1; if ( lottery.indexOf(n) === -1)&#123; lottery.push(n); &#125; &#125; 49個號碼選出6個，執行次數6次，如果使用for迴圈，看起來就一目了然，是適合用for迴圈來執行的情境。 範例實作","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day11:「如果肚子餓了，就吃香蕉」--流程判斷邏輯","slug":"21-day11-ifElse","date":"2021-09-11T04:58:32.000Z","updated":"2022-04-13T14:00:32.000Z","comments":true,"path":"2021/09/11/21-day11-ifElse/","link":"","permalink":"https://popeye-ux.github.io/2021/09/11/21-day11-ifElse/","excerpt":"最簡單的流程控制，就是「如果」符合某個條件，就去做某件事，也就是if…else這樣的程式語法。","text":"最簡單的流程控制，就是「如果」符合某個條件，就去做某件事，也就是if…else這樣的程式語法。 就像「如果肚子餓了，就吃香蕉」，猴子嗎？ 例如：「打不過，逃！」這是江南七怪的老五南樵子在學生郭靖要出江湖闖蕩時，提醒郭靖的話。如果滿足「打不過」這個條件，就做「逃」這個動作。 if (條件式)&#123; //條件成立(true)的話，執行&#123; &#125;區塊內的內容 &#125; else &#123; //如果條件不成立(false)，執行&#123; &#125;區塊中的內容 &#125; 如果條件不只一個，可以使用 else…if 來新增條件。 if (條件式 1)&#123; //條件1成立(true)的話，執行&#123; &#125;區塊內的內容 &#125; else if (條件式 2)&#123; //條件2成立(true)的話，執行&#123; &#125;區塊內的內容 &#125; else if (條件式 3)&#123; //條件3成立(true)的話，執行&#123; &#125;區塊內的內容 &#125; else &#123; //如果上面的條件都不成立(false)，執行&#123; &#125;區塊中的內容 &#125; 回到郭靖的例子： var fight = '打到對方吐血'; if ('打不過' === true) &#123; fight = '逃'; &#125; 我想隨機選出1到7之間的數字，用來表示江南七怪的排行，例如數字等於1就印出「飛天蝙蝠–柯鎮惡」，數字等於2就印出「妙手書生–朱聰」，依此類推。 Math.random() 會隨機產生 0 到 1 之間的小數。 而 Math.ceil(x) 會將x無條件進位。 //Math.random() 會隨機產生 0 到 1 之間的小數。 而 Math.ceil(x) 會將x無條件進位。 if(Math.ceil(Math.random()*7)===1)&#123; console.log('飛天蝙蝠--柯鎮惡'); &#125; else if (Math.ceil(Math.random()*7)===2)&#123; console.log('妙手書生--朱聰'); &#125; else if (Math.ceil(Math.random()*7)===3)&#123; console.log('馬王神--韓寶駒'); &#125; else if (Math.ceil(Math.random()*7)===4)&#123; console.log('南山樵子--南希仁'); &#125; else if (Math.ceil(Math.random()*7)===5)&#123; console.log('笑彌陀--張阿生'); &#125; else if (Math.ceil(Math.random()*7)===6)&#123; console.log('鬧市俠隱--全金發'); &#125; else&#123; console.log('越女劍--韓小瑩'); &#125; 寫了這麼落落長的一段，看得眼都花了，if …. else ….也判斷了7次，就效能上來說比較差。 JavaScript還有另一種的switch條件判斷式，適合這樣的情況。 switch(Math.ceil(Math.random()*7))&#123; case 1: console.log('飛天蝙蝠--柯鎮惡'); break; case 2: console.log('妙手書生--朱聰'); break; case 3: console.log('馬王神--韓寶駒'); break; case 4: console.log('南山樵子--南希仁'); break; case 5: console.log('笑彌陀--張阿生'); break; case 6: console.log('鬧市俠隱--全金發'); break; case 7: console.log('越女劍--韓小瑩');; break; default: console.log('六怪陣亡，只剩老大飛天蝙蝠柯鎮惡'); break; &#125; switch括號中可以放入「運算式」、「變數」或「值」，如果符合case後面所列出來的條件，就執行那個case區塊的程式敘述。如果都不符合則執行default區塊的程式敘述。 當滿足case列出來的條件，執行完程式敘述，break指令會中指流程判斷，不去執行後面的case條件判斷。 參考資料switch…case 和 if…else效率比較和優化 MDN上的解釋 JavaScript 基礎知識-switch &amp; if else 的判別差異 avaScript 的 if 跟 switch 效能[http://tw.gitbook.net/javascript/javascript_switch_case.html]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"To be or Not To be？邏輯運算子","slug":"21-day10-logical","date":"2021-09-10T03:56:26.000Z","updated":"2022-04-13T12:57:30.000Z","comments":true,"path":"2021/09/10/21-day10-logical/","link":"","permalink":"https://popeye-ux.github.io/2021/09/10/21-day10-logical/","excerpt":"","text":"邏輯運算子(Logical Operator)有 AND &amp;&amp;、OR ||、NOT ! 三種。運算子兩側的值經過ToBoolean轉換後會得到一個布林值，再由邏輯運算子比較後傳回其中一個值。 &amp;&amp;以及||再進行判斷時，會對左邊的數值進行檢查，如果原本是布林值，就進行後續判斷。如果不是，則透過ToBoolean轉換為true或false。 AND &amp;&amp;：(條件&#x2F;運算式A) &amp;&amp; (條件&#x2F;運算式B)，如果兩側的值都為true，得到true的結果；如果其中一方為false，則得到false。如果第一個值轉換為true，則回傳第二個值，否則回傳第一個值。 OR ||：(條件&#x2F;運算式A) || (條件&#x2F;運算式B)，兩側的值只要有一側為true，就得到true的結果；如果兩側都為false，才得到false。如果第一個值轉換為true，則回傳第一個值，否則回傳第二個值。 NOT !：true的結果透過!轉換會得到false，而false的結果會變成true。 那些經過ToBoolean轉換後會得到false的值共有以下五種： undefined Null +0、-0 NaN 空字串””或’’ 其他的值都會轉為true。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"千算萬算的運算子","slug":"21-day9-operator","date":"2021-09-09T03:53:47.000Z","updated":"2022-04-13T12:55:44.000Z","comments":true,"path":"2021/09/09/21-day9-operator/","link":"","permalink":"https://popeye-ux.github.io/2021/09/09/21-day9-operator/","excerpt":"","text":"運算子算是比較繁雜的部分，需要多些耐心來理解與記憶，沒辦法用一個簡明的觀念來一以貫之。 算術運算子四則運算四則運算也就是加減乘除，一邊數字的加減乘除就像小學可本上教的一樣，由左而右，先乘除後加減。 在這個部分要注意的是： 不同型別的值進行四則運算的「自動轉型問題」。 特殊的數字如Infinity、-Infinity以及NaN進行運算時產生的特殊情形。 加號(+)正常情況下，當+加號兩邊都是數字，或者都是字串的情況下： var x = 1 + 2; console.log(x); //3 var y = '歐陽鋒是' + '一隻癩哈蟆'; console.log(y); //歐陽鋒是一隻癩哈蟆 在不同型別的狀況下： 當加號+兩側有一個是字串的情形下，會將「非字串」的那一邊「自動轉型」為字串，再將兩個字串連接在一起。 當一邊是數字，一邊是undefined的時候，undefined會被試著轉為數字，變成NaN，任何數字與NaN相加都是NaN。 當一邊是數字，加號另一邊是null的時候，null會被轉為數字0。 //數字與字串相加 77 + '49' //'7749' 77 + '四十九' //'77四十九' //字串與字串相加 '七七' + '四十九' //'七七四十九' 77 + &#123;&#125; //'77[object object]' //當數字要跟undefined相加的時候，udefined會被嘗試轉為數字，也就是NaN，還記得NaN的型別是number嗎？ 77 + unfined //NaN '七七' + unfined //'七七undefined' //當數字要與null相加時，null會被轉成數字 0 ; 77 + null //77 '七七' + null //77null 還要注意一些特別的數字：Infinity、-Infinity以及NaN。 Infinity + Infinity //Infinity -Infinity + -Infinity //-Infinity Infinity + -Infinity //NaN NaN與任何數字相加都是NaN 77 + NaN //NaN Infinity + NaN //NaN -Infinity + NaN //NaN '七七' + NaN //'七七NaN' 減號(-)如果是一般數字的四則運算，就是我們熟悉的算法。 如果遇到數字與基本型別相減，則基本型別的值會被轉為數字 49 - '36' //13 //字串會被轉為數字，也就是NaN 49 - 'abc' //NaN //布林值的true，會被轉行為數字 1 49 - true //48 //布林值的false，會被轉行為數字 0 49 - false //49 49 - undefined //NaN //null會轉為數字0 49 - null //49 如果減號的一側是物件型別的話，則會透過物件的valueOf()轉為對應的數字，如果得到NaN，那相減的結果就是NaN。 49 - &#123;&#125; //NaN 乘號(*)如果是一般數字的相乘，那就按照四則運算規則，有左而右計算。 如果其中一側不是數字，那就按照Number()轉為數字再進行計算，如果無法轉為數字，則為NaN。 如果其中一個數字為NaN，那計算出來的結果也是NaN。 49 * '10' //490 49 * '四十九' //NaN 49 * true // 49 49 * false //0 49 * &#123;&#125; //NaN 除號(&#x2F;)JS的除法規則與乘法一樣，但是有以下特殊情形： n&#x2F;0，n為正數時，結果為Infinity。 n&#x2F;0，n為負數時，結果為-Infinity。 0&#x2F;0，結果為NaN。 四則運算 數字 基本型別非數字 物件 減法 正常運算 Number()方法轉為數字 透過valueOf()轉為數字 乘法 正常運算 Number()方法轉為數字 Number()方法轉為數字 除法 正常運算 Number()方法轉為數字 Number()方法轉為數字 加法 正常運算 如果是number、boolean透過toString()方法轉為字串，null或undefined透過String()轉為字串 toString()轉為字串 JS四則運算規則表 算數運算子之 一元運算子正號(+)與負號(-)正號(+)與負號(-)用來表示一個數值是正數或是負數。 如果正號(+)與負號(-)後面跟的不是一個數字，則會透過Number()方法將之轉型為數字，再由前面的正號(+)與負號(-)判斷其數值。 var a = +49; var b = -49; var c = '+72'; var d = '-72'; var e = '天下無狗'; console.log(a); //49 console.log(b); //-49 console.log(+c); //72 console.log(-c); //-72 console.log(+d); //-72 console.log(-d); //72 console.log(-e) //NaN 如果是物件型別則使用valueOf()方法求得對應的值，再用正號(+)與負號(-)來判斷其數值，如果求得的值是NaN，那結果就是NaN。 遞增++與遞減–當變數遇上++，表示該變數加1；如果變數遇上 - -，則代表該變數減1。 a &#x3D; a+1可以用a++或 ++a表示。 a&#x3D; a-1 可以用a- -或 - - a表示。 ++在前面表示「運算前+1」；++在數字後面表示「運算後+1」。 —在前面代表「運算前-1」；- -在數字後方表示「運算後-1」。 var x = 49; var y = 49; console.log(x++); //49 console.log(++y); //50 console.log(x); //50 console.log(y); //50 將+ +放在變數x後面，console.log(x++)會傳回「原始的數值」。將++放在變數x前方，console.log(++x)會回傳「+1」的結果。 「+1」是在開團購嗎？那我「++」。 比較運算子比較運算子用來比較兩側的數值，比較之後得到布林值 true 或 false。 一個等號 &#x3D;，我們知道是「指定、賦值」的意思。 var x = 49; 在JavaScript中，「&#x3D; &#x3D;」是相等的意思，而「&#x3D;&#x3D;&#x3D;」是全等的意思。 var x = 49; //數字 var y = '49'; //字串 console.log(x == y); //true，因為 == 在比較兩側的變數是否相等的時候，會自動幫變數轉型。 true == '1'; //true false == '0'; //true true === \"1\"; //false false === \"0\"; //false 使用「&#x3D;&#x3D;」相等的時候，會自動替兩側的變數轉型。 當使用「&#x3D;&#x3D;&#x3D;」全等的時候，不會替變數自動轉型，是比較嚴謹的模式，也是比較推薦使用的方法。 比較特別的是，NaN不等於NaN，不管是 &#x3D;&#x3D; 還是&#x3D;&#x3D;&#x3D;，都是一樣 NaN不等於NaN。 &#x3D;&#x3D;的自動轉型規則： 當遇到「字串」與「數字」做比較的時候，字串會透過Number()嘗試轉為數字，再進行比較。 如果比較的一方為布林值，則true會轉為1，false會轉為0。 當 &#x3D;&#x3D;的一側為物件型別，另一側為基本型別，物件型別會透過valueOf()，轉為對應的基本型別進行比較。 不等於! &#x3D; 與 ! &#x3D;&#x3D; 「! &#x3D;」與「! &#x3D;&#x3D;」兩者都是不等於，但是「! &#x3D;」會替變數做自動轉型，而「! &#x3D;&#x3D;」不會替變數自動轉型，推薦使用「! &#x3D;&#x3D;」。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"人算不如天算的運算式","slug":"21-day8-expression","date":"2021-09-08T03:49:27.000Z","updated":"2022-04-13T12:57:22.000Z","comments":true,"path":"2021/09/08/21-day8-expression/","link":"","permalink":"https://popeye-ux.github.io/2021/09/08/21-day8-expression/","excerpt":"","text":"這個部分算是JavaScript比較難纏的部分，不是難以理解，而是因為比較冗雜，稍稍心浮氣躁，就沒辦法好好理解，所以我把它拆成兩個部分。 運算式(expression)是由運算元(operand)以及運算子(operator)所組成。 例如：1+2&#x3D;3 「+」是運算子，而 1、 2是運算元。 運算式可以分為以下幾種：指定運算式、算術運算式、字串運算式、布林運算式。 指定運算式利用指定運算子(&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;)，將運算式右邊的值「指定」給左邊。 x = 100; 算數運算式由常數、變數、函數、括號、運算子(+、-、*、&#x2F;)組合而成的運算式。 x + y; x++; (x + y) / z; 字串運算式利用「+」號將兩個字串組成一個新的字串。 let name ='洪七公' ,carrier = '丐幫幫主', hobby = '美食家'; hongQ = name + '不只是' + carrier + ',還是' + hobby; 布林運算式布林運算式通常搭配邏輯運算子(&amp;&amp; 、|| 、!)來比較兩個運算式。 let x = 20; let y = 10; (x > 15) &amp;&amp; (y > 5); //true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day7:如何檢查型別","slug":"21-day7-typeCheck","date":"2021-09-07T03:47:16.000Z","updated":"2022-04-13T12:50:12.000Z","comments":true,"path":"2021/09/07/21-day7-typeCheck/","link":"","permalink":"https://popeye-ux.github.io/2021/09/07/21-day7-typeCheck/","excerpt":"","text":"前面提到「變數本身沒有型別問題，變數帶的值才有型別資訊」，所以要判斷型別，當然是去檢查變數所帶的值。 我們可以這樣來判斷變數的型別： typeof 資料 typeof(資料) typeof '洪七公'; //'string' typeof 7749; //'number' typeof NaN; //'number' typeof true //'boolean' typeof &#123;&#125;; //'object' typeof []; //'object' typeof null; //'object' 用typeof檢查資料型別，回傳的都是字串，如果是為宣告的變數則回傳’undefined’。 如何判斷型別是否為NaN？比較特別的是： typeof NaN; //'number' 假設楊康這個小屁孩在應該填寫數字的表單裡面打了一堆亂碼，回傳給JavaScript判斷，parseInt()之後會給我們NaN的結果，此時就不能使用(typeof(xx) ! &#x3D;&#x3D; number)來判斷，因為遇到 typeof NaN的回傳值會是’number’。 ※ parseInt()可以用來將資料轉為整數，由字串最左邊開始轉換，一值轉換到字串結束或遇到非數字字元為止。 這時要使用 isNaN() 來判斷傳回的資料是否為’NaN’，如果不是，傳回的是false，才進行後面的計算。 如何判斷型別是否為陣列？因為使用typeof去檢查陣列，得到的結果會是 ‘object’，所以該如何正確地判斷某個變數為陣列，而非物件？ 這時要使用 isArray() 這個方法。 array.isArray([]); //true array.isArray(['東邪','西毒','北丐','南帝','中神通']); //true array.isArray(&#123;&#125;); //false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day6:長幼有序的好孩子：陣列","slug":"21-day6-array","date":"2021-09-06T03:00:21.000Z","updated":"2022-04-13T12:02:10.000Z","comments":true,"path":"2021/09/06/21-day6-array/","link":"","permalink":"https://popeye-ux.github.io/2021/09/06/21-day6-array/","excerpt":"","text":"陣列算是一種「特殊物件」，可以在裡面放入0到多個元素，裡面的元素可以是字串、數字等原始型別資料、也可以是另一個陣列或另一個物件。與物件的差別在於，陣列是有順序的集合，每個元素都有其索引值，並且可以用length的屬性來取得陣列的長度。 如何建立陣列?普遍的做法是採用「陣列實字」(Array Literal)的方式： //建立一個華山論劍(huaShan)的陣列 var huaShan = ['東邪','西毒','北丐','南帝','中神通']; console.log(huaShan.length); //5 huaShan這個陣列有5個元素，所以長度為5 console.log(huaShan[0]); //'東邪' 陣列的索引值從0開始算，所以第一個元素的索引值為0。 console.log(huaShan[1]); //'西毒' 陣列的索引值從0開始算，所以第二個元素的索引值為1。 這樣也可以建立陣列： //建立一個華山論劍(huaShan)的「空」陣列 var huaShan = []; huaShan[0] = '東邪'; huaShan[1] = '西毒'; huaShan[2] = '北丐'; huaShan[3] = '南帝'; huaShan[4] = '中神通'; console.log(huaShan); // [object Array] (5) [\"東邪\",\"西毒\",\"北丐\",\"南帝\",\"中神通\"] console.log(huaShan.length); // 5 還有一種方式是透過new關鍵字來建立物件： //建立一個江南七怪(sevenMonster)的陣列 var sevenMonster = new Array(); sevenMonster[0] = '柯鎮惡'; sevenMonster[1] = '朱聰'; sevenMonster[2] = '韓寶駒'; sevenMonster[3] = '南希仁'; sevenMonster[4] = '張阿生'; sevenMonster[5] = '全金發'; sevenMonster[6] = '韓小瑩'; console.log(sevenMonster.length); // 7 陣列並不需要連續指定，沒被指定的其索引值為 undefined。 就像江南七怪在大漠時，五哥「笑彌陀」張阿生被「銅屍」陳玄風殺死，只剩六怪，但是排序是不變的，不會六弟變五哥，七妹變六妹，五哥空出來的位置就變成’undefined’。 //建立一個江南七怪(sevenMonster)的陣列，但是五哥「笑彌陀」張阿生被「銅屍」陳玄風殺死，只剩六怪 var sevenMonster = new Array(); sevenMonster[0] = '柯鎮惡'; sevenMonster[1] = '朱聰'; sevenMonster[2] = '韓寶駒'; sevenMonster[3] = '南希仁'; //但是五哥「笑彌陀」張阿生被「銅屍」陳玄風殺死，sevenMonster[4]，不予指定。 sevenMonster[5] = '全金發'; sevenMonster[6] = '韓小瑩'; console.log(sevenMonster.length); // 7 console.log(sevenMonster); //['柯鎮惡','朱聰','韓寶駒','南希仁','undefined','全金發','韓小瑩']; //sevenMonster第五個元素，也就是sevenMonster[4]的元素變成'undefined' 我們可以利用 .length 的屬性來取得陣列的長度，或利用它來改變陣列的長度。 如果length設得比原本的陣列長度還要長，多出來的元素將以’undefined’填補。如果length設的比原本陣列長度少，則多出來的元素將被刪除，即使之後length設回原來長度，被刪掉的元素也不會恢復，而會以’undefined’取代。 //建立一個江南七怪(sevenMonster)的陣列 var sevenMonster = ['柯鎮惡','朱聰','韓寶駒','南希仁','張阿生','全金發','韓小瑩']; console.log(sevenMonster.length); // 7 //江南七怪後來被陳玄風及楊康分別殺害，只剩柯鎮惡一人。 sevenMonster.length = 1; console.log(sevenMonster); // ['柯鎮惡']; //人死不能復生，即使再把江南七怪(sevenMonster)的length設為7，後面的六位大俠也都是'undefined' sevenMonster.length = 7; console.log(sevenMonster); //['柯鎮惡','undefined','undefined','undefined','undefined','undefined','undefined'] 陣列可以使用的方法列舉如下： pop()：取出陣列尾端元素。 push()：新增元素至陣列的尾端。 shift()：取出陣列的第一個元素 unshift()：新增元素至陣列開端。 //建立一個華山(huaShan)的陣列 var huaShan = ['東邪','西毒','北丐','南帝','中神通']; huaShan.pop(); console.log(huaShan); //['東邪','西毒','北丐','南帝'] huaShan.pop()取出了陣列的最後一個元素 huaShan.push('中頑童'); console.log(huaShan); //['東邪','西毒','北丐','南帝','中頑童']; huaShan.shift(); console.log(huaShan); //['西毒','北丐','南帝','中頑童'] huaShan.unshift('東方不敗'); //['東方不敗','西毒','北丐','南帝','中頑童']; //東方不敗跑錯棚了 學會陣列與物件之後，我們就可以開始用JavaScript來處理一些網頁上擷取來的資料，就像學內功要先學打坐練習呼吸一樣。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽, array","slug":"JavaScript-2021iT邦鐵人賽-array","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD-array/"}]},{"title":"Day5:不可貌相的JS變數型別：如何練成一個物件","slug":"21-day5-object","date":"2021-09-05T02:55:58.000Z","updated":"2022-04-13T11:59:12.000Z","comments":true,"path":"2021/09/05/21-day5-object/","link":"","permalink":"https://popeye-ux.github.io/2021/09/05/21-day5-object/","excerpt":"","text":"前面提到除了string、number、boolean、null和undefined等5種基本型別之外，其他的值都是物件型別。 那什麼是物件呢？ 物件是0到多種屬性的集合，而所謂的屬性是一組鍵(key)與值(value)的配對關聯。值的內容可以是字串、數字等基本型別，也可以是另一個物件，或是一個函數。 如何建立一個自定義的物件？現在最常見的方法就是使用**「物件實字」(Object literal)**的方法，用一個大括號{}建立一個物件，同時在大括號中直接建立屬性及方法。 //使用「物件實字」建立一個郭靖(guoJing)的物件 var guoJing = &#123; name: '郭靖', gender: 'male', skill: '降龍十八掌', useSkill: function () &#123; alert('降龍十八掌之亢龍有悔') &#125; &#125; 而在早期要建立一個物件，會使用new 關鍵字來建立一個物件實體，再用「物件.屬性」的方式替這個物件新增屬性及方法。 //使用「new」關鍵字建立一個郭靖(guoJing)的物件 var guoJing = new Object(); guoJing.name = '郭靖'; guoJing.gender= 'male'; guoJing.skill= '降龍十八掌'; guoJing.useSkill: function () &#123; alert('降龍十八掌之亢龍有悔') &#125; 至於如何新增與刪除屬性，可以用下面這種方式： //建立一個郭靖(guoJing)的物件,裡面不放任何屬性 var guoJing = &#123;&#125; //建立name的屬性 guoJing.name = '郭靖'; //建立skill的屬性 guoJing.skill= '降龍十八掌'; //刪除 guoJing.skill 這個屬性 delete guoJing.skill; console.log(guoJing.skill) //undefined 前面提到用物件實字的方式建立物件，這也是JSON格式的核心語法，JavaScript透過JSON來撈取外部的資料到程式內部使用。 物件就像是樂高，可以自由拼裝想要形狀與組件，自己養成一個天下武功第一的大俠。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽, 變數","slug":"JavaScript-2021iT邦鐵人賽-變數","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD-%E8%AE%8A%E6%95%B8/"}]},{"title":"Day4:不可貌相的JS變數型別：基本型別","slug":"21-day4-variableType","date":"2021-09-04T02:52:10.000Z","updated":"2022-04-13T11:57:02.000Z","comments":true,"path":"2021/09/04/21-day4-variableType/","link":"","permalink":"https://popeye-ux.github.io/2021/09/04/21-day4-variableType/","excerpt":"","text":"俗話說：「人不可貌相，海水不可斗量。」就像我們看到郭靖傻不楞登，怎麼知道他武功高強。楊康外表英俊，能言善道，卻一肚子壞水。 變數也跟人一樣，從外觀無法判斷內涵。變數本身沒有型別，它所裝的「值」才有型別。 變數的型別可以分為基本型別 (Primitives) 與 物件型別(Object) 兩類。 變數的基本型別有以下5種： 字串(string) 數字(number) 布林(boolean) null undefined 最重要的是，除了以上幾種之外，其他都是「物件」。 字串string字串必須用2個單引號’’或是2個雙引號包住，二者不可混用。 字串內也可以不放任何字元，稱之為空字串。 字串可以使用+號與其他字串連接。 //字串(string)，必須要放在''或是\"\"之中 var guoJing = '降龍十八掌'; //空字串 var guoJing = ''; //字串連接可以使用+號 var huangRong = '黃蓉'+'打狗棒法'; //兩個單引號包覆單引號，會出錯 var yangKang = 'He's a bad man'; //改用雙引號包覆單引號，就沒有問題 var yangKang = \"He's a bad man\"; 數字number不管是整數還是帶有小數點的浮點數在JavaScript中都屬於數字這個類型。 //數字(number),玉山有3952公尺 var jadeMountain = 3952; 但是數字number中有幾個比較特別的類型： infinity 正的無限大，非0的數字除以0，結果都是infinity，例如 3&#x2F;0會回傳infinity。 -infinity 負的無限大，負數除以0，結果都是-infinity，例如-3&#x2F;0會回傳-infinity。 NaN 不是個數字，當遇到無法轉換為數字的狀態，或是無意義的運算，例如0&#x2F;0，就會回傳NaN。而且NaN與任何數字做運算，回傳的結果都是NaN。 我們可以使用isNaN()來檢查一個變數是不是NaN。 //infinity console.log(3/0); //-infinity console.log(-3/0) //NaN console.log(0/0); //檢查是否為NaN isNaN('降龍十八掌') //NaN 布林值 booleanboolean只有二種值：true 和 false。主要用在判斷式，作為程式流程控制之用。 var real = true; var fake = false; var more = (100 > 50); //true 任何值都可以轉為布林值，但我們只要記得會轉為false的值就可以了。 以下幾種會轉為false：false、0、空字串(“”)、NaN、null以及undefined。 除了上述幾種，其他的值皆為true。 試試看用Boolean()函數將值轉換為布林值： Boolean(1); //true Boolean(0); //false Boolean(\"\"); //false Boolean(null); //false nullnull代表「空值」，所以要將一個變數的值清除？可以指定那個變數為null。 //郭靖本來的內力值為100分 var guoJing = 100; console.log(guoJing); //100 //郭靖中毒後，一點功力都提不起來 var guoJing = null; console.log(guoJing); //null undefinedundefined指的是變數未經宣告，且沒有賦值；或者是有宣告變數，但是沒有給定值的狀態。 var x; console.log(x); //undefined 引用許國政先生在《0 陷阱！0 誤解！8 天重新認識JavaScript！》為undefined以及null下的註解： 『 undefined代表的是「(此變數)還沒有給值，所以不知道是什麼」。 null代表的是「(此變數可能曾經有值，可能沒有值)現在沒有值」 』 以上就是JavaScript的五種基本型別。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽, 變數","slug":"JavaScript-2021iT邦鐵人賽-變數","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD-%E8%AE%8A%E6%95%B8/"}]},{"title":"變數宣告var、let、const的區別","slug":"21-day3-varLetConst","date":"2021-09-03T02:31:25.000Z","updated":"2022-04-13T11:33:28.000Z","comments":true,"path":"2021/09/03/21-day3-varLetConst/","link":"","permalink":"https://popeye-ux.github.io/2021/09/03/21-day3-varLetConst/","excerpt":"","text":"但是老師教我用var宣告變數，但我也看到有同學用 let 與 const 宣告變數，這是怎麼一回事呢？ //建立一個變數郭靖(guoJing) var guoJing; 也可以看到這樣： //建立一個建立一個名為黃蓉(huangRong)的變數，給她'打狗棒法'的值 let huangRong = '打狗棒法'; //建立一個洪七公(hongQigong)的常數，給他「北丐」的值 const hongQigong = '北丐'; var、let、const這三兄弟到底有甚麼差別呢？ 原來除了用var宣告變數之外，在ES6之後，變數區分為變數與常數，透過 var 與 let 宣告「變數」，透過const宣告「常數」。 var 和 let 最大的區別在於「作用域」不同，這一點我們先放在心上，之後再深入探討。 先來看看var： //建立一個變數郭靖(guoJing) var guoJing; console.log(guoJing); //未賦值，所以出現的結果為 undefined guoJing = '降龍十八掌'; console.log('郭靖使出 ' + guoJing); //結果為\"郭靖使出 降龍十八掌\" guoJing = '空明拳'; console.log('郭靖使出 ' + guoJing); //結果為\"郭靖使出 空明拳\" var guoJing = '九陰真經'; //再次用var宣告 guoJing = '九陰真經'; console.log('郭靖使出 ' + guoJing); //結果為\"郭靖使出 九陰真經\" 使用var的時候，同一個變數名稱可以再重新「宣告」，重新賦值。 再看看使用let的狀況： //建立一個建立一個名為黃蓉(huangRong)的變數，給她'打狗棒法'的值 let huangRong; huangRong = '打狗棒法'; console.log('黃蓉使出 ' + huangRong); //結果為\"黃蓉使出 打狗棒法\" huangRong = '落英神劍掌'; console.log('黃蓉使出 ' + huangRong); //結果為\"黃蓉使出 落英神劍掌\" let huangRong = '蘭花拂穴手'; //Uncaught SyntaxError: Identifier 'huangRong' has already been declared 使用 let 比使用 var 來宣告變數嚴謹，如果宣告時未賦值，並不會以undefined初始化，所以從宣告到初始化這段時間會無法使用，這個時間差稱為「暫時死區」。 let 能重複賦值，但是同一個變數名稱只能宣告一次，如果重複宣告會出現： 「Uncaught SyntaxError: Identifier ‘huangRong’ has already been declared」 提醒你已經用let宣告過這個變數了。 讓我們來試試const： //建立一個洪七公(hongQigong)的常數，給他「北丐」的值 const hongQigong = '北丐'; console.log('洪七公是 ' + hongQigong); hongQigong = '美食家'; //Uncaught TypeError: Assignment to constant variable. const hongQigong = '美食家'; //Uncaught SyntaxError: Identifier 'hongQigong' has already been declared const是用來宣告常數，也就是不會變動的常量，所以不能重複宣告，也不能重複賦值。 重複宣告會告訴你： 「Uncaught SyntaxError: Identifier ‘hongQigong’ has already been declared」 重複賦值則會提醒你： 「Uncaught TypeError: Assignment to constant variable.」 因為以上這些區別，使用var、let、const來宣告變數的時機與場景有不同的區別，語意上也有明確區分。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day1:起手式—變數宣告","slug":"21-declaration","date":"2021-09-02T02:19:13.000Z","updated":"2022-04-13T11:30:00.000Z","comments":true,"path":"2021/09/02/21-declaration/","link":"","permalink":"https://popeye-ux.github.io/2021/09/02/21-declaration/","excerpt":"","text":"剛開始接觸程式語言，總會聽老師說：「我們現在來var一個變數…」 哇！什麼是var？甚麼是變數？當時我滿頭問號！但是隨著練習增加經驗，建立變數會變得像是呼吸一樣理所當然。 簡單來說，變數就是一個容器，裡面裝著你想要電腦幫你運算的資料。 先讓我們不專業的方式來理解一下： //假設我們建立一個名為郭靖(guoJing)的變數，給他 '降龍十八掌'的值 var guoJing = '降龍十八掌'; //建立一個名為黃蓉(huangRong)的變數，給她'打狗棒法'的值 var huangRong = '打狗棒法'; //建立一個名為歐陽鋒(ouyangFeng)的變數，給他'蛤蟆功'的值 var ouyangFeng = '蛤蟆功'; 我們把武功裝在名為郭靖(guoJing)、黃蓉(huangRong)與歐陽鋒(ouyangFeng)的三個變數裡面，就可以讓他們在電腦中華山論劍，用功夫決鬥，你裝什麼功夫在變數裡面，他們就用什麼功夫決鬥。 建立變數包含2個動作： 宣告：就是給變數一個名稱。 初始化：給變數一個初始值。 我們可以先宣告變數，同時賦予初始值，也可以之後再給初始值。 //宣告變數郭靖(guoJing)，同時賦予初始值 var guoJing = '降龍十八掌'; //先宣告黃蓉(huangRong)，之後再賦值 var huangRong; huangRong = '打狗棒法'; 也可以這樣，建立多個變數，之間用逗點 ( , )隔開，之後再給他們值。 var var guoJing, huangRong, ouyangFeng; guoJing = '降龍十八掌'; huangRong = '打狗棒法'; ouyangFeng = '蛤蟆功'; 再來談談變數的規則： 變數的第一個字母必須為英文字母、底線_、錢字符號$，不可以使用數字。 變數名稱不可以是JavaScript的保留字（Reserved Words）或關鍵字（keywords）。 JavaScript有區分大小寫，變數monkey與變數Monkey會被認為是不同的變數。 JavaScript支援Unicode，所以變數名稱可以用中文命名，避免其他語言系統開啟會變亂碼，所以不建議使用，還是讓郭靖與黃蓉講英文吧。 如果變數未經宣告就要使用的話，會出現ReferenceError的狀況。 宣告變數就是JavaScript的起手式，理解了這些，我們就可以進一步去理解變數的型別與應用。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]},{"title":"Day0:為什麼踏入前端這個領域?","slug":"21-foreword","date":"2021-09-01T10:51:43.000Z","updated":"2022-04-13T11:28:52.000Z","comments":true,"path":"2021/09/01/21-foreword/","link":"","permalink":"https://popeye-ux.github.io/2021/09/01/21-foreword/","excerpt":"","text":"在寫前言的時候，我已經寫完鐵人賽的29篇文章了！ 在寫技術文的過程中，我彷彿看到去年那個一竅不通，一路撞壁，在未知中摸索的自己。 看著Notion裡面靜靜躺著的28篇文章，此刻心中充滿著感動。 為什麼會想要投入前端工程師的這個領域呢？何況是中年轉職，在這個領域似乎都是年紀很小就開始摸網頁、摸程式了，我這個年紀的人似乎沒有優勢！ 我本來在某媒體擔任繪圖師，去年二月底，疫情開始爆發的時候，我任職的公司結束了營運。當時踏出公司大門的時候，我的內心有種解脫的感覺：「你終於從媒體畢業了！」內心有種從此不要再踏入這一行的念頭。 離職後，一邊休息也同時對未來感到茫然！想到自己在媒體後期當救火隊員，用Bootstrape幫公司做了幾個新聞專題網頁，似乎以前學過的HTML與CSS還像是刻在我心裡的名字…盧廣仲上身！Sorry！而且捉了幾個JavaScript回來改改參數，似乎也跑得很順！（這個錯覺讓我跳入了前端工程師這個大坑！我被這個錯覺騙了！） 就像念魔咒一樣，我們都知道前端有三大要素： HTML負責網頁架構與內容 CSS負責網頁外觀與樣式 JavaScript負責資料與互動 那個時候，我想HTML跟CSS我都摸過(水果攤老闆說：少年仔！摸過就要買喔！不買剁手！)那只要搞懂JavaScript就好的！ But，人生最厲害的就是這個But！多麼痛的領悟！ 從變數宣告開始，我就好像在跟外星人學講話一樣，外星人講話變來變去，老師一下var一個B（怎麼罵髒話呢?），B一下又變成別的值，那麼容易變來變去，真的是JavaScript裡面沒有真愛！變數在function裡面跟你很熟，在外面就變成了陌生人！對於門外漢而言，想到腦筋都打結了！ 至於迴圈與邏輯判斷，更讓我像是踩進黃藥師的五行八卦陣裡面，繞了好久都繞不出來！我以為自己聰明才智如楊過，卻發現自己是怎麼學都學不會的傻郭靖。這一年來就在撞壁受傷，爬起再戰的輪迴中慢慢前進。 滿謝謝六角學院的，上過他們《學徒的試煉》線上課程，讓我了解許多實務上的做法。也謝謝Kuro大大許國政寫的《0 陷阱！0 誤解！8 天重新認識 JavaScript！》，這本書深入淺出的介紹了許多JavaScript的觀念，算是我的武功心法，雖然他的1天，可能要花掉我半個月的時間才能搞懂 XD。 這28篇文章就是我學JavaScript的筆記，這些主題很多人寫過，但這就是我自己摸索著走過的路，一路上想辦法把難的、複雜的事物用簡單的概念讓自己理解的過程！當然這只是一個起點，後面還有更大的坑在等著我。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"}]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://popeye-ux.github.io/categories/JavaScript/"},{"name":"PlugIn","slug":"PlugIn","permalink":"https://popeye-ux.github.io/categories/PlugIn/"},{"name":"Vue3","slug":"Vue3","permalink":"https://popeye-ux.github.io/categories/Vue3/"},{"name":"雜記","slug":"雜記","permalink":"https://popeye-ux.github.io/categories/%E9%9B%9C%E8%A8%98/"},{"name":"CSS","slug":"CSS","permalink":"https://popeye-ux.github.io/categories/CSS/"},{"name":"VS Code","slug":"VS-Code","permalink":"https://popeye-ux.github.io/categories/VS-Code/"}],"tags":[{"name":"JavaScript,array,sort,indexOf","slug":"JavaScript-array-sort-indexOf","permalink":"https://popeye-ux.github.io/tags/JavaScript-array-sort-indexOf/"},{"name":"JavaScript, dom-to-image, plugin","slug":"JavaScript-dom-to-image-plugin","permalink":"https://popeye-ux.github.io/tags/JavaScript-dom-to-image-plugin/"},{"name":"Vue3, JavaScript, checkbox, computed,methods","slug":"Vue3-JavaScript-checkbox-computed-methods","permalink":"https://popeye-ux.github.io/tags/Vue3-JavaScript-checkbox-computed-methods/"},{"name":"Vue3, JavaScript, ref, Modal","slug":"Vue3-JavaScript-ref-Modal","permalink":"https://popeye-ux.github.io/tags/Vue3-JavaScript-ref-Modal/"},{"name":"雜記","slug":"雜記","permalink":"https://popeye-ux.github.io/tags/%E9%9B%9C%E8%A8%98/"},{"name":"Vue3, JavaScript, Vee-Valdate, Validate","slug":"Vue3-JavaScript-Vee-Valdate-Validate","permalink":"https://popeye-ux.github.io/tags/Vue3-JavaScript-Vee-Valdate-Validate/"},{"name":"Vue3, Javascript, env, g-tag","slug":"Vue3-Javascript-env-g-tag","permalink":"https://popeye-ux.github.io/tags/Vue3-Javascript-env-g-tag/"},{"name":"Vue3, JavaScript, createWebHashHistory, createWebHistory","slug":"Vue3-JavaScript-createWebHashHistory-createWebHistory","permalink":"https://popeye-ux.github.io/tags/Vue3-JavaScript-createWebHashHistory-createWebHistory/"},{"name":"Vue, pinia, compositionAPI, optionAPI","slug":"Vue-pinia-compositionAPI-optionAPI","permalink":"https://popeye-ux.github.io/tags/Vue-pinia-compositionAPI-optionAPI/"},{"name":"Vue, modal, pinia","slug":"Vue-modal-pinia","permalink":"https://popeye-ux.github.io/tags/Vue-modal-pinia/"},{"name":"Vue, modal, props, emit","slug":"Vue-modal-props-emit","permalink":"https://popeye-ux.github.io/tags/Vue-modal-props-emit/"},{"name":"CSS, hover","slug":"CSS-hover","permalink":"https://popeye-ux.github.io/tags/CSS-hover/"},{"name":"CSS, target","slug":"CSS-target","permalink":"https://popeye-ux.github.io/tags/CSS-target/"},{"name":"Vue, Computeds","slug":"Vue-Computeds","permalink":"https://popeye-ux.github.io/tags/Vue-Computeds/"},{"name":"Vue, Vue3, JavaScript","slug":"Vue-Vue3-JavaScript","permalink":"https://popeye-ux.github.io/tags/Vue-Vue3-JavaScript/"},{"name":"VS Code,樣板自面值,HTML補全","slug":"VS-Code-樣板自面值-HTML補全","permalink":"https://popeye-ux.github.io/tags/VS-Code-%E6%A8%A3%E6%9D%BF%E8%87%AA%E9%9D%A2%E5%80%BC-HTML%E8%A3%9C%E5%85%A8/"},{"name":"JavaScript,this,箭頭函式","slug":"JavaScript-this-箭頭函式","permalink":"https://popeye-ux.github.io/tags/JavaScript-this-%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F/"},{"name":"JavaScript, JS直播班","slug":"JavaScript-JS直播班","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD/"},{"name":"JavaScript, JS直播班, C3.js","slug":"JavaScript-JS直播班-C3-js","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD-C3-js/"},{"name":"JavaScript, JS直播班, array","slug":"JavaScript-JS直播班-array","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD-array/"},{"name":"JavaScript, JS直播班, hoisting","slug":"JavaScript-JS直播班-hoisting","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD-hoisting/"},{"name":"JavaScript, JS直播班, 物件","slug":"JavaScript-JS直播班-物件","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD-%E7%89%A9%E4%BB%B6/"},{"name":"JavaScript,JS直播班","slug":"JavaScript-JS直播班","permalink":"https://popeye-ux.github.io/tags/JavaScript-JS%E7%9B%B4%E6%92%AD%E7%8F%AD/"},{"name":"JavaScript, 2021iT邦鐵人賽","slug":"JavaScript-2021iT邦鐵人賽","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"JavaScript, 2021iT邦鐵人賽, array","slug":"JavaScript-2021iT邦鐵人賽-array","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD-array/"},{"name":"JavaScript, 2021iT邦鐵人賽, 變數","slug":"JavaScript-2021iT邦鐵人賽-變數","permalink":"https://popeye-ux.github.io/tags/JavaScript-2021iT%E9%82%A6%E9%90%B5%E4%BA%BA%E8%B3%BD-%E8%AE%8A%E6%95%B8/"}]}